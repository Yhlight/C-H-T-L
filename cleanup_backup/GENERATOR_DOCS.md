# CHTL生成器文档

## 概述

CHTL生成器实现了CHTL语法到HTML/CSS/JS的转换，完整支持以下特性：

- **注释处理**：三种注释类型的不同处理方式
- **文本节点**：`text { }` 语法支持
- **字面量**：无修饰字面量、双引号、单引号字符串
- **CE对等式**：`:` 和 `=` 完全等价
- **元素节点**：所有HTML元素支持
- **属性**：灵活的属性语法
- **局部样式块**：智能的样式处理和提取

## 核心功能实现

### 1. 注释处理

```cpp
// 单行注释 - 不会出现在生成的HTML中
generator.processSingleLineComment("// 这是单行注释");

/* 多行注释 - 不会出现在生成的HTML中 */
generator.processMultiLineComment("/* 这是多行注释 */");

// 生成器注释 - 会转换为HTML注释
generator.processGeneratorComment("-- 这是生成器注释");
// 输出: <!-- 这是生成器注释 -->
```

### 2. 文本节点

```cpp
// text块处理
generator.beginTextBlock();
generator.generateTextNode("这是一段文本");          // 无引号
generator.generateTextNode("\"带双引号的文本\"");    // 双引号
generator.generateTextNode("'带单引号的文本'");      // 单引号  
generator.endTextBlock();
```

**特点**：
- 自动处理引号（有则去除）
- HTML特殊字符自动转义
- 支持多种字面量格式

### 3. 字面量处理

生成器的 `LiteralProcessor` 类提供了完整的字面量支持：

```cpp
// 无修饰字面量
LiteralProcessor::isUnquotedLiteral("red");        // true
LiteralProcessor::isUnquotedLiteral("\"red\"");    // false

// 移除引号
LiteralProcessor::removeQuotes("\"text\"");        // 返回: text
LiteralProcessor::removeQuotes("text");            // 返回: text

// CSS值处理
LiteralProcessor::processCSSValue("red");          // 返回: red
LiteralProcessor::processCSSValue("hello world");  // 返回: "hello world"
```

### 4. 属性生成

```cpp
// 支持CE对等式
std::unordered_map<std::string, std::string> attrs = {
    {"id", "box"},              // 使用 :
    {"class", "container"},     // 使用 =
    {"data-value", "\"123\""}   // 带引号的值
};
generator.generateElement("div", attrs);
// 输出: <div id="box" class="container" data-value="123">
```

### 5. 局部样式块

#### 内联样式
```cpp
generator.beginStyleBlock();
generator.generateInlineStyle("width", "100px");
generator.generateInlineStyle("height", "200px");
generator.endStyleBlock();
// 样式会作为style属性添加到元素
```

#### 自动化类名
```cpp
generator.generateElement("div", {});
generator.beginStyleBlock();

// 自动为div添加类名"box"
std::vector<std::pair<std::string, std::string>> styles = {
    {"width", "300px"},
    {"padding", "10px"}
};
generator.generateClassRule("box", styles);

generator.endStyleBlock();
generator.closeElement();

// HTML输出: <div class="box"></div>
// CSS输出: .box { width: 300px; padding: 10px; }
```

#### 自动化ID
```cpp
generator.generateIdRule("header", {
    {"font-size", "24px"},
    {"color", "blue"}
});
// 自动为当前元素添加id="header"
// CSS输出: #header { font-size: 24px; color: blue; }
```

#### 上下文推导（&符号）
```cpp
// 先添加类名
generator.generateClassRule("button", buttonStyles);

// 使用&符号
generator.generatePseudoRule(":hover", hoverStyles);
// 输出: .button:hover { ... }

generator.generatePseudoRule("::before", beforeStyles);
// 输出: .button::before { ... }
```

## 生成器架构

### CHTLGenerator 类

主要生成器类，负责协调整个生成过程：

```cpp
class CHTLGenerator {
    // 三个输出流
    std::stringstream htmlOutput;   // HTML内容
    std::stringstream cssOutput;    // 全局CSS
    std::stringstream jsOutput;     // JavaScript代码
    
    // 样式管理
    std::vector<StyleRule> globalStyles;
    std::unordered_map<std::string, std::string> autoGeneratedClasses;
    std::unordered_map<std::string, std::string> autoGeneratedIds;
};
```

### StyleExtractor 类

负责提取和管理样式规则：

```cpp
class StyleExtractor {
    // 判断是否应该提取到全局
    bool shouldExtractToGlobal(const std::string& selector);
    
    // 生成全局样式块
    std::string generateGlobalStyleBlock();
};
```

提取规则：
- 类选择器（`.class`）→ 全局CSS
- ID选择器（`#id`）→ 全局CSS  
- 伪类/伪元素（`:hover`、`::before`）→ 全局CSS
- 普通属性 → 内联样式

### CommentProcessor 类

处理不同类型的注释：

```cpp
CommentProcessor::CommentType detectCommentType(const std::string& text);
std::string extractCommentContent(const std::string& text, CommentType type);
std::string formatAsHTMLComment(const std::string& content);
```

## 使用示例

### 完整示例

```cpp
// 创建生成器
auto context = std::make_shared<CHTLContext>();
GeneratorOptions options;
options.preserveGeneratorComments = true;
options.extractStyleToGlobal = true;

CHTLGenerator generator(context, options);

// 生成HTML结构
generator.processGeneratorComment("主容器");
generator.generateElement("div", {});
generator.beginStyleBlock();

// 添加容器样式
generator.generateClassRule("container", {
    {"max-width", "1200px"},
    {"margin", "0 auto"},
    {"padding", "20px"}
});

// 添加hover效果
generator.generatePseudoRule(":hover", {
    {"background", "#f0f0f0"}
});

generator.endStyleBlock();

// 添加内容
generator.beginTextBlock();
generator.generateTextNode("欢迎使用CHTL");
generator.endTextBlock();

generator.closeElement();

// 获取输出
std::string html = generator.getCombinedOutput();
```

### 输出结果

```html
<!DOCTYPE html>
<html>
<head>
<style>
.container {
  max-width: 1200px;
  margin: 0 auto;
  padding: 20px;
}

.container:hover {
  background: #f0f0f0;
}
</style>
</head>
<body>
<!-- 主容器 -->
<div class="container">
  欢迎使用CHTL
</div>
</body>
</html>
```

## 高级特性

### 1. 自动编号

生成器会自动为类名和ID添加编号，避免冲突：

```cpp
generator.generateAutoClassName("btn");   // 返回: btn_1
generator.generateAutoClassName("btn");   // 返回: btn_2
generator.generateAutoId("header");       // 返回: header_1
```

### 2. 样式智能提取

- 内联样式保留在元素上
- 选择器样式提取到全局
- 自动去重和优化

### 3. 嵌套支持

生成器维护元素栈，支持任意深度的嵌套：

```cpp
generator.generateElement("div", {});    // 推入栈
generator.generateElement("span", {});   // 推入栈
generator.closeElement();                // 弹出span
generator.closeElement();                // 弹出div
```

### 4. 错误处理

- 自动处理未闭合的标签
- 验证选择器格式
- 转义特殊字符

## 最佳实践

1. **使用自动化功能**：让生成器自动管理类名和ID
2. **利用上下文推导**：使用`&`符号简化伪类/伪元素
3. **合理组织样式**：内联样式用于特定元素，选择器样式用于可复用规则
4. **保持语义化**：使用有意义的类名和ID
5. **注释规范**：使用`--`注释重要的结构信息