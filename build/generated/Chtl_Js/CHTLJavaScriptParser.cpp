
// Generated from /workspace/grammar/CHTLJavaScript.g4 by ANTLR 4.10


#include "CHTLJavaScriptVisitor.h"

#include "CHTLJavaScriptParser.h"


using namespace antlrcpp;

using namespace antlr4;

namespace {

struct CHTLJavaScriptParserStaticData final {
  CHTLJavaScriptParserStaticData(std::vector<std::string> ruleNames,
                        std::vector<std::string> literalNames,
                        std::vector<std::string> symbolicNames)
      : ruleNames(std::move(ruleNames)), literalNames(std::move(literalNames)),
        symbolicNames(std::move(symbolicNames)),
        vocabulary(this->literalNames, this->symbolicNames) {}

  CHTLJavaScriptParserStaticData(const CHTLJavaScriptParserStaticData&) = delete;
  CHTLJavaScriptParserStaticData(CHTLJavaScriptParserStaticData&&) = delete;
  CHTLJavaScriptParserStaticData& operator=(const CHTLJavaScriptParserStaticData&) = delete;
  CHTLJavaScriptParserStaticData& operator=(CHTLJavaScriptParserStaticData&&) = delete;

  std::vector<antlr4::dfa::DFA> decisionToDFA;
  antlr4::atn::PredictionContextCache sharedContextCache;
  const std::vector<std::string> ruleNames;
  const std::vector<std::string> literalNames;
  const std::vector<std::string> symbolicNames;
  const antlr4::dfa::Vocabulary vocabulary;
  antlr4::atn::SerializedATNView serializedATN;
  std::unique_ptr<antlr4::atn::ATN> atn;
};

std::once_flag chtljavascriptParserOnceFlag;
CHTLJavaScriptParserStaticData *chtljavascriptParserStaticData = nullptr;

void chtljavascriptParserInitialize() {
  assert(chtljavascriptParserStaticData == nullptr);
  auto staticData = std::make_unique<CHTLJavaScriptParserStaticData>(
    std::vector<std::string>{
      "singleExpression", "chtlSelectorList", "chtlSelector", "chtlSelectorContent", 
      "cssSelector", "cssSelectorPart", "listenObject", "eventBinding", 
      "delegateObject", "delegateProperty", "selectorArray", "animateCall", 
      "animateObject", "animateProperty", "cssObject", "cssProperty", "whenArray", 
      "whenObject", "whenProperty", "literal", "program", "statement", "block", 
      "variableStatement", "variableDeclarationList", "varModifier", "variableDeclaration", 
      "emptyStatement", "expressionStatement", "ifStatement", "iterationStatement", 
      "continueStatement", "breakStatement", "returnStatement", "withStatement", 
      "labelledStatement", "switchStatement", "caseBlock", "caseClauses", 
      "caseClause", "defaultClause", "throwStatement", "tryStatement", "catchClause", 
      "finallyClause", "functionDeclaration", "classDeclaration", "classTail", 
      "classElement", "methodDefinition", "getter", "setter", "generatorMethod", 
      "asyncMethod", "importStatement", "importFromBlock", "importNamespace", 
      "importSpecifier", "moduleExportName", "exportStatement", "exportFromBlock", 
      "exportNamespace", "exportSpecifier", "declaration", "formalParameterList", 
      "formalParameter", "restParameter", "assignable", "propertyName", 
      "expressionSequence", "assignmentOperator", "arrayLiteral", "elementList", 
      "arrayElement", "objectLiteral", "propertyAssignment", "arguments", 
      "argumentList", "argument", "anonymousFunction", "arrowFunction", 
      "arrowFunctionParameters", "arrowFunctionBody", "typeofExpression", 
      "identifierName", "reservedWord", "keyword"
    },
    std::vector<std::string>{
      "", "'->'", "'{{'", "'}}'", "'#'", "'@'", "' '", "'listen'", "'delegate'", 
      "'target'", "'animate'", "'duration'", "'easing'", "'begin'", "'end'", 
      "'when'", "'loop'", "'direction'", "'delay'", "'callback'", "'`'", 
      "", "", "", "", "", "", "'break'", "'do'", "'instanceof'", "'typeof'", 
      "'case'", "'else'", "'new'", "'var'", "'catch'", "'finally'", "'return'", 
      "'void'", "'continue'", "'for'", "'switch'", "'while'", "'debugger'", 
      "'function'", "'this'", "'with'", "'default'", "'if'", "'throw'", 
      "'delete'", "'in'", "'try'", "'class'", "'enum'", "'extends'", "'super'", 
      "'const'", "'export'", "'import'", "'async'", "'await'", "'yield'", 
      "'let'", "'static'", "'from'", "'as'", "'of'", "'get'", "'set'", "'null'", 
      "", "'undefined'", "'('", "')'", "'{'", "'}'", "'['", "']'", "';'", 
      "','", "'.'", "'\\u003F'", "':'", "'...'", "'='", "'*='", "'/='", 
      "'%='", "'+='", "'-='", "'<<='", "'>>='", "'>>>='", "'&='", "'^='", 
      "'|='", "'**='", "'\\u003F\\u003F='", "'=>'", "'++'", "'--'", "'+'", 
      "'-'", "'~'", "'!'", "'*'", "'/'", "'%'", "'**'", "'\\u003F\\u003F'", 
      "'<<'", "'>>'", "'>>>'", "'<'", "'>'", "'<='", "'>='", "'=='", "'!='", 
      "'==='", "'!=='", "'&'", "'^'", "'|'", "'&&'", "'||'"
    },
    std::vector<std::string>{
      "", "CHTL_ARROW", "CHTL_SELECTOR_START", "CHTL_SELECTOR_END", "HASH", 
      "AT", "SPACE", "LISTEN", "DELEGATE", "TARGET", "ANIMATE", "DURATION", 
      "EASING", "BEGIN_PROP", "END_PROP", "WHEN", "LOOP", "DIRECTION", "DELAY", 
      "CALLBACK", "BACKTICK", "TEMPLATE_STRING", "REGEX", "IDENTIFIER", 
      "LINE_COMMENT", "BLOCK_COMMENT", "WS", "BREAK", "DO", "INSTANCEOF", 
      "TYPEOF", "CASE", "ELSE", "NEW", "VAR", "CATCH", "FINALLY", "RETURN", 
      "VOID", "CONTINUE", "FOR", "SWITCH", "WHILE", "DEBUGGER", "FUNCTION", 
      "THIS", "WITH", "DEFAULT", "IF", "THROW", "DELETE", "IN", "TRY", "CLASS", 
      "ENUM", "EXTENDS", "SUPER", "CONST", "EXPORT", "IMPORT", "ASYNC", 
      "AWAIT", "YIELD", "LET", "STATIC", "FROM", "AS", "OF", "GET", "SET", 
      "NULL_LITERAL", "BOOLEAN", "UNDEFINED", "LPAREN", "RPAREN", "LBRACE", 
      "RBRACE", "LBRACKET", "RBRACKET", "SEMICOLON", "COMMA", "DOT", "QUESTION", 
      "COLON", "ELLIPSIS", "EQUALS", "STAR_EQUALS", "SLASH_EQUALS", "PERCENT_EQUALS", 
      "PLUS_EQUALS", "MINUS_EQUALS", "LSHIFT_EQUALS", "RSHIFT_EQUALS", "URSHIFT_EQUALS", 
      "AMPERSAND_EQUALS", "CARET_EQUALS", "PIPE_EQUALS", "POWER_EQUALS", 
      "NULLISH_EQUALS", "ARROW", "PLUSPLUS", "MINUSMINUS", "PLUS", "MINUS", 
      "TILDE", "EXCLAMATION", "STAR", "SLASH", "PERCENT", "POWER", "NULLISH_COALESCING", 
      "LSHIFT", "RSHIFT", "URSHIFT", "LT", "GT", "LE", "GE", "EQUALS_OP", 
      "NOT_EQUALS", "STRICT_EQUALS", "STRICT_NOT_EQUALS", "AMPERSAND", "CARET", 
      "PIPE", "AND_OP", "OR_OP", "NUMBER", "BIGINT", "STRING"
    }
  );
  static const int32_t serializedATNSegment[] = {
  	4,1,129,1070,2,0,7,0,2,1,7,1,2,2,7,2,2,3,7,3,2,4,7,4,2,5,7,5,2,6,7,6,
  	2,7,7,7,2,8,7,8,2,9,7,9,2,10,7,10,2,11,7,11,2,12,7,12,2,13,7,13,2,14,
  	7,14,2,15,7,15,2,16,7,16,2,17,7,17,2,18,7,18,2,19,7,19,2,20,7,20,2,21,
  	7,21,2,22,7,22,2,23,7,23,2,24,7,24,2,25,7,25,2,26,7,26,2,27,7,27,2,28,
  	7,28,2,29,7,29,2,30,7,30,2,31,7,31,2,32,7,32,2,33,7,33,2,34,7,34,2,35,
  	7,35,2,36,7,36,2,37,7,37,2,38,7,38,2,39,7,39,2,40,7,40,2,41,7,41,2,42,
  	7,42,2,43,7,43,2,44,7,44,2,45,7,45,2,46,7,46,2,47,7,47,2,48,7,48,2,49,
  	7,49,2,50,7,50,2,51,7,51,2,52,7,52,2,53,7,53,2,54,7,54,2,55,7,55,2,56,
  	7,56,2,57,7,57,2,58,7,58,2,59,7,59,2,60,7,60,2,61,7,61,2,62,7,62,2,63,
  	7,63,2,64,7,64,2,65,7,65,2,66,7,66,2,67,7,67,2,68,7,68,2,69,7,69,2,70,
  	7,70,2,71,7,71,2,72,7,72,2,73,7,73,2,74,7,74,2,75,7,75,2,76,7,76,2,77,
  	7,77,2,78,7,78,2,79,7,79,2,80,7,80,2,81,7,81,2,82,7,82,2,83,7,83,2,84,
  	7,84,2,85,7,85,2,86,7,86,1,0,1,0,1,0,1,0,1,0,1,0,1,0,1,0,3,0,183,8,0,
  	1,0,1,0,1,0,1,0,1,0,1,0,1,0,1,0,1,0,1,0,1,0,1,0,1,0,1,0,1,0,1,0,1,0,1,
  	0,1,0,1,0,1,0,1,0,1,0,1,0,1,0,1,0,1,0,1,0,1,0,1,0,1,0,3,0,216,8,0,1,0,
  	1,0,1,0,1,0,1,0,1,0,1,0,1,0,1,0,1,0,1,0,1,0,1,0,1,0,1,0,1,0,1,0,1,0,1,
  	0,1,0,1,0,1,0,1,0,1,0,1,0,1,0,1,0,1,0,1,0,1,0,1,0,1,0,1,0,1,0,1,0,1,0,
  	1,0,1,0,1,0,1,0,1,0,1,0,1,0,1,0,1,0,1,0,1,0,1,0,1,0,1,0,1,0,1,0,1,0,1,
  	0,1,0,1,0,1,0,1,0,1,0,1,0,1,0,1,0,1,0,1,0,1,0,1,0,1,0,1,0,1,0,1,0,1,0,
  	1,0,1,0,1,0,1,0,1,0,1,0,1,0,1,0,1,0,1,0,1,0,1,0,1,0,1,0,1,0,1,0,1,0,1,
  	0,1,0,1,0,5,0,309,8,0,10,0,12,0,312,9,0,1,1,1,1,1,1,5,1,317,8,1,10,1,
  	12,1,320,9,1,1,2,1,2,1,2,1,2,1,3,1,3,1,3,1,3,1,3,1,3,3,3,332,8,3,1,4,
  	4,4,335,8,4,11,4,12,4,336,1,5,1,5,1,5,1,5,1,5,1,5,1,5,1,5,1,5,3,5,348,
  	8,5,1,6,1,6,1,6,1,6,5,6,354,8,6,10,6,12,6,357,9,6,1,6,1,6,1,7,1,7,1,7,
  	1,7,3,7,365,8,7,1,8,1,8,1,8,1,8,5,8,371,8,8,10,8,12,8,374,9,8,1,8,1,8,
  	1,9,1,9,1,9,1,9,3,9,382,8,9,1,9,1,9,1,9,3,9,387,8,9,1,10,1,10,1,10,1,
  	10,5,10,393,8,10,10,10,12,10,396,9,10,1,10,1,10,1,11,1,11,1,11,1,11,1,
  	11,1,12,1,12,1,12,1,12,5,12,409,8,12,10,12,12,12,412,9,12,1,12,1,12,1,
  	13,1,13,1,13,1,13,1,13,1,13,1,13,1,13,1,13,1,13,1,13,1,13,1,13,1,13,1,
  	13,1,13,1,13,1,13,1,13,1,13,1,13,1,13,1,13,1,13,1,13,1,13,1,13,1,13,3,
  	13,444,8,13,3,13,446,8,13,1,14,1,14,1,14,1,14,5,14,452,8,14,10,14,12,
  	14,455,9,14,1,14,1,14,1,15,1,15,1,15,1,15,1,15,3,15,464,8,15,1,16,1,16,
  	1,16,1,16,5,16,470,8,16,10,16,12,16,473,9,16,1,16,1,16,1,17,1,17,1,17,
  	1,17,5,17,481,8,17,10,17,12,17,484,9,17,1,17,1,17,1,18,1,18,1,18,1,18,
  	1,18,1,18,1,18,1,18,3,18,496,8,18,3,18,498,8,18,1,19,1,19,1,20,5,20,503,
  	8,20,10,20,12,20,506,9,20,1,20,1,20,1,21,1,21,1,21,1,21,1,21,1,21,1,21,
  	1,21,1,21,1,21,1,21,1,21,1,21,1,21,1,21,1,21,1,21,1,21,3,21,528,8,21,
  	1,22,1,22,5,22,532,8,22,10,22,12,22,535,9,22,1,22,1,22,1,23,1,23,1,23,
  	1,24,1,24,1,24,1,24,5,24,546,8,24,10,24,12,24,549,9,24,1,25,1,25,1,26,
  	1,26,1,26,3,26,556,8,26,1,27,1,27,1,28,1,28,1,28,1,29,1,29,1,29,1,29,
  	1,29,1,29,1,29,3,29,570,8,29,1,30,1,30,1,30,1,30,1,30,1,30,1,30,1,30,
  	1,30,1,30,1,30,1,30,1,30,1,30,1,30,1,30,1,30,1,30,3,30,590,8,30,1,30,
  	1,30,3,30,594,8,30,1,30,1,30,3,30,598,8,30,1,30,1,30,1,30,1,30,1,30,1,
  	30,3,30,606,8,30,1,30,1,30,1,30,1,30,1,30,1,30,1,30,1,30,1,30,3,30,617,
  	8,30,1,30,1,30,1,30,1,30,1,30,1,30,1,30,1,30,1,30,1,30,3,30,629,8,30,
  	1,30,1,30,1,30,1,30,1,30,3,30,636,8,30,1,31,1,31,3,31,640,8,31,1,31,1,
  	31,1,32,1,32,3,32,646,8,32,1,32,1,32,1,33,1,33,3,33,652,8,33,1,33,1,33,
  	1,34,1,34,1,34,1,34,1,34,1,34,1,35,1,35,1,35,1,35,1,36,1,36,1,36,1,36,
  	1,36,1,36,1,37,1,37,3,37,674,8,37,1,37,1,37,3,37,678,8,37,3,37,680,8,
  	37,1,37,1,37,1,38,4,38,685,8,38,11,38,12,38,686,1,39,1,39,1,39,1,39,5,
  	39,693,8,39,10,39,12,39,696,9,39,1,40,1,40,1,40,5,40,701,8,40,10,40,12,
  	40,704,9,40,1,41,1,41,1,41,1,41,1,42,1,42,1,42,1,42,3,42,714,8,42,1,42,
  	3,42,717,8,42,1,43,1,43,1,43,1,43,1,43,3,43,724,8,43,1,43,1,43,1,44,1,
  	44,1,44,1,45,3,45,732,8,45,1,45,1,45,3,45,736,8,45,1,45,1,45,1,45,3,45,
  	741,8,45,1,45,1,45,1,45,1,46,1,46,1,46,1,46,3,46,750,8,46,1,46,1,46,1,
  	47,1,47,5,47,756,8,47,10,47,12,47,759,9,47,1,47,1,47,1,48,3,48,764,8,
  	48,1,48,1,48,1,48,1,48,1,48,1,48,1,48,3,48,773,8,48,1,49,1,49,1,49,3,
  	49,778,8,49,1,49,1,49,1,49,1,49,1,49,1,49,1,49,3,49,787,8,49,1,50,1,50,
  	1,50,1,50,1,50,1,50,1,51,1,51,1,51,1,51,1,51,1,51,1,51,1,52,1,52,1,52,
  	1,52,3,52,806,8,52,1,52,1,52,1,52,1,53,1,53,1,53,1,53,3,53,815,8,53,1,
  	53,1,53,1,53,1,54,1,54,1,54,3,54,823,8,54,1,54,1,54,1,55,1,55,1,55,1,
  	55,3,55,831,8,55,1,55,1,55,1,55,1,56,1,56,1,56,1,56,5,56,840,8,56,10,
  	56,12,56,843,9,56,3,56,845,8,56,1,56,1,56,1,57,1,57,3,57,851,8,57,1,57,
  	1,57,3,57,855,8,57,1,58,1,58,1,59,1,59,1,59,3,59,862,8,59,1,59,1,59,1,
  	59,1,59,1,59,1,59,1,59,3,59,871,8,59,1,60,1,60,3,60,875,8,60,1,60,1,60,
  	1,60,1,61,1,61,1,61,1,61,5,61,884,8,61,10,61,12,61,887,9,61,3,61,889,
  	8,61,1,61,1,61,1,62,1,62,3,62,895,8,62,1,62,1,62,3,62,899,8,62,1,63,1,
  	63,1,63,3,63,904,8,63,1,64,1,64,1,64,5,64,909,8,64,10,64,12,64,912,9,
  	64,1,64,1,64,3,64,916,8,64,1,64,3,64,919,8,64,1,65,1,65,1,65,3,65,924,
  	8,65,1,66,1,66,1,66,1,67,1,67,1,67,3,67,932,8,67,1,68,1,68,1,68,1,68,
  	1,68,1,68,1,68,3,68,941,8,68,1,69,1,69,1,69,5,69,946,8,69,10,69,12,69,
  	949,9,69,1,70,1,70,1,71,1,71,3,71,955,8,71,1,71,1,71,1,72,1,72,1,72,5,
  	72,962,8,72,10,72,12,72,965,9,72,1,73,3,73,968,8,73,1,73,1,73,3,73,972,
  	8,73,1,74,1,74,1,74,1,74,5,74,978,8,74,10,74,12,74,981,9,74,1,74,3,74,
  	984,8,74,1,74,1,74,1,75,1,75,1,75,1,75,1,75,1,75,1,75,1,75,1,75,1,75,
  	1,75,1,75,1,75,1,75,3,75,1002,8,75,1,76,1,76,3,76,1006,8,76,1,76,1,76,
  	1,77,1,77,1,77,5,77,1013,8,77,10,77,12,77,1016,9,77,1,78,3,78,1019,8,
  	78,1,78,1,78,1,79,3,79,1024,8,79,1,79,1,79,3,79,1028,8,79,1,79,1,79,3,
  	79,1032,8,79,1,79,1,79,1,79,1,80,3,80,1038,8,80,1,80,1,80,1,80,1,80,1,
  	81,1,81,1,81,3,81,1047,8,81,1,81,3,81,1050,8,81,1,82,1,82,3,82,1054,8,
  	82,1,83,1,83,1,83,1,84,1,84,3,84,1061,8,84,1,85,1,85,1,85,3,85,1066,8,
  	85,1,86,1,86,1,86,0,1,0,87,0,2,4,6,8,10,12,14,16,18,20,22,24,26,28,30,
  	32,34,36,38,40,42,44,46,48,50,52,54,56,58,60,62,64,66,68,70,72,74,76,
  	78,80,82,84,86,88,90,92,94,96,98,100,102,104,106,108,110,112,114,116,
  	118,120,122,124,126,128,130,132,134,136,138,140,142,144,146,148,150,152,
  	154,156,158,160,162,164,166,168,170,172,0,10,1,0,106,108,1,0,102,103,
  	1,0,111,113,1,0,114,117,1,0,118,121,2,0,23,23,129,129,4,0,21,21,70,72,
  	127,127,129,129,3,0,34,34,57,57,63,63,1,0,86,98,1,0,27,67,1173,0,215,
  	1,0,0,0,2,313,1,0,0,0,4,321,1,0,0,0,6,331,1,0,0,0,8,334,1,0,0,0,10,347,
  	1,0,0,0,12,349,1,0,0,0,14,360,1,0,0,0,16,366,1,0,0,0,18,386,1,0,0,0,20,
  	388,1,0,0,0,22,399,1,0,0,0,24,404,1,0,0,0,26,445,1,0,0,0,28,447,1,0,0,
  	0,30,458,1,0,0,0,32,465,1,0,0,0,34,476,1,0,0,0,36,497,1,0,0,0,38,499,
  	1,0,0,0,40,504,1,0,0,0,42,527,1,0,0,0,44,529,1,0,0,0,46,538,1,0,0,0,48,
  	541,1,0,0,0,50,550,1,0,0,0,52,552,1,0,0,0,54,557,1,0,0,0,56,559,1,0,0,
  	0,58,562,1,0,0,0,60,635,1,0,0,0,62,637,1,0,0,0,64,643,1,0,0,0,66,649,
  	1,0,0,0,68,655,1,0,0,0,70,661,1,0,0,0,72,665,1,0,0,0,74,671,1,0,0,0,76,
  	684,1,0,0,0,78,688,1,0,0,0,80,697,1,0,0,0,82,705,1,0,0,0,84,709,1,0,0,
  	0,86,718,1,0,0,0,88,727,1,0,0,0,90,731,1,0,0,0,92,745,1,0,0,0,94,753,
  	1,0,0,0,96,772,1,0,0,0,98,786,1,0,0,0,100,788,1,0,0,0,102,794,1,0,0,0,
  	104,801,1,0,0,0,106,810,1,0,0,0,108,819,1,0,0,0,110,830,1,0,0,0,112,835,
  	1,0,0,0,114,850,1,0,0,0,116,856,1,0,0,0,118,870,1,0,0,0,120,874,1,0,0,
  	0,122,879,1,0,0,0,124,894,1,0,0,0,126,903,1,0,0,0,128,918,1,0,0,0,130,
  	920,1,0,0,0,132,925,1,0,0,0,134,931,1,0,0,0,136,940,1,0,0,0,138,942,1,
  	0,0,0,140,950,1,0,0,0,142,952,1,0,0,0,144,958,1,0,0,0,146,971,1,0,0,0,
  	148,973,1,0,0,0,150,1001,1,0,0,0,152,1003,1,0,0,0,154,1009,1,0,0,0,156,
  	1018,1,0,0,0,158,1023,1,0,0,0,160,1037,1,0,0,0,162,1049,1,0,0,0,164,1053,
  	1,0,0,0,166,1055,1,0,0,0,168,1060,1,0,0,0,170,1065,1,0,0,0,172,1067,1,
  	0,0,0,174,175,6,0,-1,0,175,216,3,4,2,0,176,216,3,22,11,0,177,216,3,158,
  	79,0,178,216,3,160,80,0,179,180,5,33,0,0,180,182,3,0,0,0,181,183,3,152,
  	76,0,182,181,1,0,0,0,182,183,1,0,0,0,183,216,1,0,0,0,184,185,5,50,0,0,
  	185,216,3,0,0,35,186,187,5,38,0,0,187,216,3,0,0,34,188,189,5,30,0,0,189,
  	216,3,0,0,33,190,191,5,100,0,0,191,216,3,0,0,32,192,193,5,101,0,0,193,
  	216,3,0,0,31,194,195,5,102,0,0,195,216,3,0,0,30,196,197,5,103,0,0,197,
  	216,3,0,0,29,198,199,5,104,0,0,199,216,3,0,0,28,200,201,5,105,0,0,201,
  	216,3,0,0,27,202,203,5,61,0,0,203,216,3,0,0,26,204,216,5,45,0,0,205,216,
  	5,23,0,0,206,216,5,56,0,0,207,216,3,38,19,0,208,216,3,142,71,0,209,216,
  	3,148,74,0,210,211,5,73,0,0,211,212,3,138,69,0,212,213,5,74,0,0,213,216,
  	1,0,0,0,214,216,3,166,83,0,215,174,1,0,0,0,215,176,1,0,0,0,215,177,1,
  	0,0,0,215,178,1,0,0,0,215,179,1,0,0,0,215,184,1,0,0,0,215,186,1,0,0,0,
  	215,188,1,0,0,0,215,190,1,0,0,0,215,192,1,0,0,0,215,194,1,0,0,0,215,196,
  	1,0,0,0,215,198,1,0,0,0,215,200,1,0,0,0,215,202,1,0,0,0,215,204,1,0,0,
  	0,215,205,1,0,0,0,215,206,1,0,0,0,215,207,1,0,0,0,215,208,1,0,0,0,215,
  	209,1,0,0,0,215,210,1,0,0,0,215,214,1,0,0,0,216,310,1,0,0,0,217,218,10,
  	25,0,0,218,219,5,109,0,0,219,309,3,0,0,26,220,221,10,24,0,0,221,222,7,
  	0,0,0,222,309,3,0,0,25,223,224,10,23,0,0,224,225,7,1,0,0,225,309,3,0,
  	0,24,226,227,10,22,0,0,227,228,7,2,0,0,228,309,3,0,0,23,229,230,10,21,
  	0,0,230,231,7,3,0,0,231,309,3,0,0,22,232,233,10,20,0,0,233,234,5,29,0,
  	0,234,309,3,0,0,21,235,236,10,19,0,0,236,237,5,51,0,0,237,309,3,0,0,20,
  	238,239,10,18,0,0,239,240,7,4,0,0,240,309,3,0,0,19,241,242,10,17,0,0,
  	242,243,5,122,0,0,243,309,3,0,0,18,244,245,10,16,0,0,245,246,5,123,0,
  	0,246,309,3,0,0,17,247,248,10,15,0,0,248,249,5,124,0,0,249,309,3,0,0,
  	16,250,251,10,14,0,0,251,252,5,125,0,0,252,309,3,0,0,15,253,254,10,13,
  	0,0,254,255,5,126,0,0,255,309,3,0,0,14,256,257,10,12,0,0,257,258,5,110,
  	0,0,258,309,3,0,0,13,259,260,10,11,0,0,260,261,5,82,0,0,261,262,3,0,0,
  	0,262,263,5,83,0,0,263,264,3,0,0,12,264,309,1,0,0,0,265,266,10,10,0,0,
  	266,267,5,85,0,0,267,309,3,0,0,11,268,269,10,9,0,0,269,270,3,140,70,0,
  	270,271,3,0,0,10,271,309,1,0,0,0,272,273,10,48,0,0,273,274,5,1,0,0,274,
  	309,3,168,84,0,275,276,10,47,0,0,276,277,5,1,0,0,277,278,3,168,84,0,278,
  	279,3,152,76,0,279,309,1,0,0,0,280,281,10,46,0,0,281,282,5,1,0,0,282,
  	283,5,7,0,0,283,284,5,73,0,0,284,285,3,12,6,0,285,286,5,74,0,0,286,309,
  	1,0,0,0,287,288,10,45,0,0,288,289,5,1,0,0,289,290,5,8,0,0,290,291,5,73,
  	0,0,291,292,3,16,8,0,292,293,5,74,0,0,293,309,1,0,0,0,294,295,10,41,0,
  	0,295,296,5,77,0,0,296,297,3,138,69,0,297,298,5,78,0,0,298,309,1,0,0,
  	0,299,300,10,40,0,0,300,301,5,81,0,0,301,309,3,168,84,0,302,303,10,39,
  	0,0,303,309,3,152,76,0,304,305,10,37,0,0,305,309,5,100,0,0,306,307,10,
  	36,0,0,307,309,5,101,0,0,308,217,1,0,0,0,308,220,1,0,0,0,308,223,1,0,
  	0,0,308,226,1,0,0,0,308,229,1,0,0,0,308,232,1,0,0,0,308,235,1,0,0,0,308,
  	238,1,0,0,0,308,241,1,0,0,0,308,244,1,0,0,0,308,247,1,0,0,0,308,250,1,
  	0,0,0,308,253,1,0,0,0,308,256,1,0,0,0,308,259,1,0,0,0,308,265,1,0,0,0,
  	308,268,1,0,0,0,308,272,1,0,0,0,308,275,1,0,0,0,308,280,1,0,0,0,308,287,
  	1,0,0,0,308,294,1,0,0,0,308,299,1,0,0,0,308,302,1,0,0,0,308,304,1,0,0,
  	0,308,306,1,0,0,0,309,312,1,0,0,0,310,308,1,0,0,0,310,311,1,0,0,0,311,
  	1,1,0,0,0,312,310,1,0,0,0,313,318,3,4,2,0,314,315,5,80,0,0,315,317,3,
  	4,2,0,316,314,1,0,0,0,317,320,1,0,0,0,318,316,1,0,0,0,318,319,1,0,0,0,
  	319,3,1,0,0,0,320,318,1,0,0,0,321,322,5,2,0,0,322,323,3,6,3,0,323,324,
  	5,3,0,0,324,5,1,0,0,0,325,332,5,23,0,0,326,327,5,81,0,0,327,332,5,23,
  	0,0,328,329,5,4,0,0,329,332,5,23,0,0,330,332,3,0,0,0,331,325,1,0,0,0,
  	331,326,1,0,0,0,331,328,1,0,0,0,331,330,1,0,0,0,332,7,1,0,0,0,333,335,
  	3,10,5,0,334,333,1,0,0,0,335,336,1,0,0,0,336,334,1,0,0,0,336,337,1,0,
  	0,0,337,9,1,0,0,0,338,348,5,23,0,0,339,340,5,81,0,0,340,348,5,23,0,0,
  	341,342,5,4,0,0,342,348,5,23,0,0,343,344,5,77,0,0,344,345,5,127,0,0,345,
  	348,5,78,0,0,346,348,5,6,0,0,347,338,1,0,0,0,347,339,1,0,0,0,347,341,
  	1,0,0,0,347,343,1,0,0,0,347,346,1,0,0,0,348,11,1,0,0,0,349,350,5,75,0,
  	0,350,355,3,14,7,0,351,352,5,80,0,0,352,354,3,14,7,0,353,351,1,0,0,0,
  	354,357,1,0,0,0,355,353,1,0,0,0,355,356,1,0,0,0,356,358,1,0,0,0,357,355,
  	1,0,0,0,358,359,5,76,0,0,359,13,1,0,0,0,360,361,5,23,0,0,361,364,5,83,
  	0,0,362,365,3,0,0,0,363,365,5,23,0,0,364,362,1,0,0,0,364,363,1,0,0,0,
  	365,15,1,0,0,0,366,367,5,75,0,0,367,372,3,18,9,0,368,369,5,80,0,0,369,
  	371,3,18,9,0,370,368,1,0,0,0,371,374,1,0,0,0,372,370,1,0,0,0,372,373,
  	1,0,0,0,373,375,1,0,0,0,374,372,1,0,0,0,375,376,5,76,0,0,376,17,1,0,0,
  	0,377,378,5,9,0,0,378,381,5,83,0,0,379,382,3,4,2,0,380,382,3,20,10,0,
  	381,379,1,0,0,0,381,380,1,0,0,0,382,387,1,0,0,0,383,384,5,23,0,0,384,
  	385,5,83,0,0,385,387,3,0,0,0,386,377,1,0,0,0,386,383,1,0,0,0,387,19,1,
  	0,0,0,388,389,5,77,0,0,389,394,3,4,2,0,390,391,5,80,0,0,391,393,3,4,2,
  	0,392,390,1,0,0,0,393,396,1,0,0,0,394,392,1,0,0,0,394,395,1,0,0,0,395,
  	397,1,0,0,0,396,394,1,0,0,0,397,398,5,78,0,0,398,21,1,0,0,0,399,400,5,
  	10,0,0,400,401,5,73,0,0,401,402,3,24,12,0,402,403,5,74,0,0,403,23,1,0,
  	0,0,404,405,5,75,0,0,405,410,3,26,13,0,406,407,5,80,0,0,407,409,3,26,
  	13,0,408,406,1,0,0,0,409,412,1,0,0,0,410,408,1,0,0,0,410,411,1,0,0,0,
  	411,413,1,0,0,0,412,410,1,0,0,0,413,414,5,76,0,0,414,25,1,0,0,0,415,416,
  	5,11,0,0,416,417,5,83,0,0,417,446,5,127,0,0,418,419,5,12,0,0,419,420,
  	5,83,0,0,420,446,7,5,0,0,421,422,5,13,0,0,422,423,5,83,0,0,423,446,3,
  	28,14,0,424,425,5,14,0,0,425,426,5,83,0,0,426,446,3,28,14,0,427,428,5,
  	15,0,0,428,429,5,83,0,0,429,446,3,32,16,0,430,431,5,16,0,0,431,432,5,
  	83,0,0,432,446,5,127,0,0,433,434,5,17,0,0,434,435,5,83,0,0,435,446,7,
  	5,0,0,436,437,5,18,0,0,437,438,5,83,0,0,438,446,5,127,0,0,439,440,5,19,
  	0,0,440,443,5,83,0,0,441,444,3,0,0,0,442,444,5,23,0,0,443,441,1,0,0,0,
  	443,442,1,0,0,0,444,446,1,0,0,0,445,415,1,0,0,0,445,418,1,0,0,0,445,421,
  	1,0,0,0,445,424,1,0,0,0,445,427,1,0,0,0,445,430,1,0,0,0,445,433,1,0,0,
  	0,445,436,1,0,0,0,445,439,1,0,0,0,446,27,1,0,0,0,447,448,5,75,0,0,448,
  	453,3,30,15,0,449,450,5,80,0,0,450,452,3,30,15,0,451,449,1,0,0,0,452,
  	455,1,0,0,0,453,451,1,0,0,0,453,454,1,0,0,0,454,456,1,0,0,0,455,453,1,
  	0,0,0,456,457,5,76,0,0,457,29,1,0,0,0,458,459,5,23,0,0,459,463,5,83,0,
  	0,460,464,5,129,0,0,461,464,5,127,0,0,462,464,3,0,0,0,463,460,1,0,0,0,
  	463,461,1,0,0,0,463,462,1,0,0,0,464,31,1,0,0,0,465,466,5,77,0,0,466,471,
  	3,34,17,0,467,468,5,80,0,0,468,470,3,34,17,0,469,467,1,0,0,0,470,473,
  	1,0,0,0,471,469,1,0,0,0,471,472,1,0,0,0,472,474,1,0,0,0,473,471,1,0,0,
  	0,474,475,5,78,0,0,475,33,1,0,0,0,476,477,5,75,0,0,477,482,3,36,18,0,
  	478,479,5,80,0,0,479,481,3,36,18,0,480,478,1,0,0,0,481,484,1,0,0,0,482,
  	480,1,0,0,0,482,483,1,0,0,0,483,485,1,0,0,0,484,482,1,0,0,0,485,486,5,
  	76,0,0,486,35,1,0,0,0,487,488,5,5,0,0,488,489,5,83,0,0,489,498,5,127,
  	0,0,490,491,5,23,0,0,491,495,5,83,0,0,492,496,5,129,0,0,493,496,5,127,
  	0,0,494,496,3,0,0,0,495,492,1,0,0,0,495,493,1,0,0,0,495,494,1,0,0,0,496,
  	498,1,0,0,0,497,487,1,0,0,0,497,490,1,0,0,0,498,37,1,0,0,0,499,500,7,
  	6,0,0,500,39,1,0,0,0,501,503,3,42,21,0,502,501,1,0,0,0,503,506,1,0,0,
  	0,504,502,1,0,0,0,504,505,1,0,0,0,505,507,1,0,0,0,506,504,1,0,0,0,507,
  	508,5,0,0,1,508,41,1,0,0,0,509,528,3,44,22,0,510,528,3,46,23,0,511,528,
  	3,54,27,0,512,528,3,56,28,0,513,528,3,58,29,0,514,528,3,60,30,0,515,528,
  	3,62,31,0,516,528,3,64,32,0,517,528,3,66,33,0,518,528,3,68,34,0,519,528,
  	3,70,35,0,520,528,3,72,36,0,521,528,3,82,41,0,522,528,3,84,42,0,523,528,
  	3,90,45,0,524,528,3,92,46,0,525,528,3,108,54,0,526,528,3,118,59,0,527,
  	509,1,0,0,0,527,510,1,0,0,0,527,511,1,0,0,0,527,512,1,0,0,0,527,513,1,
  	0,0,0,527,514,1,0,0,0,527,515,1,0,0,0,527,516,1,0,0,0,527,517,1,0,0,0,
  	527,518,1,0,0,0,527,519,1,0,0,0,527,520,1,0,0,0,527,521,1,0,0,0,527,522,
  	1,0,0,0,527,523,1,0,0,0,527,524,1,0,0,0,527,525,1,0,0,0,527,526,1,0,0,
  	0,528,43,1,0,0,0,529,533,5,75,0,0,530,532,3,42,21,0,531,530,1,0,0,0,532,
  	535,1,0,0,0,533,531,1,0,0,0,533,534,1,0,0,0,534,536,1,0,0,0,535,533,1,
  	0,0,0,536,537,5,76,0,0,537,45,1,0,0,0,538,539,3,48,24,0,539,540,5,79,
  	0,0,540,47,1,0,0,0,541,542,3,50,25,0,542,547,3,52,26,0,543,544,5,80,0,
  	0,544,546,3,52,26,0,545,543,1,0,0,0,546,549,1,0,0,0,547,545,1,0,0,0,547,
  	548,1,0,0,0,548,49,1,0,0,0,549,547,1,0,0,0,550,551,7,7,0,0,551,51,1,0,
  	0,0,552,555,3,134,67,0,553,554,5,85,0,0,554,556,3,0,0,0,555,553,1,0,0,
  	0,555,556,1,0,0,0,556,53,1,0,0,0,557,558,5,79,0,0,558,55,1,0,0,0,559,
  	560,3,138,69,0,560,561,5,79,0,0,561,57,1,0,0,0,562,563,5,48,0,0,563,564,
  	5,73,0,0,564,565,3,138,69,0,565,566,5,74,0,0,566,569,3,42,21,0,567,568,
  	5,32,0,0,568,570,3,42,21,0,569,567,1,0,0,0,569,570,1,0,0,0,570,59,1,0,
  	0,0,571,572,5,28,0,0,572,573,3,42,21,0,573,574,5,42,0,0,574,575,5,73,
  	0,0,575,576,3,138,69,0,576,577,5,74,0,0,577,578,5,79,0,0,578,636,1,0,
  	0,0,579,580,5,42,0,0,580,581,5,73,0,0,581,582,3,138,69,0,582,583,5,74,
  	0,0,583,584,3,42,21,0,584,636,1,0,0,0,585,586,5,40,0,0,586,589,5,73,0,
  	0,587,590,3,138,69,0,588,590,3,48,24,0,589,587,1,0,0,0,589,588,1,0,0,
  	0,589,590,1,0,0,0,590,591,1,0,0,0,591,593,5,79,0,0,592,594,3,138,69,0,
  	593,592,1,0,0,0,593,594,1,0,0,0,594,595,1,0,0,0,595,597,5,79,0,0,596,
  	598,3,138,69,0,597,596,1,0,0,0,597,598,1,0,0,0,598,599,1,0,0,0,599,600,
  	5,74,0,0,600,636,3,42,21,0,601,602,5,40,0,0,602,605,5,73,0,0,603,606,
  	3,0,0,0,604,606,3,48,24,0,605,603,1,0,0,0,605,604,1,0,0,0,606,607,1,0,
  	0,0,607,608,5,51,0,0,608,609,3,138,69,0,609,610,5,74,0,0,610,611,3,42,
  	21,0,611,636,1,0,0,0,612,613,5,40,0,0,613,616,5,73,0,0,614,617,3,0,0,
  	0,615,617,3,48,24,0,616,614,1,0,0,0,616,615,1,0,0,0,617,618,1,0,0,0,618,
  	619,5,67,0,0,619,620,3,138,69,0,620,621,5,74,0,0,621,622,3,42,21,0,622,
  	636,1,0,0,0,623,624,5,40,0,0,624,625,5,61,0,0,625,628,5,73,0,0,626,629,
  	3,0,0,0,627,629,3,48,24,0,628,626,1,0,0,0,628,627,1,0,0,0,629,630,1,0,
  	0,0,630,631,5,67,0,0,631,632,3,138,69,0,632,633,5,74,0,0,633,634,3,42,
  	21,0,634,636,1,0,0,0,635,571,1,0,0,0,635,579,1,0,0,0,635,585,1,0,0,0,
  	635,601,1,0,0,0,635,612,1,0,0,0,635,623,1,0,0,0,636,61,1,0,0,0,637,639,
  	5,39,0,0,638,640,5,23,0,0,639,638,1,0,0,0,639,640,1,0,0,0,640,641,1,0,
  	0,0,641,642,5,79,0,0,642,63,1,0,0,0,643,645,5,27,0,0,644,646,5,23,0,0,
  	645,644,1,0,0,0,645,646,1,0,0,0,646,647,1,0,0,0,647,648,5,79,0,0,648,
  	65,1,0,0,0,649,651,5,37,0,0,650,652,3,138,69,0,651,650,1,0,0,0,651,652,
  	1,0,0,0,652,653,1,0,0,0,653,654,5,79,0,0,654,67,1,0,0,0,655,656,5,46,
  	0,0,656,657,5,73,0,0,657,658,3,138,69,0,658,659,5,74,0,0,659,660,3,42,
  	21,0,660,69,1,0,0,0,661,662,5,23,0,0,662,663,5,83,0,0,663,664,3,42,21,
  	0,664,71,1,0,0,0,665,666,5,41,0,0,666,667,5,73,0,0,667,668,3,138,69,0,
  	668,669,5,74,0,0,669,670,3,74,37,0,670,73,1,0,0,0,671,673,5,75,0,0,672,
  	674,3,76,38,0,673,672,1,0,0,0,673,674,1,0,0,0,674,679,1,0,0,0,675,677,
  	3,80,40,0,676,678,3,76,38,0,677,676,1,0,0,0,677,678,1,0,0,0,678,680,1,
  	0,0,0,679,675,1,0,0,0,679,680,1,0,0,0,680,681,1,0,0,0,681,682,5,76,0,
  	0,682,75,1,0,0,0,683,685,3,78,39,0,684,683,1,0,0,0,685,686,1,0,0,0,686,
  	684,1,0,0,0,686,687,1,0,0,0,687,77,1,0,0,0,688,689,5,31,0,0,689,690,3,
  	138,69,0,690,694,5,83,0,0,691,693,3,42,21,0,692,691,1,0,0,0,693,696,1,
  	0,0,0,694,692,1,0,0,0,694,695,1,0,0,0,695,79,1,0,0,0,696,694,1,0,0,0,
  	697,698,5,47,0,0,698,702,5,83,0,0,699,701,3,42,21,0,700,699,1,0,0,0,701,
  	704,1,0,0,0,702,700,1,0,0,0,702,703,1,0,0,0,703,81,1,0,0,0,704,702,1,
  	0,0,0,705,706,5,49,0,0,706,707,3,138,69,0,707,708,5,79,0,0,708,83,1,0,
  	0,0,709,710,5,52,0,0,710,716,3,44,22,0,711,713,3,86,43,0,712,714,3,88,
  	44,0,713,712,1,0,0,0,713,714,1,0,0,0,714,717,1,0,0,0,715,717,3,88,44,
  	0,716,711,1,0,0,0,716,715,1,0,0,0,717,85,1,0,0,0,718,723,5,35,0,0,719,
  	720,5,73,0,0,720,721,3,134,67,0,721,722,5,74,0,0,722,724,1,0,0,0,723,
  	719,1,0,0,0,723,724,1,0,0,0,724,725,1,0,0,0,725,726,3,44,22,0,726,87,
  	1,0,0,0,727,728,5,36,0,0,728,729,3,44,22,0,729,89,1,0,0,0,730,732,5,60,
  	0,0,731,730,1,0,0,0,731,732,1,0,0,0,732,733,1,0,0,0,733,735,5,44,0,0,
  	734,736,5,106,0,0,735,734,1,0,0,0,735,736,1,0,0,0,736,737,1,0,0,0,737,
  	738,5,23,0,0,738,740,5,73,0,0,739,741,3,128,64,0,740,739,1,0,0,0,740,
  	741,1,0,0,0,741,742,1,0,0,0,742,743,5,74,0,0,743,744,3,44,22,0,744,91,
  	1,0,0,0,745,746,5,53,0,0,746,749,5,23,0,0,747,748,5,55,0,0,748,750,3,
  	0,0,0,749,747,1,0,0,0,749,750,1,0,0,0,750,751,1,0,0,0,751,752,3,94,47,
  	0,752,93,1,0,0,0,753,757,5,75,0,0,754,756,3,96,48,0,755,754,1,0,0,0,756,
  	759,1,0,0,0,757,755,1,0,0,0,757,758,1,0,0,0,758,760,1,0,0,0,759,757,1,
  	0,0,0,760,761,5,76,0,0,761,95,1,0,0,0,762,764,5,64,0,0,763,762,1,0,0,
  	0,763,764,1,0,0,0,764,765,1,0,0,0,765,773,3,98,49,0,766,773,3,54,27,0,
  	767,768,3,136,68,0,768,769,5,85,0,0,769,770,3,0,0,0,770,771,5,79,0,0,
  	771,773,1,0,0,0,772,763,1,0,0,0,772,766,1,0,0,0,772,767,1,0,0,0,773,97,
  	1,0,0,0,774,775,3,136,68,0,775,777,5,73,0,0,776,778,3,128,64,0,777,776,
  	1,0,0,0,777,778,1,0,0,0,778,779,1,0,0,0,779,780,5,74,0,0,780,781,3,44,
  	22,0,781,787,1,0,0,0,782,787,3,100,50,0,783,787,3,102,51,0,784,787,3,
  	104,52,0,785,787,3,106,53,0,786,774,1,0,0,0,786,782,1,0,0,0,786,783,1,
  	0,0,0,786,784,1,0,0,0,786,785,1,0,0,0,787,99,1,0,0,0,788,789,5,68,0,0,
  	789,790,3,136,68,0,790,791,5,73,0,0,791,792,5,74,0,0,792,793,3,44,22,
  	0,793,101,1,0,0,0,794,795,5,69,0,0,795,796,3,136,68,0,796,797,5,73,0,
  	0,797,798,3,128,64,0,798,799,5,74,0,0,799,800,3,44,22,0,800,103,1,0,0,
  	0,801,802,5,106,0,0,802,803,3,136,68,0,803,805,5,73,0,0,804,806,3,128,
  	64,0,805,804,1,0,0,0,805,806,1,0,0,0,806,807,1,0,0,0,807,808,5,74,0,0,
  	808,809,3,44,22,0,809,105,1,0,0,0,810,811,5,60,0,0,811,812,3,136,68,0,
  	812,814,5,73,0,0,813,815,3,128,64,0,814,813,1,0,0,0,814,815,1,0,0,0,815,
  	816,1,0,0,0,816,817,5,74,0,0,817,818,3,44,22,0,818,107,1,0,0,0,819,822,
  	5,59,0,0,820,823,3,110,55,0,821,823,5,129,0,0,822,820,1,0,0,0,822,821,
  	1,0,0,0,823,824,1,0,0,0,824,825,5,79,0,0,825,109,1,0,0,0,826,827,5,106,
  	0,0,827,828,5,66,0,0,828,831,5,23,0,0,829,831,3,112,56,0,830,826,1,0,
  	0,0,830,829,1,0,0,0,831,832,1,0,0,0,832,833,5,65,0,0,833,834,5,129,0,
  	0,834,111,1,0,0,0,835,844,5,75,0,0,836,841,3,114,57,0,837,838,5,80,0,
  	0,838,840,3,114,57,0,839,837,1,0,0,0,840,843,1,0,0,0,841,839,1,0,0,0,
  	841,842,1,0,0,0,842,845,1,0,0,0,843,841,1,0,0,0,844,836,1,0,0,0,844,845,
  	1,0,0,0,845,846,1,0,0,0,846,847,5,76,0,0,847,113,1,0,0,0,848,851,5,23,
  	0,0,849,851,3,116,58,0,850,848,1,0,0,0,850,849,1,0,0,0,851,854,1,0,0,
  	0,852,853,5,66,0,0,853,855,5,23,0,0,854,852,1,0,0,0,854,855,1,0,0,0,855,
  	115,1,0,0,0,856,857,7,5,0,0,857,117,1,0,0,0,858,861,5,58,0,0,859,862,
  	3,120,60,0,860,862,3,126,63,0,861,859,1,0,0,0,861,860,1,0,0,0,862,863,
  	1,0,0,0,863,864,5,79,0,0,864,871,1,0,0,0,865,866,5,58,0,0,866,867,5,47,
  	0,0,867,868,3,0,0,0,868,869,5,79,0,0,869,871,1,0,0,0,870,858,1,0,0,0,
  	870,865,1,0,0,0,871,119,1,0,0,0,872,875,5,106,0,0,873,875,3,122,61,0,
  	874,872,1,0,0,0,874,873,1,0,0,0,875,876,1,0,0,0,876,877,5,65,0,0,877,
  	878,5,129,0,0,878,121,1,0,0,0,879,888,5,75,0,0,880,885,3,124,62,0,881,
  	882,5,80,0,0,882,884,3,124,62,0,883,881,1,0,0,0,884,887,1,0,0,0,885,883,
  	1,0,0,0,885,886,1,0,0,0,886,889,1,0,0,0,887,885,1,0,0,0,888,880,1,0,0,
  	0,888,889,1,0,0,0,889,890,1,0,0,0,890,891,5,76,0,0,891,123,1,0,0,0,892,
  	895,5,23,0,0,893,895,3,116,58,0,894,892,1,0,0,0,894,893,1,0,0,0,895,898,
  	1,0,0,0,896,897,5,66,0,0,897,899,3,116,58,0,898,896,1,0,0,0,898,899,1,
  	0,0,0,899,125,1,0,0,0,900,904,3,46,23,0,901,904,3,92,46,0,902,904,3,90,
  	45,0,903,900,1,0,0,0,903,901,1,0,0,0,903,902,1,0,0,0,904,127,1,0,0,0,
  	905,910,3,130,65,0,906,907,5,80,0,0,907,909,3,130,65,0,908,906,1,0,0,
  	0,909,912,1,0,0,0,910,908,1,0,0,0,910,911,1,0,0,0,911,915,1,0,0,0,912,
  	910,1,0,0,0,913,914,5,80,0,0,914,916,3,132,66,0,915,913,1,0,0,0,915,916,
  	1,0,0,0,916,919,1,0,0,0,917,919,3,132,66,0,918,905,1,0,0,0,918,917,1,
  	0,0,0,919,129,1,0,0,0,920,923,3,134,67,0,921,922,5,85,0,0,922,924,3,0,
  	0,0,923,921,1,0,0,0,923,924,1,0,0,0,924,131,1,0,0,0,925,926,5,84,0,0,
  	926,927,3,134,67,0,927,133,1,0,0,0,928,932,5,23,0,0,929,932,3,142,71,
  	0,930,932,3,148,74,0,931,928,1,0,0,0,931,929,1,0,0,0,931,930,1,0,0,0,
  	932,135,1,0,0,0,933,941,3,168,84,0,934,941,5,129,0,0,935,941,5,127,0,
  	0,936,937,5,77,0,0,937,938,3,0,0,0,938,939,5,78,0,0,939,941,1,0,0,0,940,
  	933,1,0,0,0,940,934,1,0,0,0,940,935,1,0,0,0,940,936,1,0,0,0,941,137,1,
  	0,0,0,942,947,3,0,0,0,943,944,5,80,0,0,944,946,3,0,0,0,945,943,1,0,0,
  	0,946,949,1,0,0,0,947,945,1,0,0,0,947,948,1,0,0,0,948,139,1,0,0,0,949,
  	947,1,0,0,0,950,951,7,8,0,0,951,141,1,0,0,0,952,954,5,77,0,0,953,955,
  	3,144,72,0,954,953,1,0,0,0,954,955,1,0,0,0,955,956,1,0,0,0,956,957,5,
  	78,0,0,957,143,1,0,0,0,958,963,3,146,73,0,959,960,5,80,0,0,960,962,3,
  	146,73,0,961,959,1,0,0,0,962,965,1,0,0,0,963,961,1,0,0,0,963,964,1,0,
  	0,0,964,145,1,0,0,0,965,963,1,0,0,0,966,968,5,84,0,0,967,966,1,0,0,0,
  	967,968,1,0,0,0,968,969,1,0,0,0,969,972,3,0,0,0,970,972,5,80,0,0,971,
  	967,1,0,0,0,971,970,1,0,0,0,972,147,1,0,0,0,973,974,5,75,0,0,974,979,
  	3,150,75,0,975,976,5,80,0,0,976,978,3,150,75,0,977,975,1,0,0,0,978,981,
  	1,0,0,0,979,977,1,0,0,0,979,980,1,0,0,0,980,983,1,0,0,0,981,979,1,0,0,
  	0,982,984,5,80,0,0,983,982,1,0,0,0,983,984,1,0,0,0,984,985,1,0,0,0,985,
  	986,5,76,0,0,986,149,1,0,0,0,987,988,3,136,68,0,988,989,5,83,0,0,989,
  	990,3,0,0,0,990,1002,1,0,0,0,991,992,5,77,0,0,992,993,3,0,0,0,993,994,
  	5,78,0,0,994,995,5,83,0,0,995,996,3,0,0,0,996,1002,1,0,0,0,997,1002,3,
  	98,49,0,998,1002,5,23,0,0,999,1000,5,84,0,0,1000,1002,3,0,0,0,1001,987,
  	1,0,0,0,1001,991,1,0,0,0,1001,997,1,0,0,0,1001,998,1,0,0,0,1001,999,1,
  	0,0,0,1002,151,1,0,0,0,1003,1005,5,73,0,0,1004,1006,3,154,77,0,1005,1004,
  	1,0,0,0,1005,1006,1,0,0,0,1006,1007,1,0,0,0,1007,1008,5,74,0,0,1008,153,
  	1,0,0,0,1009,1014,3,156,78,0,1010,1011,5,80,0,0,1011,1013,3,156,78,0,
  	1012,1010,1,0,0,0,1013,1016,1,0,0,0,1014,1012,1,0,0,0,1014,1015,1,0,0,
  	0,1015,155,1,0,0,0,1016,1014,1,0,0,0,1017,1019,5,84,0,0,1018,1017,1,0,
  	0,0,1018,1019,1,0,0,0,1019,1020,1,0,0,0,1020,1021,3,0,0,0,1021,157,1,
  	0,0,0,1022,1024,5,60,0,0,1023,1022,1,0,0,0,1023,1024,1,0,0,0,1024,1025,
  	1,0,0,0,1025,1027,5,44,0,0,1026,1028,5,106,0,0,1027,1026,1,0,0,0,1027,
  	1028,1,0,0,0,1028,1029,1,0,0,0,1029,1031,5,73,0,0,1030,1032,3,128,64,
  	0,1031,1030,1,0,0,0,1031,1032,1,0,0,0,1032,1033,1,0,0,0,1033,1034,5,74,
  	0,0,1034,1035,3,44,22,0,1035,159,1,0,0,0,1036,1038,5,60,0,0,1037,1036,
  	1,0,0,0,1037,1038,1,0,0,0,1038,1039,1,0,0,0,1039,1040,3,162,81,0,1040,
  	1041,5,99,0,0,1041,1042,3,164,82,0,1042,161,1,0,0,0,1043,1050,5,23,0,
  	0,1044,1046,5,73,0,0,1045,1047,3,128,64,0,1046,1045,1,0,0,0,1046,1047,
  	1,0,0,0,1047,1048,1,0,0,0,1048,1050,5,74,0,0,1049,1043,1,0,0,0,1049,1044,
  	1,0,0,0,1050,163,1,0,0,0,1051,1054,3,0,0,0,1052,1054,3,44,22,0,1053,1051,
  	1,0,0,0,1053,1052,1,0,0,0,1054,165,1,0,0,0,1055,1056,5,30,0,0,1056,1057,
  	3,0,0,0,1057,167,1,0,0,0,1058,1061,5,23,0,0,1059,1061,3,170,85,0,1060,
  	1058,1,0,0,0,1060,1059,1,0,0,0,1061,169,1,0,0,0,1062,1066,3,172,86,0,
  	1063,1066,5,70,0,0,1064,1066,5,71,0,0,1065,1062,1,0,0,0,1065,1063,1,0,
  	0,0,1065,1064,1,0,0,0,1066,171,1,0,0,0,1067,1068,7,9,0,0,1068,173,1,0,
  	0,0,99,182,215,308,310,318,331,336,347,355,364,372,381,386,394,410,443,
  	445,453,463,471,482,495,497,504,527,533,547,555,569,589,593,597,605,616,
  	628,635,639,645,651,673,677,679,686,694,702,713,716,723,731,735,740,749,
  	757,763,772,777,786,805,814,822,830,841,844,850,854,861,870,874,885,888,
  	894,898,903,910,915,918,923,931,940,947,954,963,967,971,979,983,1001,
  	1005,1014,1018,1023,1027,1031,1037,1046,1049,1053,1060,1065
  };
  staticData->serializedATN = antlr4::atn::SerializedATNView(serializedATNSegment, sizeof(serializedATNSegment) / sizeof(serializedATNSegment[0]));

  antlr4::atn::ATNDeserializer deserializer;
  staticData->atn = deserializer.deserialize(staticData->serializedATN);

  const size_t count = staticData->atn->getNumberOfDecisions();
  staticData->decisionToDFA.reserve(count);
  for (size_t i = 0; i < count; i++) { 
    staticData->decisionToDFA.emplace_back(staticData->atn->getDecisionState(i), i);
  }
  chtljavascriptParserStaticData = staticData.release();
}

}

CHTLJavaScriptParser::CHTLJavaScriptParser(TokenStream *input) : CHTLJavaScriptParser(input, antlr4::atn::ParserATNSimulatorOptions()) {}

CHTLJavaScriptParser::CHTLJavaScriptParser(TokenStream *input, const antlr4::atn::ParserATNSimulatorOptions &options) : Parser(input) {
  CHTLJavaScriptParser::initialize();
  _interpreter = new atn::ParserATNSimulator(this, *chtljavascriptParserStaticData->atn, chtljavascriptParserStaticData->decisionToDFA, chtljavascriptParserStaticData->sharedContextCache, options);
}

CHTLJavaScriptParser::~CHTLJavaScriptParser() {
  delete _interpreter;
}

const atn::ATN& CHTLJavaScriptParser::getATN() const {
  return *chtljavascriptParserStaticData->atn;
}

std::string CHTLJavaScriptParser::getGrammarFileName() const {
  return "CHTLJavaScript.g4";
}

const std::vector<std::string>& CHTLJavaScriptParser::getRuleNames() const {
  return chtljavascriptParserStaticData->ruleNames;
}

const dfa::Vocabulary& CHTLJavaScriptParser::getVocabulary() const {
  return chtljavascriptParserStaticData->vocabulary;
}

antlr4::atn::SerializedATNView CHTLJavaScriptParser::getSerializedATN() const {
  return chtljavascriptParserStaticData->serializedATN;
}


//----------------- SingleExpressionContext ------------------------------------------------------------------

CHTLJavaScriptParser::SingleExpressionContext::SingleExpressionContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

CHTLJavaScriptParser::ChtlSelectorContext* CHTLJavaScriptParser::SingleExpressionContext::chtlSelector() {
  return getRuleContext<CHTLJavaScriptParser::ChtlSelectorContext>(0);
}

CHTLJavaScriptParser::AnimateCallContext* CHTLJavaScriptParser::SingleExpressionContext::animateCall() {
  return getRuleContext<CHTLJavaScriptParser::AnimateCallContext>(0);
}

CHTLJavaScriptParser::AnonymousFunctionContext* CHTLJavaScriptParser::SingleExpressionContext::anonymousFunction() {
  return getRuleContext<CHTLJavaScriptParser::AnonymousFunctionContext>(0);
}

CHTLJavaScriptParser::ArrowFunctionContext* CHTLJavaScriptParser::SingleExpressionContext::arrowFunction() {
  return getRuleContext<CHTLJavaScriptParser::ArrowFunctionContext>(0);
}

tree::TerminalNode* CHTLJavaScriptParser::SingleExpressionContext::NEW() {
  return getToken(CHTLJavaScriptParser::NEW, 0);
}

std::vector<CHTLJavaScriptParser::SingleExpressionContext *> CHTLJavaScriptParser::SingleExpressionContext::singleExpression() {
  return getRuleContexts<CHTLJavaScriptParser::SingleExpressionContext>();
}

CHTLJavaScriptParser::SingleExpressionContext* CHTLJavaScriptParser::SingleExpressionContext::singleExpression(size_t i) {
  return getRuleContext<CHTLJavaScriptParser::SingleExpressionContext>(i);
}

CHTLJavaScriptParser::ArgumentsContext* CHTLJavaScriptParser::SingleExpressionContext::arguments() {
  return getRuleContext<CHTLJavaScriptParser::ArgumentsContext>(0);
}

tree::TerminalNode* CHTLJavaScriptParser::SingleExpressionContext::DELETE() {
  return getToken(CHTLJavaScriptParser::DELETE, 0);
}

tree::TerminalNode* CHTLJavaScriptParser::SingleExpressionContext::VOID() {
  return getToken(CHTLJavaScriptParser::VOID, 0);
}

tree::TerminalNode* CHTLJavaScriptParser::SingleExpressionContext::TYPEOF() {
  return getToken(CHTLJavaScriptParser::TYPEOF, 0);
}

tree::TerminalNode* CHTLJavaScriptParser::SingleExpressionContext::PLUSPLUS() {
  return getToken(CHTLJavaScriptParser::PLUSPLUS, 0);
}

tree::TerminalNode* CHTLJavaScriptParser::SingleExpressionContext::MINUSMINUS() {
  return getToken(CHTLJavaScriptParser::MINUSMINUS, 0);
}

tree::TerminalNode* CHTLJavaScriptParser::SingleExpressionContext::PLUS() {
  return getToken(CHTLJavaScriptParser::PLUS, 0);
}

tree::TerminalNode* CHTLJavaScriptParser::SingleExpressionContext::MINUS() {
  return getToken(CHTLJavaScriptParser::MINUS, 0);
}

tree::TerminalNode* CHTLJavaScriptParser::SingleExpressionContext::TILDE() {
  return getToken(CHTLJavaScriptParser::TILDE, 0);
}

tree::TerminalNode* CHTLJavaScriptParser::SingleExpressionContext::EXCLAMATION() {
  return getToken(CHTLJavaScriptParser::EXCLAMATION, 0);
}

tree::TerminalNode* CHTLJavaScriptParser::SingleExpressionContext::AWAIT() {
  return getToken(CHTLJavaScriptParser::AWAIT, 0);
}

tree::TerminalNode* CHTLJavaScriptParser::SingleExpressionContext::THIS() {
  return getToken(CHTLJavaScriptParser::THIS, 0);
}

tree::TerminalNode* CHTLJavaScriptParser::SingleExpressionContext::IDENTIFIER() {
  return getToken(CHTLJavaScriptParser::IDENTIFIER, 0);
}

tree::TerminalNode* CHTLJavaScriptParser::SingleExpressionContext::SUPER() {
  return getToken(CHTLJavaScriptParser::SUPER, 0);
}

CHTLJavaScriptParser::LiteralContext* CHTLJavaScriptParser::SingleExpressionContext::literal() {
  return getRuleContext<CHTLJavaScriptParser::LiteralContext>(0);
}

CHTLJavaScriptParser::ArrayLiteralContext* CHTLJavaScriptParser::SingleExpressionContext::arrayLiteral() {
  return getRuleContext<CHTLJavaScriptParser::ArrayLiteralContext>(0);
}

CHTLJavaScriptParser::ObjectLiteralContext* CHTLJavaScriptParser::SingleExpressionContext::objectLiteral() {
  return getRuleContext<CHTLJavaScriptParser::ObjectLiteralContext>(0);
}

tree::TerminalNode* CHTLJavaScriptParser::SingleExpressionContext::LPAREN() {
  return getToken(CHTLJavaScriptParser::LPAREN, 0);
}

CHTLJavaScriptParser::ExpressionSequenceContext* CHTLJavaScriptParser::SingleExpressionContext::expressionSequence() {
  return getRuleContext<CHTLJavaScriptParser::ExpressionSequenceContext>(0);
}

tree::TerminalNode* CHTLJavaScriptParser::SingleExpressionContext::RPAREN() {
  return getToken(CHTLJavaScriptParser::RPAREN, 0);
}

CHTLJavaScriptParser::TypeofExpressionContext* CHTLJavaScriptParser::SingleExpressionContext::typeofExpression() {
  return getRuleContext<CHTLJavaScriptParser::TypeofExpressionContext>(0);
}

tree::TerminalNode* CHTLJavaScriptParser::SingleExpressionContext::POWER() {
  return getToken(CHTLJavaScriptParser::POWER, 0);
}

tree::TerminalNode* CHTLJavaScriptParser::SingleExpressionContext::STAR() {
  return getToken(CHTLJavaScriptParser::STAR, 0);
}

tree::TerminalNode* CHTLJavaScriptParser::SingleExpressionContext::SLASH() {
  return getToken(CHTLJavaScriptParser::SLASH, 0);
}

tree::TerminalNode* CHTLJavaScriptParser::SingleExpressionContext::PERCENT() {
  return getToken(CHTLJavaScriptParser::PERCENT, 0);
}

tree::TerminalNode* CHTLJavaScriptParser::SingleExpressionContext::LSHIFT() {
  return getToken(CHTLJavaScriptParser::LSHIFT, 0);
}

tree::TerminalNode* CHTLJavaScriptParser::SingleExpressionContext::RSHIFT() {
  return getToken(CHTLJavaScriptParser::RSHIFT, 0);
}

tree::TerminalNode* CHTLJavaScriptParser::SingleExpressionContext::URSHIFT() {
  return getToken(CHTLJavaScriptParser::URSHIFT, 0);
}

tree::TerminalNode* CHTLJavaScriptParser::SingleExpressionContext::LT() {
  return getToken(CHTLJavaScriptParser::LT, 0);
}

tree::TerminalNode* CHTLJavaScriptParser::SingleExpressionContext::GT() {
  return getToken(CHTLJavaScriptParser::GT, 0);
}

tree::TerminalNode* CHTLJavaScriptParser::SingleExpressionContext::LE() {
  return getToken(CHTLJavaScriptParser::LE, 0);
}

tree::TerminalNode* CHTLJavaScriptParser::SingleExpressionContext::GE() {
  return getToken(CHTLJavaScriptParser::GE, 0);
}

tree::TerminalNode* CHTLJavaScriptParser::SingleExpressionContext::INSTANCEOF() {
  return getToken(CHTLJavaScriptParser::INSTANCEOF, 0);
}

tree::TerminalNode* CHTLJavaScriptParser::SingleExpressionContext::IN() {
  return getToken(CHTLJavaScriptParser::IN, 0);
}

tree::TerminalNode* CHTLJavaScriptParser::SingleExpressionContext::EQUALS_OP() {
  return getToken(CHTLJavaScriptParser::EQUALS_OP, 0);
}

tree::TerminalNode* CHTLJavaScriptParser::SingleExpressionContext::NOT_EQUALS() {
  return getToken(CHTLJavaScriptParser::NOT_EQUALS, 0);
}

tree::TerminalNode* CHTLJavaScriptParser::SingleExpressionContext::STRICT_EQUALS() {
  return getToken(CHTLJavaScriptParser::STRICT_EQUALS, 0);
}

tree::TerminalNode* CHTLJavaScriptParser::SingleExpressionContext::STRICT_NOT_EQUALS() {
  return getToken(CHTLJavaScriptParser::STRICT_NOT_EQUALS, 0);
}

tree::TerminalNode* CHTLJavaScriptParser::SingleExpressionContext::AMPERSAND() {
  return getToken(CHTLJavaScriptParser::AMPERSAND, 0);
}

tree::TerminalNode* CHTLJavaScriptParser::SingleExpressionContext::CARET() {
  return getToken(CHTLJavaScriptParser::CARET, 0);
}

tree::TerminalNode* CHTLJavaScriptParser::SingleExpressionContext::PIPE() {
  return getToken(CHTLJavaScriptParser::PIPE, 0);
}

tree::TerminalNode* CHTLJavaScriptParser::SingleExpressionContext::AND_OP() {
  return getToken(CHTLJavaScriptParser::AND_OP, 0);
}

tree::TerminalNode* CHTLJavaScriptParser::SingleExpressionContext::OR_OP() {
  return getToken(CHTLJavaScriptParser::OR_OP, 0);
}

tree::TerminalNode* CHTLJavaScriptParser::SingleExpressionContext::NULLISH_COALESCING() {
  return getToken(CHTLJavaScriptParser::NULLISH_COALESCING, 0);
}

tree::TerminalNode* CHTLJavaScriptParser::SingleExpressionContext::QUESTION() {
  return getToken(CHTLJavaScriptParser::QUESTION, 0);
}

tree::TerminalNode* CHTLJavaScriptParser::SingleExpressionContext::COLON() {
  return getToken(CHTLJavaScriptParser::COLON, 0);
}

tree::TerminalNode* CHTLJavaScriptParser::SingleExpressionContext::EQUALS() {
  return getToken(CHTLJavaScriptParser::EQUALS, 0);
}

CHTLJavaScriptParser::AssignmentOperatorContext* CHTLJavaScriptParser::SingleExpressionContext::assignmentOperator() {
  return getRuleContext<CHTLJavaScriptParser::AssignmentOperatorContext>(0);
}

tree::TerminalNode* CHTLJavaScriptParser::SingleExpressionContext::CHTL_ARROW() {
  return getToken(CHTLJavaScriptParser::CHTL_ARROW, 0);
}

CHTLJavaScriptParser::IdentifierNameContext* CHTLJavaScriptParser::SingleExpressionContext::identifierName() {
  return getRuleContext<CHTLJavaScriptParser::IdentifierNameContext>(0);
}

tree::TerminalNode* CHTLJavaScriptParser::SingleExpressionContext::LISTEN() {
  return getToken(CHTLJavaScriptParser::LISTEN, 0);
}

CHTLJavaScriptParser::ListenObjectContext* CHTLJavaScriptParser::SingleExpressionContext::listenObject() {
  return getRuleContext<CHTLJavaScriptParser::ListenObjectContext>(0);
}

tree::TerminalNode* CHTLJavaScriptParser::SingleExpressionContext::DELEGATE() {
  return getToken(CHTLJavaScriptParser::DELEGATE, 0);
}

CHTLJavaScriptParser::DelegateObjectContext* CHTLJavaScriptParser::SingleExpressionContext::delegateObject() {
  return getRuleContext<CHTLJavaScriptParser::DelegateObjectContext>(0);
}

tree::TerminalNode* CHTLJavaScriptParser::SingleExpressionContext::LBRACKET() {
  return getToken(CHTLJavaScriptParser::LBRACKET, 0);
}

tree::TerminalNode* CHTLJavaScriptParser::SingleExpressionContext::RBRACKET() {
  return getToken(CHTLJavaScriptParser::RBRACKET, 0);
}

tree::TerminalNode* CHTLJavaScriptParser::SingleExpressionContext::DOT() {
  return getToken(CHTLJavaScriptParser::DOT, 0);
}


size_t CHTLJavaScriptParser::SingleExpressionContext::getRuleIndex() const {
  return CHTLJavaScriptParser::RuleSingleExpression;
}


std::any CHTLJavaScriptParser::SingleExpressionContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<CHTLJavaScriptVisitor*>(visitor))
    return parserVisitor->visitSingleExpression(this);
  else
    return visitor->visitChildren(this);
}


CHTLJavaScriptParser::SingleExpressionContext* CHTLJavaScriptParser::singleExpression() {
   return singleExpression(0);
}

CHTLJavaScriptParser::SingleExpressionContext* CHTLJavaScriptParser::singleExpression(int precedence) {
  ParserRuleContext *parentContext = _ctx;
  size_t parentState = getState();
  CHTLJavaScriptParser::SingleExpressionContext *_localctx = _tracker.createInstance<SingleExpressionContext>(_ctx, parentState);
  CHTLJavaScriptParser::SingleExpressionContext *previousContext = _localctx;
  (void)previousContext; // Silence compiler, in case the context is not used by generated code.
  size_t startState = 0;
  enterRecursionRule(_localctx, 0, CHTLJavaScriptParser::RuleSingleExpression, precedence);

    size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    unrollRecursionContexts(parentContext);
  });
  try {
    size_t alt;
    enterOuterAlt(_localctx, 1);
    setState(215);
    _errHandler->sync(this);
    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 1, _ctx)) {
    case 1: {
      setState(175);
      chtlSelector();
      break;
    }

    case 2: {
      setState(176);
      animateCall();
      break;
    }

    case 3: {
      setState(177);
      anonymousFunction();
      break;
    }

    case 4: {
      setState(178);
      arrowFunction();
      break;
    }

    case 5: {
      setState(179);
      match(CHTLJavaScriptParser::NEW);
      setState(180);
      singleExpression(0);
      setState(182);
      _errHandler->sync(this);

      switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 0, _ctx)) {
      case 1: {
        setState(181);
        arguments();
        break;
      }

      default:
        break;
      }
      break;
    }

    case 6: {
      setState(184);
      match(CHTLJavaScriptParser::DELETE);
      setState(185);
      singleExpression(35);
      break;
    }

    case 7: {
      setState(186);
      match(CHTLJavaScriptParser::VOID);
      setState(187);
      singleExpression(34);
      break;
    }

    case 8: {
      setState(188);
      match(CHTLJavaScriptParser::TYPEOF);
      setState(189);
      singleExpression(33);
      break;
    }

    case 9: {
      setState(190);
      match(CHTLJavaScriptParser::PLUSPLUS);
      setState(191);
      singleExpression(32);
      break;
    }

    case 10: {
      setState(192);
      match(CHTLJavaScriptParser::MINUSMINUS);
      setState(193);
      singleExpression(31);
      break;
    }

    case 11: {
      setState(194);
      match(CHTLJavaScriptParser::PLUS);
      setState(195);
      singleExpression(30);
      break;
    }

    case 12: {
      setState(196);
      match(CHTLJavaScriptParser::MINUS);
      setState(197);
      singleExpression(29);
      break;
    }

    case 13: {
      setState(198);
      match(CHTLJavaScriptParser::TILDE);
      setState(199);
      singleExpression(28);
      break;
    }

    case 14: {
      setState(200);
      match(CHTLJavaScriptParser::EXCLAMATION);
      setState(201);
      singleExpression(27);
      break;
    }

    case 15: {
      setState(202);
      match(CHTLJavaScriptParser::AWAIT);
      setState(203);
      singleExpression(26);
      break;
    }

    case 16: {
      setState(204);
      match(CHTLJavaScriptParser::THIS);
      break;
    }

    case 17: {
      setState(205);
      match(CHTLJavaScriptParser::IDENTIFIER);
      break;
    }

    case 18: {
      setState(206);
      match(CHTLJavaScriptParser::SUPER);
      break;
    }

    case 19: {
      setState(207);
      literal();
      break;
    }

    case 20: {
      setState(208);
      arrayLiteral();
      break;
    }

    case 21: {
      setState(209);
      objectLiteral();
      break;
    }

    case 22: {
      setState(210);
      match(CHTLJavaScriptParser::LPAREN);
      setState(211);
      expressionSequence();
      setState(212);
      match(CHTLJavaScriptParser::RPAREN);
      break;
    }

    case 23: {
      setState(214);
      typeofExpression();
      break;
    }

    default:
      break;
    }
    _ctx->stop = _input->LT(-1);
    setState(310);
    _errHandler->sync(this);
    alt = getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 3, _ctx);
    while (alt != 2 && alt != atn::ATN::INVALID_ALT_NUMBER) {
      if (alt == 1) {
        if (!_parseListeners.empty())
          triggerExitRuleEvent();
        previousContext = _localctx;
        setState(308);
        _errHandler->sync(this);
        switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 2, _ctx)) {
        case 1: {
          _localctx = _tracker.createInstance<SingleExpressionContext>(parentContext, parentState);
          pushNewRecursionContext(_localctx, startState, RuleSingleExpression);
          setState(217);

          if (!(precpred(_ctx, 25))) throw FailedPredicateException(this, "precpred(_ctx, 25)");
          setState(218);
          match(CHTLJavaScriptParser::POWER);
          setState(219);
          singleExpression(26);
          break;
        }

        case 2: {
          _localctx = _tracker.createInstance<SingleExpressionContext>(parentContext, parentState);
          pushNewRecursionContext(_localctx, startState, RuleSingleExpression);
          setState(220);

          if (!(precpred(_ctx, 24))) throw FailedPredicateException(this, "precpred(_ctx, 24)");
          setState(221);
          _la = _input->LA(1);
          if (!(((((_la - 106) & ~ 0x3fULL) == 0) &&
            ((1ULL << (_la - 106)) & ((1ULL << (CHTLJavaScriptParser::STAR - 106))
            | (1ULL << (CHTLJavaScriptParser::SLASH - 106))
            | (1ULL << (CHTLJavaScriptParser::PERCENT - 106)))) != 0))) {
          _errHandler->recoverInline(this);
          }
          else {
            _errHandler->reportMatch(this);
            consume();
          }
          setState(222);
          singleExpression(25);
          break;
        }

        case 3: {
          _localctx = _tracker.createInstance<SingleExpressionContext>(parentContext, parentState);
          pushNewRecursionContext(_localctx, startState, RuleSingleExpression);
          setState(223);

          if (!(precpred(_ctx, 23))) throw FailedPredicateException(this, "precpred(_ctx, 23)");
          setState(224);
          _la = _input->LA(1);
          if (!(_la == CHTLJavaScriptParser::PLUS

          || _la == CHTLJavaScriptParser::MINUS)) {
          _errHandler->recoverInline(this);
          }
          else {
            _errHandler->reportMatch(this);
            consume();
          }
          setState(225);
          singleExpression(24);
          break;
        }

        case 4: {
          _localctx = _tracker.createInstance<SingleExpressionContext>(parentContext, parentState);
          pushNewRecursionContext(_localctx, startState, RuleSingleExpression);
          setState(226);

          if (!(precpred(_ctx, 22))) throw FailedPredicateException(this, "precpred(_ctx, 22)");
          setState(227);
          _la = _input->LA(1);
          if (!(((((_la - 111) & ~ 0x3fULL) == 0) &&
            ((1ULL << (_la - 111)) & ((1ULL << (CHTLJavaScriptParser::LSHIFT - 111))
            | (1ULL << (CHTLJavaScriptParser::RSHIFT - 111))
            | (1ULL << (CHTLJavaScriptParser::URSHIFT - 111)))) != 0))) {
          _errHandler->recoverInline(this);
          }
          else {
            _errHandler->reportMatch(this);
            consume();
          }
          setState(228);
          singleExpression(23);
          break;
        }

        case 5: {
          _localctx = _tracker.createInstance<SingleExpressionContext>(parentContext, parentState);
          pushNewRecursionContext(_localctx, startState, RuleSingleExpression);
          setState(229);

          if (!(precpred(_ctx, 21))) throw FailedPredicateException(this, "precpred(_ctx, 21)");
          setState(230);
          _la = _input->LA(1);
          if (!(((((_la - 114) & ~ 0x3fULL) == 0) &&
            ((1ULL << (_la - 114)) & ((1ULL << (CHTLJavaScriptParser::LT - 114))
            | (1ULL << (CHTLJavaScriptParser::GT - 114))
            | (1ULL << (CHTLJavaScriptParser::LE - 114))
            | (1ULL << (CHTLJavaScriptParser::GE - 114)))) != 0))) {
          _errHandler->recoverInline(this);
          }
          else {
            _errHandler->reportMatch(this);
            consume();
          }
          setState(231);
          singleExpression(22);
          break;
        }

        case 6: {
          _localctx = _tracker.createInstance<SingleExpressionContext>(parentContext, parentState);
          pushNewRecursionContext(_localctx, startState, RuleSingleExpression);
          setState(232);

          if (!(precpred(_ctx, 20))) throw FailedPredicateException(this, "precpred(_ctx, 20)");
          setState(233);
          match(CHTLJavaScriptParser::INSTANCEOF);
          setState(234);
          singleExpression(21);
          break;
        }

        case 7: {
          _localctx = _tracker.createInstance<SingleExpressionContext>(parentContext, parentState);
          pushNewRecursionContext(_localctx, startState, RuleSingleExpression);
          setState(235);

          if (!(precpred(_ctx, 19))) throw FailedPredicateException(this, "precpred(_ctx, 19)");
          setState(236);
          match(CHTLJavaScriptParser::IN);
          setState(237);
          singleExpression(20);
          break;
        }

        case 8: {
          _localctx = _tracker.createInstance<SingleExpressionContext>(parentContext, parentState);
          pushNewRecursionContext(_localctx, startState, RuleSingleExpression);
          setState(238);

          if (!(precpred(_ctx, 18))) throw FailedPredicateException(this, "precpred(_ctx, 18)");
          setState(239);
          _la = _input->LA(1);
          if (!(((((_la - 118) & ~ 0x3fULL) == 0) &&
            ((1ULL << (_la - 118)) & ((1ULL << (CHTLJavaScriptParser::EQUALS_OP - 118))
            | (1ULL << (CHTLJavaScriptParser::NOT_EQUALS - 118))
            | (1ULL << (CHTLJavaScriptParser::STRICT_EQUALS - 118))
            | (1ULL << (CHTLJavaScriptParser::STRICT_NOT_EQUALS - 118)))) != 0))) {
          _errHandler->recoverInline(this);
          }
          else {
            _errHandler->reportMatch(this);
            consume();
          }
          setState(240);
          singleExpression(19);
          break;
        }

        case 9: {
          _localctx = _tracker.createInstance<SingleExpressionContext>(parentContext, parentState);
          pushNewRecursionContext(_localctx, startState, RuleSingleExpression);
          setState(241);

          if (!(precpred(_ctx, 17))) throw FailedPredicateException(this, "precpred(_ctx, 17)");
          setState(242);
          match(CHTLJavaScriptParser::AMPERSAND);
          setState(243);
          singleExpression(18);
          break;
        }

        case 10: {
          _localctx = _tracker.createInstance<SingleExpressionContext>(parentContext, parentState);
          pushNewRecursionContext(_localctx, startState, RuleSingleExpression);
          setState(244);

          if (!(precpred(_ctx, 16))) throw FailedPredicateException(this, "precpred(_ctx, 16)");
          setState(245);
          match(CHTLJavaScriptParser::CARET);
          setState(246);
          singleExpression(17);
          break;
        }

        case 11: {
          _localctx = _tracker.createInstance<SingleExpressionContext>(parentContext, parentState);
          pushNewRecursionContext(_localctx, startState, RuleSingleExpression);
          setState(247);

          if (!(precpred(_ctx, 15))) throw FailedPredicateException(this, "precpred(_ctx, 15)");
          setState(248);
          match(CHTLJavaScriptParser::PIPE);
          setState(249);
          singleExpression(16);
          break;
        }

        case 12: {
          _localctx = _tracker.createInstance<SingleExpressionContext>(parentContext, parentState);
          pushNewRecursionContext(_localctx, startState, RuleSingleExpression);
          setState(250);

          if (!(precpred(_ctx, 14))) throw FailedPredicateException(this, "precpred(_ctx, 14)");
          setState(251);
          match(CHTLJavaScriptParser::AND_OP);
          setState(252);
          singleExpression(15);
          break;
        }

        case 13: {
          _localctx = _tracker.createInstance<SingleExpressionContext>(parentContext, parentState);
          pushNewRecursionContext(_localctx, startState, RuleSingleExpression);
          setState(253);

          if (!(precpred(_ctx, 13))) throw FailedPredicateException(this, "precpred(_ctx, 13)");
          setState(254);
          match(CHTLJavaScriptParser::OR_OP);
          setState(255);
          singleExpression(14);
          break;
        }

        case 14: {
          _localctx = _tracker.createInstance<SingleExpressionContext>(parentContext, parentState);
          pushNewRecursionContext(_localctx, startState, RuleSingleExpression);
          setState(256);

          if (!(precpred(_ctx, 12))) throw FailedPredicateException(this, "precpred(_ctx, 12)");
          setState(257);
          match(CHTLJavaScriptParser::NULLISH_COALESCING);
          setState(258);
          singleExpression(13);
          break;
        }

        case 15: {
          _localctx = _tracker.createInstance<SingleExpressionContext>(parentContext, parentState);
          pushNewRecursionContext(_localctx, startState, RuleSingleExpression);
          setState(259);

          if (!(precpred(_ctx, 11))) throw FailedPredicateException(this, "precpred(_ctx, 11)");
          setState(260);
          match(CHTLJavaScriptParser::QUESTION);
          setState(261);
          singleExpression(0);
          setState(262);
          match(CHTLJavaScriptParser::COLON);
          setState(263);
          singleExpression(12);
          break;
        }

        case 16: {
          _localctx = _tracker.createInstance<SingleExpressionContext>(parentContext, parentState);
          pushNewRecursionContext(_localctx, startState, RuleSingleExpression);
          setState(265);

          if (!(precpred(_ctx, 10))) throw FailedPredicateException(this, "precpred(_ctx, 10)");
          setState(266);
          match(CHTLJavaScriptParser::EQUALS);
          setState(267);
          singleExpression(11);
          break;
        }

        case 17: {
          _localctx = _tracker.createInstance<SingleExpressionContext>(parentContext, parentState);
          pushNewRecursionContext(_localctx, startState, RuleSingleExpression);
          setState(268);

          if (!(precpred(_ctx, 9))) throw FailedPredicateException(this, "precpred(_ctx, 9)");
          setState(269);
          assignmentOperator();
          setState(270);
          singleExpression(10);
          break;
        }

        case 18: {
          _localctx = _tracker.createInstance<SingleExpressionContext>(parentContext, parentState);
          pushNewRecursionContext(_localctx, startState, RuleSingleExpression);
          setState(272);

          if (!(precpred(_ctx, 48))) throw FailedPredicateException(this, "precpred(_ctx, 48)");
          setState(273);
          match(CHTLJavaScriptParser::CHTL_ARROW);
          setState(274);
          identifierName();
          break;
        }

        case 19: {
          _localctx = _tracker.createInstance<SingleExpressionContext>(parentContext, parentState);
          pushNewRecursionContext(_localctx, startState, RuleSingleExpression);
          setState(275);

          if (!(precpred(_ctx, 47))) throw FailedPredicateException(this, "precpred(_ctx, 47)");
          setState(276);
          match(CHTLJavaScriptParser::CHTL_ARROW);
          setState(277);
          identifierName();
          setState(278);
          arguments();
          break;
        }

        case 20: {
          _localctx = _tracker.createInstance<SingleExpressionContext>(parentContext, parentState);
          pushNewRecursionContext(_localctx, startState, RuleSingleExpression);
          setState(280);

          if (!(precpred(_ctx, 46))) throw FailedPredicateException(this, "precpred(_ctx, 46)");
          setState(281);
          match(CHTLJavaScriptParser::CHTL_ARROW);
          setState(282);
          match(CHTLJavaScriptParser::LISTEN);
          setState(283);
          match(CHTLJavaScriptParser::LPAREN);
          setState(284);
          listenObject();
          setState(285);
          match(CHTLJavaScriptParser::RPAREN);
          break;
        }

        case 21: {
          _localctx = _tracker.createInstance<SingleExpressionContext>(parentContext, parentState);
          pushNewRecursionContext(_localctx, startState, RuleSingleExpression);
          setState(287);

          if (!(precpred(_ctx, 45))) throw FailedPredicateException(this, "precpred(_ctx, 45)");
          setState(288);
          match(CHTLJavaScriptParser::CHTL_ARROW);
          setState(289);
          match(CHTLJavaScriptParser::DELEGATE);
          setState(290);
          match(CHTLJavaScriptParser::LPAREN);
          setState(291);
          delegateObject();
          setState(292);
          match(CHTLJavaScriptParser::RPAREN);
          break;
        }

        case 22: {
          _localctx = _tracker.createInstance<SingleExpressionContext>(parentContext, parentState);
          pushNewRecursionContext(_localctx, startState, RuleSingleExpression);
          setState(294);

          if (!(precpred(_ctx, 41))) throw FailedPredicateException(this, "precpred(_ctx, 41)");
          setState(295);
          match(CHTLJavaScriptParser::LBRACKET);
          setState(296);
          expressionSequence();
          setState(297);
          match(CHTLJavaScriptParser::RBRACKET);
          break;
        }

        case 23: {
          _localctx = _tracker.createInstance<SingleExpressionContext>(parentContext, parentState);
          pushNewRecursionContext(_localctx, startState, RuleSingleExpression);
          setState(299);

          if (!(precpred(_ctx, 40))) throw FailedPredicateException(this, "precpred(_ctx, 40)");
          setState(300);
          match(CHTLJavaScriptParser::DOT);
          setState(301);
          identifierName();
          break;
        }

        case 24: {
          _localctx = _tracker.createInstance<SingleExpressionContext>(parentContext, parentState);
          pushNewRecursionContext(_localctx, startState, RuleSingleExpression);
          setState(302);

          if (!(precpred(_ctx, 39))) throw FailedPredicateException(this, "precpred(_ctx, 39)");
          setState(303);
          arguments();
          break;
        }

        case 25: {
          _localctx = _tracker.createInstance<SingleExpressionContext>(parentContext, parentState);
          pushNewRecursionContext(_localctx, startState, RuleSingleExpression);
          setState(304);

          if (!(precpred(_ctx, 37))) throw FailedPredicateException(this, "precpred(_ctx, 37)");
          setState(305);
          match(CHTLJavaScriptParser::PLUSPLUS);
          break;
        }

        case 26: {
          _localctx = _tracker.createInstance<SingleExpressionContext>(parentContext, parentState);
          pushNewRecursionContext(_localctx, startState, RuleSingleExpression);
          setState(306);

          if (!(precpred(_ctx, 36))) throw FailedPredicateException(this, "precpred(_ctx, 36)");
          setState(307);
          match(CHTLJavaScriptParser::MINUSMINUS);
          break;
        }

        default:
          break;
        } 
      }
      setState(312);
      _errHandler->sync(this);
      alt = getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 3, _ctx);
    }
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }
  return _localctx;
}

//----------------- ChtlSelectorListContext ------------------------------------------------------------------

CHTLJavaScriptParser::ChtlSelectorListContext::ChtlSelectorListContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

std::vector<CHTLJavaScriptParser::ChtlSelectorContext *> CHTLJavaScriptParser::ChtlSelectorListContext::chtlSelector() {
  return getRuleContexts<CHTLJavaScriptParser::ChtlSelectorContext>();
}

CHTLJavaScriptParser::ChtlSelectorContext* CHTLJavaScriptParser::ChtlSelectorListContext::chtlSelector(size_t i) {
  return getRuleContext<CHTLJavaScriptParser::ChtlSelectorContext>(i);
}

std::vector<tree::TerminalNode *> CHTLJavaScriptParser::ChtlSelectorListContext::COMMA() {
  return getTokens(CHTLJavaScriptParser::COMMA);
}

tree::TerminalNode* CHTLJavaScriptParser::ChtlSelectorListContext::COMMA(size_t i) {
  return getToken(CHTLJavaScriptParser::COMMA, i);
}


size_t CHTLJavaScriptParser::ChtlSelectorListContext::getRuleIndex() const {
  return CHTLJavaScriptParser::RuleChtlSelectorList;
}


std::any CHTLJavaScriptParser::ChtlSelectorListContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<CHTLJavaScriptVisitor*>(visitor))
    return parserVisitor->visitChtlSelectorList(this);
  else
    return visitor->visitChildren(this);
}

CHTLJavaScriptParser::ChtlSelectorListContext* CHTLJavaScriptParser::chtlSelectorList() {
  ChtlSelectorListContext *_localctx = _tracker.createInstance<ChtlSelectorListContext>(_ctx, getState());
  enterRule(_localctx, 2, CHTLJavaScriptParser::RuleChtlSelectorList);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(313);
    chtlSelector();
    setState(318);
    _errHandler->sync(this);
    _la = _input->LA(1);
    while (_la == CHTLJavaScriptParser::COMMA) {
      setState(314);
      match(CHTLJavaScriptParser::COMMA);
      setState(315);
      chtlSelector();
      setState(320);
      _errHandler->sync(this);
      _la = _input->LA(1);
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- ChtlSelectorContext ------------------------------------------------------------------

CHTLJavaScriptParser::ChtlSelectorContext::ChtlSelectorContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* CHTLJavaScriptParser::ChtlSelectorContext::CHTL_SELECTOR_START() {
  return getToken(CHTLJavaScriptParser::CHTL_SELECTOR_START, 0);
}

CHTLJavaScriptParser::ChtlSelectorContentContext* CHTLJavaScriptParser::ChtlSelectorContext::chtlSelectorContent() {
  return getRuleContext<CHTLJavaScriptParser::ChtlSelectorContentContext>(0);
}

tree::TerminalNode* CHTLJavaScriptParser::ChtlSelectorContext::CHTL_SELECTOR_END() {
  return getToken(CHTLJavaScriptParser::CHTL_SELECTOR_END, 0);
}


size_t CHTLJavaScriptParser::ChtlSelectorContext::getRuleIndex() const {
  return CHTLJavaScriptParser::RuleChtlSelector;
}


std::any CHTLJavaScriptParser::ChtlSelectorContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<CHTLJavaScriptVisitor*>(visitor))
    return parserVisitor->visitChtlSelector(this);
  else
    return visitor->visitChildren(this);
}

CHTLJavaScriptParser::ChtlSelectorContext* CHTLJavaScriptParser::chtlSelector() {
  ChtlSelectorContext *_localctx = _tracker.createInstance<ChtlSelectorContext>(_ctx, getState());
  enterRule(_localctx, 4, CHTLJavaScriptParser::RuleChtlSelector);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(321);
    match(CHTLJavaScriptParser::CHTL_SELECTOR_START);
    setState(322);
    chtlSelectorContent();
    setState(323);
    match(CHTLJavaScriptParser::CHTL_SELECTOR_END);
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- ChtlSelectorContentContext ------------------------------------------------------------------

CHTLJavaScriptParser::ChtlSelectorContentContext::ChtlSelectorContentContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* CHTLJavaScriptParser::ChtlSelectorContentContext::IDENTIFIER() {
  return getToken(CHTLJavaScriptParser::IDENTIFIER, 0);
}

tree::TerminalNode* CHTLJavaScriptParser::ChtlSelectorContentContext::DOT() {
  return getToken(CHTLJavaScriptParser::DOT, 0);
}

tree::TerminalNode* CHTLJavaScriptParser::ChtlSelectorContentContext::HASH() {
  return getToken(CHTLJavaScriptParser::HASH, 0);
}

CHTLJavaScriptParser::SingleExpressionContext* CHTLJavaScriptParser::ChtlSelectorContentContext::singleExpression() {
  return getRuleContext<CHTLJavaScriptParser::SingleExpressionContext>(0);
}


size_t CHTLJavaScriptParser::ChtlSelectorContentContext::getRuleIndex() const {
  return CHTLJavaScriptParser::RuleChtlSelectorContent;
}


std::any CHTLJavaScriptParser::ChtlSelectorContentContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<CHTLJavaScriptVisitor*>(visitor))
    return parserVisitor->visitChtlSelectorContent(this);
  else
    return visitor->visitChildren(this);
}

CHTLJavaScriptParser::ChtlSelectorContentContext* CHTLJavaScriptParser::chtlSelectorContent() {
  ChtlSelectorContentContext *_localctx = _tracker.createInstance<ChtlSelectorContentContext>(_ctx, getState());
  enterRule(_localctx, 6, CHTLJavaScriptParser::RuleChtlSelectorContent);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    setState(331);
    _errHandler->sync(this);
    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 5, _ctx)) {
    case 1: {
      enterOuterAlt(_localctx, 1);
      setState(325);
      match(CHTLJavaScriptParser::IDENTIFIER);
      break;
    }

    case 2: {
      enterOuterAlt(_localctx, 2);
      setState(326);
      match(CHTLJavaScriptParser::DOT);
      setState(327);
      match(CHTLJavaScriptParser::IDENTIFIER);
      break;
    }

    case 3: {
      enterOuterAlt(_localctx, 3);
      setState(328);
      match(CHTLJavaScriptParser::HASH);
      setState(329);
      match(CHTLJavaScriptParser::IDENTIFIER);
      break;
    }

    case 4: {
      enterOuterAlt(_localctx, 4);
      setState(330);
      singleExpression(0);
      break;
    }

    default:
      break;
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- CssSelectorContext ------------------------------------------------------------------

CHTLJavaScriptParser::CssSelectorContext::CssSelectorContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

std::vector<CHTLJavaScriptParser::CssSelectorPartContext *> CHTLJavaScriptParser::CssSelectorContext::cssSelectorPart() {
  return getRuleContexts<CHTLJavaScriptParser::CssSelectorPartContext>();
}

CHTLJavaScriptParser::CssSelectorPartContext* CHTLJavaScriptParser::CssSelectorContext::cssSelectorPart(size_t i) {
  return getRuleContext<CHTLJavaScriptParser::CssSelectorPartContext>(i);
}


size_t CHTLJavaScriptParser::CssSelectorContext::getRuleIndex() const {
  return CHTLJavaScriptParser::RuleCssSelector;
}


std::any CHTLJavaScriptParser::CssSelectorContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<CHTLJavaScriptVisitor*>(visitor))
    return parserVisitor->visitCssSelector(this);
  else
    return visitor->visitChildren(this);
}

CHTLJavaScriptParser::CssSelectorContext* CHTLJavaScriptParser::cssSelector() {
  CssSelectorContext *_localctx = _tracker.createInstance<CssSelectorContext>(_ctx, getState());
  enterRule(_localctx, 8, CHTLJavaScriptParser::RuleCssSelector);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(334); 
    _errHandler->sync(this);
    _la = _input->LA(1);
    do {
      setState(333);
      cssSelectorPart();
      setState(336); 
      _errHandler->sync(this);
      _la = _input->LA(1);
    } while ((((_la & ~ 0x3fULL) == 0) &&
      ((1ULL << _la) & ((1ULL << CHTLJavaScriptParser::HASH)
      | (1ULL << CHTLJavaScriptParser::SPACE)
      | (1ULL << CHTLJavaScriptParser::IDENTIFIER))) != 0) || _la == CHTLJavaScriptParser::LBRACKET

    || _la == CHTLJavaScriptParser::DOT);
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- CssSelectorPartContext ------------------------------------------------------------------

CHTLJavaScriptParser::CssSelectorPartContext::CssSelectorPartContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* CHTLJavaScriptParser::CssSelectorPartContext::IDENTIFIER() {
  return getToken(CHTLJavaScriptParser::IDENTIFIER, 0);
}

tree::TerminalNode* CHTLJavaScriptParser::CssSelectorPartContext::DOT() {
  return getToken(CHTLJavaScriptParser::DOT, 0);
}

tree::TerminalNode* CHTLJavaScriptParser::CssSelectorPartContext::HASH() {
  return getToken(CHTLJavaScriptParser::HASH, 0);
}

tree::TerminalNode* CHTLJavaScriptParser::CssSelectorPartContext::LBRACKET() {
  return getToken(CHTLJavaScriptParser::LBRACKET, 0);
}

tree::TerminalNode* CHTLJavaScriptParser::CssSelectorPartContext::NUMBER() {
  return getToken(CHTLJavaScriptParser::NUMBER, 0);
}

tree::TerminalNode* CHTLJavaScriptParser::CssSelectorPartContext::RBRACKET() {
  return getToken(CHTLJavaScriptParser::RBRACKET, 0);
}

tree::TerminalNode* CHTLJavaScriptParser::CssSelectorPartContext::SPACE() {
  return getToken(CHTLJavaScriptParser::SPACE, 0);
}


size_t CHTLJavaScriptParser::CssSelectorPartContext::getRuleIndex() const {
  return CHTLJavaScriptParser::RuleCssSelectorPart;
}


std::any CHTLJavaScriptParser::CssSelectorPartContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<CHTLJavaScriptVisitor*>(visitor))
    return parserVisitor->visitCssSelectorPart(this);
  else
    return visitor->visitChildren(this);
}

CHTLJavaScriptParser::CssSelectorPartContext* CHTLJavaScriptParser::cssSelectorPart() {
  CssSelectorPartContext *_localctx = _tracker.createInstance<CssSelectorPartContext>(_ctx, getState());
  enterRule(_localctx, 10, CHTLJavaScriptParser::RuleCssSelectorPart);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    setState(347);
    _errHandler->sync(this);
    switch (_input->LA(1)) {
      case CHTLJavaScriptParser::IDENTIFIER: {
        enterOuterAlt(_localctx, 1);
        setState(338);
        match(CHTLJavaScriptParser::IDENTIFIER);
        break;
      }

      case CHTLJavaScriptParser::DOT: {
        enterOuterAlt(_localctx, 2);
        setState(339);
        match(CHTLJavaScriptParser::DOT);
        setState(340);
        match(CHTLJavaScriptParser::IDENTIFIER);
        break;
      }

      case CHTLJavaScriptParser::HASH: {
        enterOuterAlt(_localctx, 3);
        setState(341);
        match(CHTLJavaScriptParser::HASH);
        setState(342);
        match(CHTLJavaScriptParser::IDENTIFIER);
        break;
      }

      case CHTLJavaScriptParser::LBRACKET: {
        enterOuterAlt(_localctx, 4);
        setState(343);
        match(CHTLJavaScriptParser::LBRACKET);
        setState(344);
        match(CHTLJavaScriptParser::NUMBER);
        setState(345);
        match(CHTLJavaScriptParser::RBRACKET);
        break;
      }

      case CHTLJavaScriptParser::SPACE: {
        enterOuterAlt(_localctx, 5);
        setState(346);
        match(CHTLJavaScriptParser::SPACE);
        break;
      }

    default:
      throw NoViableAltException(this);
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- ListenObjectContext ------------------------------------------------------------------

CHTLJavaScriptParser::ListenObjectContext::ListenObjectContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* CHTLJavaScriptParser::ListenObjectContext::LBRACE() {
  return getToken(CHTLJavaScriptParser::LBRACE, 0);
}

std::vector<CHTLJavaScriptParser::EventBindingContext *> CHTLJavaScriptParser::ListenObjectContext::eventBinding() {
  return getRuleContexts<CHTLJavaScriptParser::EventBindingContext>();
}

CHTLJavaScriptParser::EventBindingContext* CHTLJavaScriptParser::ListenObjectContext::eventBinding(size_t i) {
  return getRuleContext<CHTLJavaScriptParser::EventBindingContext>(i);
}

tree::TerminalNode* CHTLJavaScriptParser::ListenObjectContext::RBRACE() {
  return getToken(CHTLJavaScriptParser::RBRACE, 0);
}

std::vector<tree::TerminalNode *> CHTLJavaScriptParser::ListenObjectContext::COMMA() {
  return getTokens(CHTLJavaScriptParser::COMMA);
}

tree::TerminalNode* CHTLJavaScriptParser::ListenObjectContext::COMMA(size_t i) {
  return getToken(CHTLJavaScriptParser::COMMA, i);
}


size_t CHTLJavaScriptParser::ListenObjectContext::getRuleIndex() const {
  return CHTLJavaScriptParser::RuleListenObject;
}


std::any CHTLJavaScriptParser::ListenObjectContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<CHTLJavaScriptVisitor*>(visitor))
    return parserVisitor->visitListenObject(this);
  else
    return visitor->visitChildren(this);
}

CHTLJavaScriptParser::ListenObjectContext* CHTLJavaScriptParser::listenObject() {
  ListenObjectContext *_localctx = _tracker.createInstance<ListenObjectContext>(_ctx, getState());
  enterRule(_localctx, 12, CHTLJavaScriptParser::RuleListenObject);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(349);
    match(CHTLJavaScriptParser::LBRACE);
    setState(350);
    eventBinding();
    setState(355);
    _errHandler->sync(this);
    _la = _input->LA(1);
    while (_la == CHTLJavaScriptParser::COMMA) {
      setState(351);
      match(CHTLJavaScriptParser::COMMA);
      setState(352);
      eventBinding();
      setState(357);
      _errHandler->sync(this);
      _la = _input->LA(1);
    }
    setState(358);
    match(CHTLJavaScriptParser::RBRACE);
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- EventBindingContext ------------------------------------------------------------------

CHTLJavaScriptParser::EventBindingContext::EventBindingContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

std::vector<tree::TerminalNode *> CHTLJavaScriptParser::EventBindingContext::IDENTIFIER() {
  return getTokens(CHTLJavaScriptParser::IDENTIFIER);
}

tree::TerminalNode* CHTLJavaScriptParser::EventBindingContext::IDENTIFIER(size_t i) {
  return getToken(CHTLJavaScriptParser::IDENTIFIER, i);
}

tree::TerminalNode* CHTLJavaScriptParser::EventBindingContext::COLON() {
  return getToken(CHTLJavaScriptParser::COLON, 0);
}

CHTLJavaScriptParser::SingleExpressionContext* CHTLJavaScriptParser::EventBindingContext::singleExpression() {
  return getRuleContext<CHTLJavaScriptParser::SingleExpressionContext>(0);
}


size_t CHTLJavaScriptParser::EventBindingContext::getRuleIndex() const {
  return CHTLJavaScriptParser::RuleEventBinding;
}


std::any CHTLJavaScriptParser::EventBindingContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<CHTLJavaScriptVisitor*>(visitor))
    return parserVisitor->visitEventBinding(this);
  else
    return visitor->visitChildren(this);
}

CHTLJavaScriptParser::EventBindingContext* CHTLJavaScriptParser::eventBinding() {
  EventBindingContext *_localctx = _tracker.createInstance<EventBindingContext>(_ctx, getState());
  enterRule(_localctx, 14, CHTLJavaScriptParser::RuleEventBinding);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(360);
    match(CHTLJavaScriptParser::IDENTIFIER);
    setState(361);
    match(CHTLJavaScriptParser::COLON);
    setState(364);
    _errHandler->sync(this);
    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 9, _ctx)) {
    case 1: {
      setState(362);
      singleExpression(0);
      break;
    }

    case 2: {
      setState(363);
      match(CHTLJavaScriptParser::IDENTIFIER);
      break;
    }

    default:
      break;
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- DelegateObjectContext ------------------------------------------------------------------

CHTLJavaScriptParser::DelegateObjectContext::DelegateObjectContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* CHTLJavaScriptParser::DelegateObjectContext::LBRACE() {
  return getToken(CHTLJavaScriptParser::LBRACE, 0);
}

std::vector<CHTLJavaScriptParser::DelegatePropertyContext *> CHTLJavaScriptParser::DelegateObjectContext::delegateProperty() {
  return getRuleContexts<CHTLJavaScriptParser::DelegatePropertyContext>();
}

CHTLJavaScriptParser::DelegatePropertyContext* CHTLJavaScriptParser::DelegateObjectContext::delegateProperty(size_t i) {
  return getRuleContext<CHTLJavaScriptParser::DelegatePropertyContext>(i);
}

tree::TerminalNode* CHTLJavaScriptParser::DelegateObjectContext::RBRACE() {
  return getToken(CHTLJavaScriptParser::RBRACE, 0);
}

std::vector<tree::TerminalNode *> CHTLJavaScriptParser::DelegateObjectContext::COMMA() {
  return getTokens(CHTLJavaScriptParser::COMMA);
}

tree::TerminalNode* CHTLJavaScriptParser::DelegateObjectContext::COMMA(size_t i) {
  return getToken(CHTLJavaScriptParser::COMMA, i);
}


size_t CHTLJavaScriptParser::DelegateObjectContext::getRuleIndex() const {
  return CHTLJavaScriptParser::RuleDelegateObject;
}


std::any CHTLJavaScriptParser::DelegateObjectContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<CHTLJavaScriptVisitor*>(visitor))
    return parserVisitor->visitDelegateObject(this);
  else
    return visitor->visitChildren(this);
}

CHTLJavaScriptParser::DelegateObjectContext* CHTLJavaScriptParser::delegateObject() {
  DelegateObjectContext *_localctx = _tracker.createInstance<DelegateObjectContext>(_ctx, getState());
  enterRule(_localctx, 16, CHTLJavaScriptParser::RuleDelegateObject);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(366);
    match(CHTLJavaScriptParser::LBRACE);
    setState(367);
    delegateProperty();
    setState(372);
    _errHandler->sync(this);
    _la = _input->LA(1);
    while (_la == CHTLJavaScriptParser::COMMA) {
      setState(368);
      match(CHTLJavaScriptParser::COMMA);
      setState(369);
      delegateProperty();
      setState(374);
      _errHandler->sync(this);
      _la = _input->LA(1);
    }
    setState(375);
    match(CHTLJavaScriptParser::RBRACE);
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- DelegatePropertyContext ------------------------------------------------------------------

CHTLJavaScriptParser::DelegatePropertyContext::DelegatePropertyContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* CHTLJavaScriptParser::DelegatePropertyContext::TARGET() {
  return getToken(CHTLJavaScriptParser::TARGET, 0);
}

tree::TerminalNode* CHTLJavaScriptParser::DelegatePropertyContext::COLON() {
  return getToken(CHTLJavaScriptParser::COLON, 0);
}

CHTLJavaScriptParser::ChtlSelectorContext* CHTLJavaScriptParser::DelegatePropertyContext::chtlSelector() {
  return getRuleContext<CHTLJavaScriptParser::ChtlSelectorContext>(0);
}

CHTLJavaScriptParser::SelectorArrayContext* CHTLJavaScriptParser::DelegatePropertyContext::selectorArray() {
  return getRuleContext<CHTLJavaScriptParser::SelectorArrayContext>(0);
}

tree::TerminalNode* CHTLJavaScriptParser::DelegatePropertyContext::IDENTIFIER() {
  return getToken(CHTLJavaScriptParser::IDENTIFIER, 0);
}

CHTLJavaScriptParser::SingleExpressionContext* CHTLJavaScriptParser::DelegatePropertyContext::singleExpression() {
  return getRuleContext<CHTLJavaScriptParser::SingleExpressionContext>(0);
}


size_t CHTLJavaScriptParser::DelegatePropertyContext::getRuleIndex() const {
  return CHTLJavaScriptParser::RuleDelegateProperty;
}


std::any CHTLJavaScriptParser::DelegatePropertyContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<CHTLJavaScriptVisitor*>(visitor))
    return parserVisitor->visitDelegateProperty(this);
  else
    return visitor->visitChildren(this);
}

CHTLJavaScriptParser::DelegatePropertyContext* CHTLJavaScriptParser::delegateProperty() {
  DelegatePropertyContext *_localctx = _tracker.createInstance<DelegatePropertyContext>(_ctx, getState());
  enterRule(_localctx, 18, CHTLJavaScriptParser::RuleDelegateProperty);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    setState(386);
    _errHandler->sync(this);
    switch (_input->LA(1)) {
      case CHTLJavaScriptParser::TARGET: {
        enterOuterAlt(_localctx, 1);
        setState(377);
        match(CHTLJavaScriptParser::TARGET);
        setState(378);
        match(CHTLJavaScriptParser::COLON);
        setState(381);
        _errHandler->sync(this);
        switch (_input->LA(1)) {
          case CHTLJavaScriptParser::CHTL_SELECTOR_START: {
            setState(379);
            chtlSelector();
            break;
          }

          case CHTLJavaScriptParser::LBRACKET: {
            setState(380);
            selectorArray();
            break;
          }

        default:
          throw NoViableAltException(this);
        }
        break;
      }

      case CHTLJavaScriptParser::IDENTIFIER: {
        enterOuterAlt(_localctx, 2);
        setState(383);
        match(CHTLJavaScriptParser::IDENTIFIER);
        setState(384);
        match(CHTLJavaScriptParser::COLON);
        setState(385);
        singleExpression(0);
        break;
      }

    default:
      throw NoViableAltException(this);
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- SelectorArrayContext ------------------------------------------------------------------

CHTLJavaScriptParser::SelectorArrayContext::SelectorArrayContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* CHTLJavaScriptParser::SelectorArrayContext::LBRACKET() {
  return getToken(CHTLJavaScriptParser::LBRACKET, 0);
}

std::vector<CHTLJavaScriptParser::ChtlSelectorContext *> CHTLJavaScriptParser::SelectorArrayContext::chtlSelector() {
  return getRuleContexts<CHTLJavaScriptParser::ChtlSelectorContext>();
}

CHTLJavaScriptParser::ChtlSelectorContext* CHTLJavaScriptParser::SelectorArrayContext::chtlSelector(size_t i) {
  return getRuleContext<CHTLJavaScriptParser::ChtlSelectorContext>(i);
}

tree::TerminalNode* CHTLJavaScriptParser::SelectorArrayContext::RBRACKET() {
  return getToken(CHTLJavaScriptParser::RBRACKET, 0);
}

std::vector<tree::TerminalNode *> CHTLJavaScriptParser::SelectorArrayContext::COMMA() {
  return getTokens(CHTLJavaScriptParser::COMMA);
}

tree::TerminalNode* CHTLJavaScriptParser::SelectorArrayContext::COMMA(size_t i) {
  return getToken(CHTLJavaScriptParser::COMMA, i);
}


size_t CHTLJavaScriptParser::SelectorArrayContext::getRuleIndex() const {
  return CHTLJavaScriptParser::RuleSelectorArray;
}


std::any CHTLJavaScriptParser::SelectorArrayContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<CHTLJavaScriptVisitor*>(visitor))
    return parserVisitor->visitSelectorArray(this);
  else
    return visitor->visitChildren(this);
}

CHTLJavaScriptParser::SelectorArrayContext* CHTLJavaScriptParser::selectorArray() {
  SelectorArrayContext *_localctx = _tracker.createInstance<SelectorArrayContext>(_ctx, getState());
  enterRule(_localctx, 20, CHTLJavaScriptParser::RuleSelectorArray);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(388);
    match(CHTLJavaScriptParser::LBRACKET);
    setState(389);
    chtlSelector();
    setState(394);
    _errHandler->sync(this);
    _la = _input->LA(1);
    while (_la == CHTLJavaScriptParser::COMMA) {
      setState(390);
      match(CHTLJavaScriptParser::COMMA);
      setState(391);
      chtlSelector();
      setState(396);
      _errHandler->sync(this);
      _la = _input->LA(1);
    }
    setState(397);
    match(CHTLJavaScriptParser::RBRACKET);
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- AnimateCallContext ------------------------------------------------------------------

CHTLJavaScriptParser::AnimateCallContext::AnimateCallContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* CHTLJavaScriptParser::AnimateCallContext::ANIMATE() {
  return getToken(CHTLJavaScriptParser::ANIMATE, 0);
}

tree::TerminalNode* CHTLJavaScriptParser::AnimateCallContext::LPAREN() {
  return getToken(CHTLJavaScriptParser::LPAREN, 0);
}

CHTLJavaScriptParser::AnimateObjectContext* CHTLJavaScriptParser::AnimateCallContext::animateObject() {
  return getRuleContext<CHTLJavaScriptParser::AnimateObjectContext>(0);
}

tree::TerminalNode* CHTLJavaScriptParser::AnimateCallContext::RPAREN() {
  return getToken(CHTLJavaScriptParser::RPAREN, 0);
}


size_t CHTLJavaScriptParser::AnimateCallContext::getRuleIndex() const {
  return CHTLJavaScriptParser::RuleAnimateCall;
}


std::any CHTLJavaScriptParser::AnimateCallContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<CHTLJavaScriptVisitor*>(visitor))
    return parserVisitor->visitAnimateCall(this);
  else
    return visitor->visitChildren(this);
}

CHTLJavaScriptParser::AnimateCallContext* CHTLJavaScriptParser::animateCall() {
  AnimateCallContext *_localctx = _tracker.createInstance<AnimateCallContext>(_ctx, getState());
  enterRule(_localctx, 22, CHTLJavaScriptParser::RuleAnimateCall);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(399);
    match(CHTLJavaScriptParser::ANIMATE);
    setState(400);
    match(CHTLJavaScriptParser::LPAREN);
    setState(401);
    animateObject();
    setState(402);
    match(CHTLJavaScriptParser::RPAREN);
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- AnimateObjectContext ------------------------------------------------------------------

CHTLJavaScriptParser::AnimateObjectContext::AnimateObjectContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* CHTLJavaScriptParser::AnimateObjectContext::LBRACE() {
  return getToken(CHTLJavaScriptParser::LBRACE, 0);
}

std::vector<CHTLJavaScriptParser::AnimatePropertyContext *> CHTLJavaScriptParser::AnimateObjectContext::animateProperty() {
  return getRuleContexts<CHTLJavaScriptParser::AnimatePropertyContext>();
}

CHTLJavaScriptParser::AnimatePropertyContext* CHTLJavaScriptParser::AnimateObjectContext::animateProperty(size_t i) {
  return getRuleContext<CHTLJavaScriptParser::AnimatePropertyContext>(i);
}

tree::TerminalNode* CHTLJavaScriptParser::AnimateObjectContext::RBRACE() {
  return getToken(CHTLJavaScriptParser::RBRACE, 0);
}

std::vector<tree::TerminalNode *> CHTLJavaScriptParser::AnimateObjectContext::COMMA() {
  return getTokens(CHTLJavaScriptParser::COMMA);
}

tree::TerminalNode* CHTLJavaScriptParser::AnimateObjectContext::COMMA(size_t i) {
  return getToken(CHTLJavaScriptParser::COMMA, i);
}


size_t CHTLJavaScriptParser::AnimateObjectContext::getRuleIndex() const {
  return CHTLJavaScriptParser::RuleAnimateObject;
}


std::any CHTLJavaScriptParser::AnimateObjectContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<CHTLJavaScriptVisitor*>(visitor))
    return parserVisitor->visitAnimateObject(this);
  else
    return visitor->visitChildren(this);
}

CHTLJavaScriptParser::AnimateObjectContext* CHTLJavaScriptParser::animateObject() {
  AnimateObjectContext *_localctx = _tracker.createInstance<AnimateObjectContext>(_ctx, getState());
  enterRule(_localctx, 24, CHTLJavaScriptParser::RuleAnimateObject);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(404);
    match(CHTLJavaScriptParser::LBRACE);
    setState(405);
    animateProperty();
    setState(410);
    _errHandler->sync(this);
    _la = _input->LA(1);
    while (_la == CHTLJavaScriptParser::COMMA) {
      setState(406);
      match(CHTLJavaScriptParser::COMMA);
      setState(407);
      animateProperty();
      setState(412);
      _errHandler->sync(this);
      _la = _input->LA(1);
    }
    setState(413);
    match(CHTLJavaScriptParser::RBRACE);
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- AnimatePropertyContext ------------------------------------------------------------------

CHTLJavaScriptParser::AnimatePropertyContext::AnimatePropertyContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* CHTLJavaScriptParser::AnimatePropertyContext::DURATION() {
  return getToken(CHTLJavaScriptParser::DURATION, 0);
}

tree::TerminalNode* CHTLJavaScriptParser::AnimatePropertyContext::COLON() {
  return getToken(CHTLJavaScriptParser::COLON, 0);
}

tree::TerminalNode* CHTLJavaScriptParser::AnimatePropertyContext::NUMBER() {
  return getToken(CHTLJavaScriptParser::NUMBER, 0);
}

tree::TerminalNode* CHTLJavaScriptParser::AnimatePropertyContext::EASING() {
  return getToken(CHTLJavaScriptParser::EASING, 0);
}

tree::TerminalNode* CHTLJavaScriptParser::AnimatePropertyContext::IDENTIFIER() {
  return getToken(CHTLJavaScriptParser::IDENTIFIER, 0);
}

tree::TerminalNode* CHTLJavaScriptParser::AnimatePropertyContext::STRING() {
  return getToken(CHTLJavaScriptParser::STRING, 0);
}

tree::TerminalNode* CHTLJavaScriptParser::AnimatePropertyContext::BEGIN_PROP() {
  return getToken(CHTLJavaScriptParser::BEGIN_PROP, 0);
}

CHTLJavaScriptParser::CssObjectContext* CHTLJavaScriptParser::AnimatePropertyContext::cssObject() {
  return getRuleContext<CHTLJavaScriptParser::CssObjectContext>(0);
}

tree::TerminalNode* CHTLJavaScriptParser::AnimatePropertyContext::END_PROP() {
  return getToken(CHTLJavaScriptParser::END_PROP, 0);
}

tree::TerminalNode* CHTLJavaScriptParser::AnimatePropertyContext::WHEN() {
  return getToken(CHTLJavaScriptParser::WHEN, 0);
}

CHTLJavaScriptParser::WhenArrayContext* CHTLJavaScriptParser::AnimatePropertyContext::whenArray() {
  return getRuleContext<CHTLJavaScriptParser::WhenArrayContext>(0);
}

tree::TerminalNode* CHTLJavaScriptParser::AnimatePropertyContext::LOOP() {
  return getToken(CHTLJavaScriptParser::LOOP, 0);
}

tree::TerminalNode* CHTLJavaScriptParser::AnimatePropertyContext::DIRECTION() {
  return getToken(CHTLJavaScriptParser::DIRECTION, 0);
}

tree::TerminalNode* CHTLJavaScriptParser::AnimatePropertyContext::DELAY() {
  return getToken(CHTLJavaScriptParser::DELAY, 0);
}

tree::TerminalNode* CHTLJavaScriptParser::AnimatePropertyContext::CALLBACK() {
  return getToken(CHTLJavaScriptParser::CALLBACK, 0);
}

CHTLJavaScriptParser::SingleExpressionContext* CHTLJavaScriptParser::AnimatePropertyContext::singleExpression() {
  return getRuleContext<CHTLJavaScriptParser::SingleExpressionContext>(0);
}


size_t CHTLJavaScriptParser::AnimatePropertyContext::getRuleIndex() const {
  return CHTLJavaScriptParser::RuleAnimateProperty;
}


std::any CHTLJavaScriptParser::AnimatePropertyContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<CHTLJavaScriptVisitor*>(visitor))
    return parserVisitor->visitAnimateProperty(this);
  else
    return visitor->visitChildren(this);
}

CHTLJavaScriptParser::AnimatePropertyContext* CHTLJavaScriptParser::animateProperty() {
  AnimatePropertyContext *_localctx = _tracker.createInstance<AnimatePropertyContext>(_ctx, getState());
  enterRule(_localctx, 26, CHTLJavaScriptParser::RuleAnimateProperty);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    setState(445);
    _errHandler->sync(this);
    switch (_input->LA(1)) {
      case CHTLJavaScriptParser::DURATION: {
        enterOuterAlt(_localctx, 1);
        setState(415);
        match(CHTLJavaScriptParser::DURATION);
        setState(416);
        match(CHTLJavaScriptParser::COLON);
        setState(417);
        match(CHTLJavaScriptParser::NUMBER);
        break;
      }

      case CHTLJavaScriptParser::EASING: {
        enterOuterAlt(_localctx, 2);
        setState(418);
        match(CHTLJavaScriptParser::EASING);
        setState(419);
        match(CHTLJavaScriptParser::COLON);
        setState(420);
        _la = _input->LA(1);
        if (!(_la == CHTLJavaScriptParser::IDENTIFIER || _la == CHTLJavaScriptParser::STRING)) {
        _errHandler->recoverInline(this);
        }
        else {
          _errHandler->reportMatch(this);
          consume();
        }
        break;
      }

      case CHTLJavaScriptParser::BEGIN_PROP: {
        enterOuterAlt(_localctx, 3);
        setState(421);
        match(CHTLJavaScriptParser::BEGIN_PROP);
        setState(422);
        match(CHTLJavaScriptParser::COLON);
        setState(423);
        cssObject();
        break;
      }

      case CHTLJavaScriptParser::END_PROP: {
        enterOuterAlt(_localctx, 4);
        setState(424);
        match(CHTLJavaScriptParser::END_PROP);
        setState(425);
        match(CHTLJavaScriptParser::COLON);
        setState(426);
        cssObject();
        break;
      }

      case CHTLJavaScriptParser::WHEN: {
        enterOuterAlt(_localctx, 5);
        setState(427);
        match(CHTLJavaScriptParser::WHEN);
        setState(428);
        match(CHTLJavaScriptParser::COLON);
        setState(429);
        whenArray();
        break;
      }

      case CHTLJavaScriptParser::LOOP: {
        enterOuterAlt(_localctx, 6);
        setState(430);
        match(CHTLJavaScriptParser::LOOP);
        setState(431);
        match(CHTLJavaScriptParser::COLON);
        setState(432);
        match(CHTLJavaScriptParser::NUMBER);
        break;
      }

      case CHTLJavaScriptParser::DIRECTION: {
        enterOuterAlt(_localctx, 7);
        setState(433);
        match(CHTLJavaScriptParser::DIRECTION);
        setState(434);
        match(CHTLJavaScriptParser::COLON);
        setState(435);
        _la = _input->LA(1);
        if (!(_la == CHTLJavaScriptParser::IDENTIFIER || _la == CHTLJavaScriptParser::STRING)) {
        _errHandler->recoverInline(this);
        }
        else {
          _errHandler->reportMatch(this);
          consume();
        }
        break;
      }

      case CHTLJavaScriptParser::DELAY: {
        enterOuterAlt(_localctx, 8);
        setState(436);
        match(CHTLJavaScriptParser::DELAY);
        setState(437);
        match(CHTLJavaScriptParser::COLON);
        setState(438);
        match(CHTLJavaScriptParser::NUMBER);
        break;
      }

      case CHTLJavaScriptParser::CALLBACK: {
        enterOuterAlt(_localctx, 9);
        setState(439);
        match(CHTLJavaScriptParser::CALLBACK);
        setState(440);
        match(CHTLJavaScriptParser::COLON);
        setState(443);
        _errHandler->sync(this);
        switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 15, _ctx)) {
        case 1: {
          setState(441);
          singleExpression(0);
          break;
        }

        case 2: {
          setState(442);
          match(CHTLJavaScriptParser::IDENTIFIER);
          break;
        }

        default:
          break;
        }
        break;
      }

    default:
      throw NoViableAltException(this);
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- CssObjectContext ------------------------------------------------------------------

CHTLJavaScriptParser::CssObjectContext::CssObjectContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* CHTLJavaScriptParser::CssObjectContext::LBRACE() {
  return getToken(CHTLJavaScriptParser::LBRACE, 0);
}

std::vector<CHTLJavaScriptParser::CssPropertyContext *> CHTLJavaScriptParser::CssObjectContext::cssProperty() {
  return getRuleContexts<CHTLJavaScriptParser::CssPropertyContext>();
}

CHTLJavaScriptParser::CssPropertyContext* CHTLJavaScriptParser::CssObjectContext::cssProperty(size_t i) {
  return getRuleContext<CHTLJavaScriptParser::CssPropertyContext>(i);
}

tree::TerminalNode* CHTLJavaScriptParser::CssObjectContext::RBRACE() {
  return getToken(CHTLJavaScriptParser::RBRACE, 0);
}

std::vector<tree::TerminalNode *> CHTLJavaScriptParser::CssObjectContext::COMMA() {
  return getTokens(CHTLJavaScriptParser::COMMA);
}

tree::TerminalNode* CHTLJavaScriptParser::CssObjectContext::COMMA(size_t i) {
  return getToken(CHTLJavaScriptParser::COMMA, i);
}


size_t CHTLJavaScriptParser::CssObjectContext::getRuleIndex() const {
  return CHTLJavaScriptParser::RuleCssObject;
}


std::any CHTLJavaScriptParser::CssObjectContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<CHTLJavaScriptVisitor*>(visitor))
    return parserVisitor->visitCssObject(this);
  else
    return visitor->visitChildren(this);
}

CHTLJavaScriptParser::CssObjectContext* CHTLJavaScriptParser::cssObject() {
  CssObjectContext *_localctx = _tracker.createInstance<CssObjectContext>(_ctx, getState());
  enterRule(_localctx, 28, CHTLJavaScriptParser::RuleCssObject);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(447);
    match(CHTLJavaScriptParser::LBRACE);
    setState(448);
    cssProperty();
    setState(453);
    _errHandler->sync(this);
    _la = _input->LA(1);
    while (_la == CHTLJavaScriptParser::COMMA) {
      setState(449);
      match(CHTLJavaScriptParser::COMMA);
      setState(450);
      cssProperty();
      setState(455);
      _errHandler->sync(this);
      _la = _input->LA(1);
    }
    setState(456);
    match(CHTLJavaScriptParser::RBRACE);
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- CssPropertyContext ------------------------------------------------------------------

CHTLJavaScriptParser::CssPropertyContext::CssPropertyContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* CHTLJavaScriptParser::CssPropertyContext::IDENTIFIER() {
  return getToken(CHTLJavaScriptParser::IDENTIFIER, 0);
}

tree::TerminalNode* CHTLJavaScriptParser::CssPropertyContext::COLON() {
  return getToken(CHTLJavaScriptParser::COLON, 0);
}

tree::TerminalNode* CHTLJavaScriptParser::CssPropertyContext::STRING() {
  return getToken(CHTLJavaScriptParser::STRING, 0);
}

tree::TerminalNode* CHTLJavaScriptParser::CssPropertyContext::NUMBER() {
  return getToken(CHTLJavaScriptParser::NUMBER, 0);
}

CHTLJavaScriptParser::SingleExpressionContext* CHTLJavaScriptParser::CssPropertyContext::singleExpression() {
  return getRuleContext<CHTLJavaScriptParser::SingleExpressionContext>(0);
}


size_t CHTLJavaScriptParser::CssPropertyContext::getRuleIndex() const {
  return CHTLJavaScriptParser::RuleCssProperty;
}


std::any CHTLJavaScriptParser::CssPropertyContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<CHTLJavaScriptVisitor*>(visitor))
    return parserVisitor->visitCssProperty(this);
  else
    return visitor->visitChildren(this);
}

CHTLJavaScriptParser::CssPropertyContext* CHTLJavaScriptParser::cssProperty() {
  CssPropertyContext *_localctx = _tracker.createInstance<CssPropertyContext>(_ctx, getState());
  enterRule(_localctx, 30, CHTLJavaScriptParser::RuleCssProperty);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(458);
    match(CHTLJavaScriptParser::IDENTIFIER);
    setState(459);
    match(CHTLJavaScriptParser::COLON);
    setState(463);
    _errHandler->sync(this);
    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 18, _ctx)) {
    case 1: {
      setState(460);
      match(CHTLJavaScriptParser::STRING);
      break;
    }

    case 2: {
      setState(461);
      match(CHTLJavaScriptParser::NUMBER);
      break;
    }

    case 3: {
      setState(462);
      singleExpression(0);
      break;
    }

    default:
      break;
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- WhenArrayContext ------------------------------------------------------------------

CHTLJavaScriptParser::WhenArrayContext::WhenArrayContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* CHTLJavaScriptParser::WhenArrayContext::LBRACKET() {
  return getToken(CHTLJavaScriptParser::LBRACKET, 0);
}

std::vector<CHTLJavaScriptParser::WhenObjectContext *> CHTLJavaScriptParser::WhenArrayContext::whenObject() {
  return getRuleContexts<CHTLJavaScriptParser::WhenObjectContext>();
}

CHTLJavaScriptParser::WhenObjectContext* CHTLJavaScriptParser::WhenArrayContext::whenObject(size_t i) {
  return getRuleContext<CHTLJavaScriptParser::WhenObjectContext>(i);
}

tree::TerminalNode* CHTLJavaScriptParser::WhenArrayContext::RBRACKET() {
  return getToken(CHTLJavaScriptParser::RBRACKET, 0);
}

std::vector<tree::TerminalNode *> CHTLJavaScriptParser::WhenArrayContext::COMMA() {
  return getTokens(CHTLJavaScriptParser::COMMA);
}

tree::TerminalNode* CHTLJavaScriptParser::WhenArrayContext::COMMA(size_t i) {
  return getToken(CHTLJavaScriptParser::COMMA, i);
}


size_t CHTLJavaScriptParser::WhenArrayContext::getRuleIndex() const {
  return CHTLJavaScriptParser::RuleWhenArray;
}


std::any CHTLJavaScriptParser::WhenArrayContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<CHTLJavaScriptVisitor*>(visitor))
    return parserVisitor->visitWhenArray(this);
  else
    return visitor->visitChildren(this);
}

CHTLJavaScriptParser::WhenArrayContext* CHTLJavaScriptParser::whenArray() {
  WhenArrayContext *_localctx = _tracker.createInstance<WhenArrayContext>(_ctx, getState());
  enterRule(_localctx, 32, CHTLJavaScriptParser::RuleWhenArray);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(465);
    match(CHTLJavaScriptParser::LBRACKET);
    setState(466);
    whenObject();
    setState(471);
    _errHandler->sync(this);
    _la = _input->LA(1);
    while (_la == CHTLJavaScriptParser::COMMA) {
      setState(467);
      match(CHTLJavaScriptParser::COMMA);
      setState(468);
      whenObject();
      setState(473);
      _errHandler->sync(this);
      _la = _input->LA(1);
    }
    setState(474);
    match(CHTLJavaScriptParser::RBRACKET);
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- WhenObjectContext ------------------------------------------------------------------

CHTLJavaScriptParser::WhenObjectContext::WhenObjectContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* CHTLJavaScriptParser::WhenObjectContext::LBRACE() {
  return getToken(CHTLJavaScriptParser::LBRACE, 0);
}

std::vector<CHTLJavaScriptParser::WhenPropertyContext *> CHTLJavaScriptParser::WhenObjectContext::whenProperty() {
  return getRuleContexts<CHTLJavaScriptParser::WhenPropertyContext>();
}

CHTLJavaScriptParser::WhenPropertyContext* CHTLJavaScriptParser::WhenObjectContext::whenProperty(size_t i) {
  return getRuleContext<CHTLJavaScriptParser::WhenPropertyContext>(i);
}

tree::TerminalNode* CHTLJavaScriptParser::WhenObjectContext::RBRACE() {
  return getToken(CHTLJavaScriptParser::RBRACE, 0);
}

std::vector<tree::TerminalNode *> CHTLJavaScriptParser::WhenObjectContext::COMMA() {
  return getTokens(CHTLJavaScriptParser::COMMA);
}

tree::TerminalNode* CHTLJavaScriptParser::WhenObjectContext::COMMA(size_t i) {
  return getToken(CHTLJavaScriptParser::COMMA, i);
}


size_t CHTLJavaScriptParser::WhenObjectContext::getRuleIndex() const {
  return CHTLJavaScriptParser::RuleWhenObject;
}


std::any CHTLJavaScriptParser::WhenObjectContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<CHTLJavaScriptVisitor*>(visitor))
    return parserVisitor->visitWhenObject(this);
  else
    return visitor->visitChildren(this);
}

CHTLJavaScriptParser::WhenObjectContext* CHTLJavaScriptParser::whenObject() {
  WhenObjectContext *_localctx = _tracker.createInstance<WhenObjectContext>(_ctx, getState());
  enterRule(_localctx, 34, CHTLJavaScriptParser::RuleWhenObject);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(476);
    match(CHTLJavaScriptParser::LBRACE);
    setState(477);
    whenProperty();
    setState(482);
    _errHandler->sync(this);
    _la = _input->LA(1);
    while (_la == CHTLJavaScriptParser::COMMA) {
      setState(478);
      match(CHTLJavaScriptParser::COMMA);
      setState(479);
      whenProperty();
      setState(484);
      _errHandler->sync(this);
      _la = _input->LA(1);
    }
    setState(485);
    match(CHTLJavaScriptParser::RBRACE);
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- WhenPropertyContext ------------------------------------------------------------------

CHTLJavaScriptParser::WhenPropertyContext::WhenPropertyContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* CHTLJavaScriptParser::WhenPropertyContext::AT() {
  return getToken(CHTLJavaScriptParser::AT, 0);
}

tree::TerminalNode* CHTLJavaScriptParser::WhenPropertyContext::COLON() {
  return getToken(CHTLJavaScriptParser::COLON, 0);
}

tree::TerminalNode* CHTLJavaScriptParser::WhenPropertyContext::NUMBER() {
  return getToken(CHTLJavaScriptParser::NUMBER, 0);
}

tree::TerminalNode* CHTLJavaScriptParser::WhenPropertyContext::IDENTIFIER() {
  return getToken(CHTLJavaScriptParser::IDENTIFIER, 0);
}

tree::TerminalNode* CHTLJavaScriptParser::WhenPropertyContext::STRING() {
  return getToken(CHTLJavaScriptParser::STRING, 0);
}

CHTLJavaScriptParser::SingleExpressionContext* CHTLJavaScriptParser::WhenPropertyContext::singleExpression() {
  return getRuleContext<CHTLJavaScriptParser::SingleExpressionContext>(0);
}


size_t CHTLJavaScriptParser::WhenPropertyContext::getRuleIndex() const {
  return CHTLJavaScriptParser::RuleWhenProperty;
}


std::any CHTLJavaScriptParser::WhenPropertyContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<CHTLJavaScriptVisitor*>(visitor))
    return parserVisitor->visitWhenProperty(this);
  else
    return visitor->visitChildren(this);
}

CHTLJavaScriptParser::WhenPropertyContext* CHTLJavaScriptParser::whenProperty() {
  WhenPropertyContext *_localctx = _tracker.createInstance<WhenPropertyContext>(_ctx, getState());
  enterRule(_localctx, 36, CHTLJavaScriptParser::RuleWhenProperty);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    setState(497);
    _errHandler->sync(this);
    switch (_input->LA(1)) {
      case CHTLJavaScriptParser::AT: {
        enterOuterAlt(_localctx, 1);
        setState(487);
        match(CHTLJavaScriptParser::AT);
        setState(488);
        match(CHTLJavaScriptParser::COLON);
        setState(489);
        match(CHTLJavaScriptParser::NUMBER);
        break;
      }

      case CHTLJavaScriptParser::IDENTIFIER: {
        enterOuterAlt(_localctx, 2);
        setState(490);
        match(CHTLJavaScriptParser::IDENTIFIER);
        setState(491);
        match(CHTLJavaScriptParser::COLON);
        setState(495);
        _errHandler->sync(this);
        switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 21, _ctx)) {
        case 1: {
          setState(492);
          match(CHTLJavaScriptParser::STRING);
          break;
        }

        case 2: {
          setState(493);
          match(CHTLJavaScriptParser::NUMBER);
          break;
        }

        case 3: {
          setState(494);
          singleExpression(0);
          break;
        }

        default:
          break;
        }
        break;
      }

    default:
      throw NoViableAltException(this);
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- LiteralContext ------------------------------------------------------------------

CHTLJavaScriptParser::LiteralContext::LiteralContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* CHTLJavaScriptParser::LiteralContext::NUMBER() {
  return getToken(CHTLJavaScriptParser::NUMBER, 0);
}

tree::TerminalNode* CHTLJavaScriptParser::LiteralContext::STRING() {
  return getToken(CHTLJavaScriptParser::STRING, 0);
}

tree::TerminalNode* CHTLJavaScriptParser::LiteralContext::BOOLEAN() {
  return getToken(CHTLJavaScriptParser::BOOLEAN, 0);
}

tree::TerminalNode* CHTLJavaScriptParser::LiteralContext::NULL_LITERAL() {
  return getToken(CHTLJavaScriptParser::NULL_LITERAL, 0);
}

tree::TerminalNode* CHTLJavaScriptParser::LiteralContext::UNDEFINED() {
  return getToken(CHTLJavaScriptParser::UNDEFINED, 0);
}

tree::TerminalNode* CHTLJavaScriptParser::LiteralContext::TEMPLATE_STRING() {
  return getToken(CHTLJavaScriptParser::TEMPLATE_STRING, 0);
}


size_t CHTLJavaScriptParser::LiteralContext::getRuleIndex() const {
  return CHTLJavaScriptParser::RuleLiteral;
}


std::any CHTLJavaScriptParser::LiteralContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<CHTLJavaScriptVisitor*>(visitor))
    return parserVisitor->visitLiteral(this);
  else
    return visitor->visitChildren(this);
}

CHTLJavaScriptParser::LiteralContext* CHTLJavaScriptParser::literal() {
  LiteralContext *_localctx = _tracker.createInstance<LiteralContext>(_ctx, getState());
  enterRule(_localctx, 38, CHTLJavaScriptParser::RuleLiteral);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(499);
    _la = _input->LA(1);
    if (!(_la == CHTLJavaScriptParser::TEMPLATE_STRING || ((((_la - 70) & ~ 0x3fULL) == 0) &&
      ((1ULL << (_la - 70)) & ((1ULL << (CHTLJavaScriptParser::NULL_LITERAL - 70))
      | (1ULL << (CHTLJavaScriptParser::BOOLEAN - 70))
      | (1ULL << (CHTLJavaScriptParser::UNDEFINED - 70))
      | (1ULL << (CHTLJavaScriptParser::NUMBER - 70))
      | (1ULL << (CHTLJavaScriptParser::STRING - 70)))) != 0))) {
    _errHandler->recoverInline(this);
    }
    else {
      _errHandler->reportMatch(this);
      consume();
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- ProgramContext ------------------------------------------------------------------

CHTLJavaScriptParser::ProgramContext::ProgramContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* CHTLJavaScriptParser::ProgramContext::EOF() {
  return getToken(CHTLJavaScriptParser::EOF, 0);
}

std::vector<CHTLJavaScriptParser::StatementContext *> CHTLJavaScriptParser::ProgramContext::statement() {
  return getRuleContexts<CHTLJavaScriptParser::StatementContext>();
}

CHTLJavaScriptParser::StatementContext* CHTLJavaScriptParser::ProgramContext::statement(size_t i) {
  return getRuleContext<CHTLJavaScriptParser::StatementContext>(i);
}


size_t CHTLJavaScriptParser::ProgramContext::getRuleIndex() const {
  return CHTLJavaScriptParser::RuleProgram;
}


std::any CHTLJavaScriptParser::ProgramContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<CHTLJavaScriptVisitor*>(visitor))
    return parserVisitor->visitProgram(this);
  else
    return visitor->visitChildren(this);
}

CHTLJavaScriptParser::ProgramContext* CHTLJavaScriptParser::program() {
  ProgramContext *_localctx = _tracker.createInstance<ProgramContext>(_ctx, getState());
  enterRule(_localctx, 40, CHTLJavaScriptParser::RuleProgram);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(504);
    _errHandler->sync(this);
    _la = _input->LA(1);
    while ((((_la & ~ 0x3fULL) == 0) &&
      ((1ULL << _la) & ((1ULL << CHTLJavaScriptParser::CHTL_SELECTOR_START)
      | (1ULL << CHTLJavaScriptParser::ANIMATE)
      | (1ULL << CHTLJavaScriptParser::TEMPLATE_STRING)
      | (1ULL << CHTLJavaScriptParser::IDENTIFIER)
      | (1ULL << CHTLJavaScriptParser::BREAK)
      | (1ULL << CHTLJavaScriptParser::DO)
      | (1ULL << CHTLJavaScriptParser::TYPEOF)
      | (1ULL << CHTLJavaScriptParser::NEW)
      | (1ULL << CHTLJavaScriptParser::VAR)
      | (1ULL << CHTLJavaScriptParser::RETURN)
      | (1ULL << CHTLJavaScriptParser::VOID)
      | (1ULL << CHTLJavaScriptParser::CONTINUE)
      | (1ULL << CHTLJavaScriptParser::FOR)
      | (1ULL << CHTLJavaScriptParser::SWITCH)
      | (1ULL << CHTLJavaScriptParser::WHILE)
      | (1ULL << CHTLJavaScriptParser::FUNCTION)
      | (1ULL << CHTLJavaScriptParser::THIS)
      | (1ULL << CHTLJavaScriptParser::WITH)
      | (1ULL << CHTLJavaScriptParser::IF)
      | (1ULL << CHTLJavaScriptParser::THROW)
      | (1ULL << CHTLJavaScriptParser::DELETE)
      | (1ULL << CHTLJavaScriptParser::TRY)
      | (1ULL << CHTLJavaScriptParser::CLASS)
      | (1ULL << CHTLJavaScriptParser::SUPER)
      | (1ULL << CHTLJavaScriptParser::CONST)
      | (1ULL << CHTLJavaScriptParser::EXPORT)
      | (1ULL << CHTLJavaScriptParser::IMPORT)
      | (1ULL << CHTLJavaScriptParser::ASYNC)
      | (1ULL << CHTLJavaScriptParser::AWAIT)
      | (1ULL << CHTLJavaScriptParser::LET))) != 0) || ((((_la - 70) & ~ 0x3fULL) == 0) &&
      ((1ULL << (_la - 70)) & ((1ULL << (CHTLJavaScriptParser::NULL_LITERAL - 70))
      | (1ULL << (CHTLJavaScriptParser::BOOLEAN - 70))
      | (1ULL << (CHTLJavaScriptParser::UNDEFINED - 70))
      | (1ULL << (CHTLJavaScriptParser::LPAREN - 70))
      | (1ULL << (CHTLJavaScriptParser::LBRACE - 70))
      | (1ULL << (CHTLJavaScriptParser::LBRACKET - 70))
      | (1ULL << (CHTLJavaScriptParser::SEMICOLON - 70))
      | (1ULL << (CHTLJavaScriptParser::PLUSPLUS - 70))
      | (1ULL << (CHTLJavaScriptParser::MINUSMINUS - 70))
      | (1ULL << (CHTLJavaScriptParser::PLUS - 70))
      | (1ULL << (CHTLJavaScriptParser::MINUS - 70))
      | (1ULL << (CHTLJavaScriptParser::TILDE - 70))
      | (1ULL << (CHTLJavaScriptParser::EXCLAMATION - 70))
      | (1ULL << (CHTLJavaScriptParser::NUMBER - 70))
      | (1ULL << (CHTLJavaScriptParser::STRING - 70)))) != 0)) {
      setState(501);
      statement();
      setState(506);
      _errHandler->sync(this);
      _la = _input->LA(1);
    }
    setState(507);
    match(CHTLJavaScriptParser::EOF);
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- StatementContext ------------------------------------------------------------------

CHTLJavaScriptParser::StatementContext::StatementContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

CHTLJavaScriptParser::BlockContext* CHTLJavaScriptParser::StatementContext::block() {
  return getRuleContext<CHTLJavaScriptParser::BlockContext>(0);
}

CHTLJavaScriptParser::VariableStatementContext* CHTLJavaScriptParser::StatementContext::variableStatement() {
  return getRuleContext<CHTLJavaScriptParser::VariableStatementContext>(0);
}

CHTLJavaScriptParser::EmptyStatementContext* CHTLJavaScriptParser::StatementContext::emptyStatement() {
  return getRuleContext<CHTLJavaScriptParser::EmptyStatementContext>(0);
}

CHTLJavaScriptParser::ExpressionStatementContext* CHTLJavaScriptParser::StatementContext::expressionStatement() {
  return getRuleContext<CHTLJavaScriptParser::ExpressionStatementContext>(0);
}

CHTLJavaScriptParser::IfStatementContext* CHTLJavaScriptParser::StatementContext::ifStatement() {
  return getRuleContext<CHTLJavaScriptParser::IfStatementContext>(0);
}

CHTLJavaScriptParser::IterationStatementContext* CHTLJavaScriptParser::StatementContext::iterationStatement() {
  return getRuleContext<CHTLJavaScriptParser::IterationStatementContext>(0);
}

CHTLJavaScriptParser::ContinueStatementContext* CHTLJavaScriptParser::StatementContext::continueStatement() {
  return getRuleContext<CHTLJavaScriptParser::ContinueStatementContext>(0);
}

CHTLJavaScriptParser::BreakStatementContext* CHTLJavaScriptParser::StatementContext::breakStatement() {
  return getRuleContext<CHTLJavaScriptParser::BreakStatementContext>(0);
}

CHTLJavaScriptParser::ReturnStatementContext* CHTLJavaScriptParser::StatementContext::returnStatement() {
  return getRuleContext<CHTLJavaScriptParser::ReturnStatementContext>(0);
}

CHTLJavaScriptParser::WithStatementContext* CHTLJavaScriptParser::StatementContext::withStatement() {
  return getRuleContext<CHTLJavaScriptParser::WithStatementContext>(0);
}

CHTLJavaScriptParser::LabelledStatementContext* CHTLJavaScriptParser::StatementContext::labelledStatement() {
  return getRuleContext<CHTLJavaScriptParser::LabelledStatementContext>(0);
}

CHTLJavaScriptParser::SwitchStatementContext* CHTLJavaScriptParser::StatementContext::switchStatement() {
  return getRuleContext<CHTLJavaScriptParser::SwitchStatementContext>(0);
}

CHTLJavaScriptParser::ThrowStatementContext* CHTLJavaScriptParser::StatementContext::throwStatement() {
  return getRuleContext<CHTLJavaScriptParser::ThrowStatementContext>(0);
}

CHTLJavaScriptParser::TryStatementContext* CHTLJavaScriptParser::StatementContext::tryStatement() {
  return getRuleContext<CHTLJavaScriptParser::TryStatementContext>(0);
}

CHTLJavaScriptParser::FunctionDeclarationContext* CHTLJavaScriptParser::StatementContext::functionDeclaration() {
  return getRuleContext<CHTLJavaScriptParser::FunctionDeclarationContext>(0);
}

CHTLJavaScriptParser::ClassDeclarationContext* CHTLJavaScriptParser::StatementContext::classDeclaration() {
  return getRuleContext<CHTLJavaScriptParser::ClassDeclarationContext>(0);
}

CHTLJavaScriptParser::ImportStatementContext* CHTLJavaScriptParser::StatementContext::importStatement() {
  return getRuleContext<CHTLJavaScriptParser::ImportStatementContext>(0);
}

CHTLJavaScriptParser::ExportStatementContext* CHTLJavaScriptParser::StatementContext::exportStatement() {
  return getRuleContext<CHTLJavaScriptParser::ExportStatementContext>(0);
}


size_t CHTLJavaScriptParser::StatementContext::getRuleIndex() const {
  return CHTLJavaScriptParser::RuleStatement;
}


std::any CHTLJavaScriptParser::StatementContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<CHTLJavaScriptVisitor*>(visitor))
    return parserVisitor->visitStatement(this);
  else
    return visitor->visitChildren(this);
}

CHTLJavaScriptParser::StatementContext* CHTLJavaScriptParser::statement() {
  StatementContext *_localctx = _tracker.createInstance<StatementContext>(_ctx, getState());
  enterRule(_localctx, 42, CHTLJavaScriptParser::RuleStatement);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    setState(527);
    _errHandler->sync(this);
    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 24, _ctx)) {
    case 1: {
      enterOuterAlt(_localctx, 1);
      setState(509);
      block();
      break;
    }

    case 2: {
      enterOuterAlt(_localctx, 2);
      setState(510);
      variableStatement();
      break;
    }

    case 3: {
      enterOuterAlt(_localctx, 3);
      setState(511);
      emptyStatement();
      break;
    }

    case 4: {
      enterOuterAlt(_localctx, 4);
      setState(512);
      expressionStatement();
      break;
    }

    case 5: {
      enterOuterAlt(_localctx, 5);
      setState(513);
      ifStatement();
      break;
    }

    case 6: {
      enterOuterAlt(_localctx, 6);
      setState(514);
      iterationStatement();
      break;
    }

    case 7: {
      enterOuterAlt(_localctx, 7);
      setState(515);
      continueStatement();
      break;
    }

    case 8: {
      enterOuterAlt(_localctx, 8);
      setState(516);
      breakStatement();
      break;
    }

    case 9: {
      enterOuterAlt(_localctx, 9);
      setState(517);
      returnStatement();
      break;
    }

    case 10: {
      enterOuterAlt(_localctx, 10);
      setState(518);
      withStatement();
      break;
    }

    case 11: {
      enterOuterAlt(_localctx, 11);
      setState(519);
      labelledStatement();
      break;
    }

    case 12: {
      enterOuterAlt(_localctx, 12);
      setState(520);
      switchStatement();
      break;
    }

    case 13: {
      enterOuterAlt(_localctx, 13);
      setState(521);
      throwStatement();
      break;
    }

    case 14: {
      enterOuterAlt(_localctx, 14);
      setState(522);
      tryStatement();
      break;
    }

    case 15: {
      enterOuterAlt(_localctx, 15);
      setState(523);
      functionDeclaration();
      break;
    }

    case 16: {
      enterOuterAlt(_localctx, 16);
      setState(524);
      classDeclaration();
      break;
    }

    case 17: {
      enterOuterAlt(_localctx, 17);
      setState(525);
      importStatement();
      break;
    }

    case 18: {
      enterOuterAlt(_localctx, 18);
      setState(526);
      exportStatement();
      break;
    }

    default:
      break;
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- BlockContext ------------------------------------------------------------------

CHTLJavaScriptParser::BlockContext::BlockContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* CHTLJavaScriptParser::BlockContext::LBRACE() {
  return getToken(CHTLJavaScriptParser::LBRACE, 0);
}

tree::TerminalNode* CHTLJavaScriptParser::BlockContext::RBRACE() {
  return getToken(CHTLJavaScriptParser::RBRACE, 0);
}

std::vector<CHTLJavaScriptParser::StatementContext *> CHTLJavaScriptParser::BlockContext::statement() {
  return getRuleContexts<CHTLJavaScriptParser::StatementContext>();
}

CHTLJavaScriptParser::StatementContext* CHTLJavaScriptParser::BlockContext::statement(size_t i) {
  return getRuleContext<CHTLJavaScriptParser::StatementContext>(i);
}


size_t CHTLJavaScriptParser::BlockContext::getRuleIndex() const {
  return CHTLJavaScriptParser::RuleBlock;
}


std::any CHTLJavaScriptParser::BlockContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<CHTLJavaScriptVisitor*>(visitor))
    return parserVisitor->visitBlock(this);
  else
    return visitor->visitChildren(this);
}

CHTLJavaScriptParser::BlockContext* CHTLJavaScriptParser::block() {
  BlockContext *_localctx = _tracker.createInstance<BlockContext>(_ctx, getState());
  enterRule(_localctx, 44, CHTLJavaScriptParser::RuleBlock);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(529);
    match(CHTLJavaScriptParser::LBRACE);
    setState(533);
    _errHandler->sync(this);
    _la = _input->LA(1);
    while ((((_la & ~ 0x3fULL) == 0) &&
      ((1ULL << _la) & ((1ULL << CHTLJavaScriptParser::CHTL_SELECTOR_START)
      | (1ULL << CHTLJavaScriptParser::ANIMATE)
      | (1ULL << CHTLJavaScriptParser::TEMPLATE_STRING)
      | (1ULL << CHTLJavaScriptParser::IDENTIFIER)
      | (1ULL << CHTLJavaScriptParser::BREAK)
      | (1ULL << CHTLJavaScriptParser::DO)
      | (1ULL << CHTLJavaScriptParser::TYPEOF)
      | (1ULL << CHTLJavaScriptParser::NEW)
      | (1ULL << CHTLJavaScriptParser::VAR)
      | (1ULL << CHTLJavaScriptParser::RETURN)
      | (1ULL << CHTLJavaScriptParser::VOID)
      | (1ULL << CHTLJavaScriptParser::CONTINUE)
      | (1ULL << CHTLJavaScriptParser::FOR)
      | (1ULL << CHTLJavaScriptParser::SWITCH)
      | (1ULL << CHTLJavaScriptParser::WHILE)
      | (1ULL << CHTLJavaScriptParser::FUNCTION)
      | (1ULL << CHTLJavaScriptParser::THIS)
      | (1ULL << CHTLJavaScriptParser::WITH)
      | (1ULL << CHTLJavaScriptParser::IF)
      | (1ULL << CHTLJavaScriptParser::THROW)
      | (1ULL << CHTLJavaScriptParser::DELETE)
      | (1ULL << CHTLJavaScriptParser::TRY)
      | (1ULL << CHTLJavaScriptParser::CLASS)
      | (1ULL << CHTLJavaScriptParser::SUPER)
      | (1ULL << CHTLJavaScriptParser::CONST)
      | (1ULL << CHTLJavaScriptParser::EXPORT)
      | (1ULL << CHTLJavaScriptParser::IMPORT)
      | (1ULL << CHTLJavaScriptParser::ASYNC)
      | (1ULL << CHTLJavaScriptParser::AWAIT)
      | (1ULL << CHTLJavaScriptParser::LET))) != 0) || ((((_la - 70) & ~ 0x3fULL) == 0) &&
      ((1ULL << (_la - 70)) & ((1ULL << (CHTLJavaScriptParser::NULL_LITERAL - 70))
      | (1ULL << (CHTLJavaScriptParser::BOOLEAN - 70))
      | (1ULL << (CHTLJavaScriptParser::UNDEFINED - 70))
      | (1ULL << (CHTLJavaScriptParser::LPAREN - 70))
      | (1ULL << (CHTLJavaScriptParser::LBRACE - 70))
      | (1ULL << (CHTLJavaScriptParser::LBRACKET - 70))
      | (1ULL << (CHTLJavaScriptParser::SEMICOLON - 70))
      | (1ULL << (CHTLJavaScriptParser::PLUSPLUS - 70))
      | (1ULL << (CHTLJavaScriptParser::MINUSMINUS - 70))
      | (1ULL << (CHTLJavaScriptParser::PLUS - 70))
      | (1ULL << (CHTLJavaScriptParser::MINUS - 70))
      | (1ULL << (CHTLJavaScriptParser::TILDE - 70))
      | (1ULL << (CHTLJavaScriptParser::EXCLAMATION - 70))
      | (1ULL << (CHTLJavaScriptParser::NUMBER - 70))
      | (1ULL << (CHTLJavaScriptParser::STRING - 70)))) != 0)) {
      setState(530);
      statement();
      setState(535);
      _errHandler->sync(this);
      _la = _input->LA(1);
    }
    setState(536);
    match(CHTLJavaScriptParser::RBRACE);
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- VariableStatementContext ------------------------------------------------------------------

CHTLJavaScriptParser::VariableStatementContext::VariableStatementContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

CHTLJavaScriptParser::VariableDeclarationListContext* CHTLJavaScriptParser::VariableStatementContext::variableDeclarationList() {
  return getRuleContext<CHTLJavaScriptParser::VariableDeclarationListContext>(0);
}

tree::TerminalNode* CHTLJavaScriptParser::VariableStatementContext::SEMICOLON() {
  return getToken(CHTLJavaScriptParser::SEMICOLON, 0);
}


size_t CHTLJavaScriptParser::VariableStatementContext::getRuleIndex() const {
  return CHTLJavaScriptParser::RuleVariableStatement;
}


std::any CHTLJavaScriptParser::VariableStatementContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<CHTLJavaScriptVisitor*>(visitor))
    return parserVisitor->visitVariableStatement(this);
  else
    return visitor->visitChildren(this);
}

CHTLJavaScriptParser::VariableStatementContext* CHTLJavaScriptParser::variableStatement() {
  VariableStatementContext *_localctx = _tracker.createInstance<VariableStatementContext>(_ctx, getState());
  enterRule(_localctx, 46, CHTLJavaScriptParser::RuleVariableStatement);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(538);
    variableDeclarationList();
    setState(539);
    match(CHTLJavaScriptParser::SEMICOLON);
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- VariableDeclarationListContext ------------------------------------------------------------------

CHTLJavaScriptParser::VariableDeclarationListContext::VariableDeclarationListContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

CHTLJavaScriptParser::VarModifierContext* CHTLJavaScriptParser::VariableDeclarationListContext::varModifier() {
  return getRuleContext<CHTLJavaScriptParser::VarModifierContext>(0);
}

std::vector<CHTLJavaScriptParser::VariableDeclarationContext *> CHTLJavaScriptParser::VariableDeclarationListContext::variableDeclaration() {
  return getRuleContexts<CHTLJavaScriptParser::VariableDeclarationContext>();
}

CHTLJavaScriptParser::VariableDeclarationContext* CHTLJavaScriptParser::VariableDeclarationListContext::variableDeclaration(size_t i) {
  return getRuleContext<CHTLJavaScriptParser::VariableDeclarationContext>(i);
}

std::vector<tree::TerminalNode *> CHTLJavaScriptParser::VariableDeclarationListContext::COMMA() {
  return getTokens(CHTLJavaScriptParser::COMMA);
}

tree::TerminalNode* CHTLJavaScriptParser::VariableDeclarationListContext::COMMA(size_t i) {
  return getToken(CHTLJavaScriptParser::COMMA, i);
}


size_t CHTLJavaScriptParser::VariableDeclarationListContext::getRuleIndex() const {
  return CHTLJavaScriptParser::RuleVariableDeclarationList;
}


std::any CHTLJavaScriptParser::VariableDeclarationListContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<CHTLJavaScriptVisitor*>(visitor))
    return parserVisitor->visitVariableDeclarationList(this);
  else
    return visitor->visitChildren(this);
}

CHTLJavaScriptParser::VariableDeclarationListContext* CHTLJavaScriptParser::variableDeclarationList() {
  VariableDeclarationListContext *_localctx = _tracker.createInstance<VariableDeclarationListContext>(_ctx, getState());
  enterRule(_localctx, 48, CHTLJavaScriptParser::RuleVariableDeclarationList);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(541);
    varModifier();
    setState(542);
    variableDeclaration();
    setState(547);
    _errHandler->sync(this);
    _la = _input->LA(1);
    while (_la == CHTLJavaScriptParser::COMMA) {
      setState(543);
      match(CHTLJavaScriptParser::COMMA);
      setState(544);
      variableDeclaration();
      setState(549);
      _errHandler->sync(this);
      _la = _input->LA(1);
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- VarModifierContext ------------------------------------------------------------------

CHTLJavaScriptParser::VarModifierContext::VarModifierContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* CHTLJavaScriptParser::VarModifierContext::VAR() {
  return getToken(CHTLJavaScriptParser::VAR, 0);
}

tree::TerminalNode* CHTLJavaScriptParser::VarModifierContext::LET() {
  return getToken(CHTLJavaScriptParser::LET, 0);
}

tree::TerminalNode* CHTLJavaScriptParser::VarModifierContext::CONST() {
  return getToken(CHTLJavaScriptParser::CONST, 0);
}


size_t CHTLJavaScriptParser::VarModifierContext::getRuleIndex() const {
  return CHTLJavaScriptParser::RuleVarModifier;
}


std::any CHTLJavaScriptParser::VarModifierContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<CHTLJavaScriptVisitor*>(visitor))
    return parserVisitor->visitVarModifier(this);
  else
    return visitor->visitChildren(this);
}

CHTLJavaScriptParser::VarModifierContext* CHTLJavaScriptParser::varModifier() {
  VarModifierContext *_localctx = _tracker.createInstance<VarModifierContext>(_ctx, getState());
  enterRule(_localctx, 50, CHTLJavaScriptParser::RuleVarModifier);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(550);
    _la = _input->LA(1);
    if (!((((_la & ~ 0x3fULL) == 0) &&
      ((1ULL << _la) & ((1ULL << CHTLJavaScriptParser::VAR)
      | (1ULL << CHTLJavaScriptParser::CONST)
      | (1ULL << CHTLJavaScriptParser::LET))) != 0))) {
    _errHandler->recoverInline(this);
    }
    else {
      _errHandler->reportMatch(this);
      consume();
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- VariableDeclarationContext ------------------------------------------------------------------

CHTLJavaScriptParser::VariableDeclarationContext::VariableDeclarationContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

CHTLJavaScriptParser::AssignableContext* CHTLJavaScriptParser::VariableDeclarationContext::assignable() {
  return getRuleContext<CHTLJavaScriptParser::AssignableContext>(0);
}

tree::TerminalNode* CHTLJavaScriptParser::VariableDeclarationContext::EQUALS() {
  return getToken(CHTLJavaScriptParser::EQUALS, 0);
}

CHTLJavaScriptParser::SingleExpressionContext* CHTLJavaScriptParser::VariableDeclarationContext::singleExpression() {
  return getRuleContext<CHTLJavaScriptParser::SingleExpressionContext>(0);
}


size_t CHTLJavaScriptParser::VariableDeclarationContext::getRuleIndex() const {
  return CHTLJavaScriptParser::RuleVariableDeclaration;
}


std::any CHTLJavaScriptParser::VariableDeclarationContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<CHTLJavaScriptVisitor*>(visitor))
    return parserVisitor->visitVariableDeclaration(this);
  else
    return visitor->visitChildren(this);
}

CHTLJavaScriptParser::VariableDeclarationContext* CHTLJavaScriptParser::variableDeclaration() {
  VariableDeclarationContext *_localctx = _tracker.createInstance<VariableDeclarationContext>(_ctx, getState());
  enterRule(_localctx, 52, CHTLJavaScriptParser::RuleVariableDeclaration);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(552);
    assignable();
    setState(555);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (_la == CHTLJavaScriptParser::EQUALS) {
      setState(553);
      match(CHTLJavaScriptParser::EQUALS);
      setState(554);
      singleExpression(0);
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- EmptyStatementContext ------------------------------------------------------------------

CHTLJavaScriptParser::EmptyStatementContext::EmptyStatementContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* CHTLJavaScriptParser::EmptyStatementContext::SEMICOLON() {
  return getToken(CHTLJavaScriptParser::SEMICOLON, 0);
}


size_t CHTLJavaScriptParser::EmptyStatementContext::getRuleIndex() const {
  return CHTLJavaScriptParser::RuleEmptyStatement;
}


std::any CHTLJavaScriptParser::EmptyStatementContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<CHTLJavaScriptVisitor*>(visitor))
    return parserVisitor->visitEmptyStatement(this);
  else
    return visitor->visitChildren(this);
}

CHTLJavaScriptParser::EmptyStatementContext* CHTLJavaScriptParser::emptyStatement() {
  EmptyStatementContext *_localctx = _tracker.createInstance<EmptyStatementContext>(_ctx, getState());
  enterRule(_localctx, 54, CHTLJavaScriptParser::RuleEmptyStatement);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(557);
    match(CHTLJavaScriptParser::SEMICOLON);
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- ExpressionStatementContext ------------------------------------------------------------------

CHTLJavaScriptParser::ExpressionStatementContext::ExpressionStatementContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

CHTLJavaScriptParser::ExpressionSequenceContext* CHTLJavaScriptParser::ExpressionStatementContext::expressionSequence() {
  return getRuleContext<CHTLJavaScriptParser::ExpressionSequenceContext>(0);
}

tree::TerminalNode* CHTLJavaScriptParser::ExpressionStatementContext::SEMICOLON() {
  return getToken(CHTLJavaScriptParser::SEMICOLON, 0);
}


size_t CHTLJavaScriptParser::ExpressionStatementContext::getRuleIndex() const {
  return CHTLJavaScriptParser::RuleExpressionStatement;
}


std::any CHTLJavaScriptParser::ExpressionStatementContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<CHTLJavaScriptVisitor*>(visitor))
    return parserVisitor->visitExpressionStatement(this);
  else
    return visitor->visitChildren(this);
}

CHTLJavaScriptParser::ExpressionStatementContext* CHTLJavaScriptParser::expressionStatement() {
  ExpressionStatementContext *_localctx = _tracker.createInstance<ExpressionStatementContext>(_ctx, getState());
  enterRule(_localctx, 56, CHTLJavaScriptParser::RuleExpressionStatement);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(559);
    expressionSequence();
    setState(560);
    match(CHTLJavaScriptParser::SEMICOLON);
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- IfStatementContext ------------------------------------------------------------------

CHTLJavaScriptParser::IfStatementContext::IfStatementContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* CHTLJavaScriptParser::IfStatementContext::IF() {
  return getToken(CHTLJavaScriptParser::IF, 0);
}

tree::TerminalNode* CHTLJavaScriptParser::IfStatementContext::LPAREN() {
  return getToken(CHTLJavaScriptParser::LPAREN, 0);
}

CHTLJavaScriptParser::ExpressionSequenceContext* CHTLJavaScriptParser::IfStatementContext::expressionSequence() {
  return getRuleContext<CHTLJavaScriptParser::ExpressionSequenceContext>(0);
}

tree::TerminalNode* CHTLJavaScriptParser::IfStatementContext::RPAREN() {
  return getToken(CHTLJavaScriptParser::RPAREN, 0);
}

std::vector<CHTLJavaScriptParser::StatementContext *> CHTLJavaScriptParser::IfStatementContext::statement() {
  return getRuleContexts<CHTLJavaScriptParser::StatementContext>();
}

CHTLJavaScriptParser::StatementContext* CHTLJavaScriptParser::IfStatementContext::statement(size_t i) {
  return getRuleContext<CHTLJavaScriptParser::StatementContext>(i);
}

tree::TerminalNode* CHTLJavaScriptParser::IfStatementContext::ELSE() {
  return getToken(CHTLJavaScriptParser::ELSE, 0);
}


size_t CHTLJavaScriptParser::IfStatementContext::getRuleIndex() const {
  return CHTLJavaScriptParser::RuleIfStatement;
}


std::any CHTLJavaScriptParser::IfStatementContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<CHTLJavaScriptVisitor*>(visitor))
    return parserVisitor->visitIfStatement(this);
  else
    return visitor->visitChildren(this);
}

CHTLJavaScriptParser::IfStatementContext* CHTLJavaScriptParser::ifStatement() {
  IfStatementContext *_localctx = _tracker.createInstance<IfStatementContext>(_ctx, getState());
  enterRule(_localctx, 58, CHTLJavaScriptParser::RuleIfStatement);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(562);
    match(CHTLJavaScriptParser::IF);
    setState(563);
    match(CHTLJavaScriptParser::LPAREN);
    setState(564);
    expressionSequence();
    setState(565);
    match(CHTLJavaScriptParser::RPAREN);
    setState(566);
    statement();
    setState(569);
    _errHandler->sync(this);

    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 28, _ctx)) {
    case 1: {
      setState(567);
      match(CHTLJavaScriptParser::ELSE);
      setState(568);
      statement();
      break;
    }

    default:
      break;
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- IterationStatementContext ------------------------------------------------------------------

CHTLJavaScriptParser::IterationStatementContext::IterationStatementContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* CHTLJavaScriptParser::IterationStatementContext::DO() {
  return getToken(CHTLJavaScriptParser::DO, 0);
}

CHTLJavaScriptParser::StatementContext* CHTLJavaScriptParser::IterationStatementContext::statement() {
  return getRuleContext<CHTLJavaScriptParser::StatementContext>(0);
}

tree::TerminalNode* CHTLJavaScriptParser::IterationStatementContext::WHILE() {
  return getToken(CHTLJavaScriptParser::WHILE, 0);
}

tree::TerminalNode* CHTLJavaScriptParser::IterationStatementContext::LPAREN() {
  return getToken(CHTLJavaScriptParser::LPAREN, 0);
}

std::vector<CHTLJavaScriptParser::ExpressionSequenceContext *> CHTLJavaScriptParser::IterationStatementContext::expressionSequence() {
  return getRuleContexts<CHTLJavaScriptParser::ExpressionSequenceContext>();
}

CHTLJavaScriptParser::ExpressionSequenceContext* CHTLJavaScriptParser::IterationStatementContext::expressionSequence(size_t i) {
  return getRuleContext<CHTLJavaScriptParser::ExpressionSequenceContext>(i);
}

tree::TerminalNode* CHTLJavaScriptParser::IterationStatementContext::RPAREN() {
  return getToken(CHTLJavaScriptParser::RPAREN, 0);
}

std::vector<tree::TerminalNode *> CHTLJavaScriptParser::IterationStatementContext::SEMICOLON() {
  return getTokens(CHTLJavaScriptParser::SEMICOLON);
}

tree::TerminalNode* CHTLJavaScriptParser::IterationStatementContext::SEMICOLON(size_t i) {
  return getToken(CHTLJavaScriptParser::SEMICOLON, i);
}

tree::TerminalNode* CHTLJavaScriptParser::IterationStatementContext::FOR() {
  return getToken(CHTLJavaScriptParser::FOR, 0);
}

CHTLJavaScriptParser::VariableDeclarationListContext* CHTLJavaScriptParser::IterationStatementContext::variableDeclarationList() {
  return getRuleContext<CHTLJavaScriptParser::VariableDeclarationListContext>(0);
}

tree::TerminalNode* CHTLJavaScriptParser::IterationStatementContext::IN() {
  return getToken(CHTLJavaScriptParser::IN, 0);
}

CHTLJavaScriptParser::SingleExpressionContext* CHTLJavaScriptParser::IterationStatementContext::singleExpression() {
  return getRuleContext<CHTLJavaScriptParser::SingleExpressionContext>(0);
}

tree::TerminalNode* CHTLJavaScriptParser::IterationStatementContext::OF() {
  return getToken(CHTLJavaScriptParser::OF, 0);
}

tree::TerminalNode* CHTLJavaScriptParser::IterationStatementContext::AWAIT() {
  return getToken(CHTLJavaScriptParser::AWAIT, 0);
}


size_t CHTLJavaScriptParser::IterationStatementContext::getRuleIndex() const {
  return CHTLJavaScriptParser::RuleIterationStatement;
}


std::any CHTLJavaScriptParser::IterationStatementContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<CHTLJavaScriptVisitor*>(visitor))
    return parserVisitor->visitIterationStatement(this);
  else
    return visitor->visitChildren(this);
}

CHTLJavaScriptParser::IterationStatementContext* CHTLJavaScriptParser::iterationStatement() {
  IterationStatementContext *_localctx = _tracker.createInstance<IterationStatementContext>(_ctx, getState());
  enterRule(_localctx, 60, CHTLJavaScriptParser::RuleIterationStatement);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    setState(635);
    _errHandler->sync(this);
    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 35, _ctx)) {
    case 1: {
      enterOuterAlt(_localctx, 1);
      setState(571);
      match(CHTLJavaScriptParser::DO);
      setState(572);
      statement();
      setState(573);
      match(CHTLJavaScriptParser::WHILE);
      setState(574);
      match(CHTLJavaScriptParser::LPAREN);
      setState(575);
      expressionSequence();
      setState(576);
      match(CHTLJavaScriptParser::RPAREN);
      setState(577);
      match(CHTLJavaScriptParser::SEMICOLON);
      break;
    }

    case 2: {
      enterOuterAlt(_localctx, 2);
      setState(579);
      match(CHTLJavaScriptParser::WHILE);
      setState(580);
      match(CHTLJavaScriptParser::LPAREN);
      setState(581);
      expressionSequence();
      setState(582);
      match(CHTLJavaScriptParser::RPAREN);
      setState(583);
      statement();
      break;
    }

    case 3: {
      enterOuterAlt(_localctx, 3);
      setState(585);
      match(CHTLJavaScriptParser::FOR);
      setState(586);
      match(CHTLJavaScriptParser::LPAREN);
      setState(589);
      _errHandler->sync(this);
      switch (_input->LA(1)) {
        case CHTLJavaScriptParser::CHTL_SELECTOR_START:
        case CHTLJavaScriptParser::ANIMATE:
        case CHTLJavaScriptParser::TEMPLATE_STRING:
        case CHTLJavaScriptParser::IDENTIFIER:
        case CHTLJavaScriptParser::TYPEOF:
        case CHTLJavaScriptParser::NEW:
        case CHTLJavaScriptParser::VOID:
        case CHTLJavaScriptParser::FUNCTION:
        case CHTLJavaScriptParser::THIS:
        case CHTLJavaScriptParser::DELETE:
        case CHTLJavaScriptParser::SUPER:
        case CHTLJavaScriptParser::ASYNC:
        case CHTLJavaScriptParser::AWAIT:
        case CHTLJavaScriptParser::NULL_LITERAL:
        case CHTLJavaScriptParser::BOOLEAN:
        case CHTLJavaScriptParser::UNDEFINED:
        case CHTLJavaScriptParser::LPAREN:
        case CHTLJavaScriptParser::LBRACE:
        case CHTLJavaScriptParser::LBRACKET:
        case CHTLJavaScriptParser::PLUSPLUS:
        case CHTLJavaScriptParser::MINUSMINUS:
        case CHTLJavaScriptParser::PLUS:
        case CHTLJavaScriptParser::MINUS:
        case CHTLJavaScriptParser::TILDE:
        case CHTLJavaScriptParser::EXCLAMATION:
        case CHTLJavaScriptParser::NUMBER:
        case CHTLJavaScriptParser::STRING: {
          setState(587);
          expressionSequence();
          break;
        }

        case CHTLJavaScriptParser::VAR:
        case CHTLJavaScriptParser::CONST:
        case CHTLJavaScriptParser::LET: {
          setState(588);
          variableDeclarationList();
          break;
        }

        case CHTLJavaScriptParser::SEMICOLON: {
          break;
        }

      default:
        break;
      }
      setState(591);
      match(CHTLJavaScriptParser::SEMICOLON);
      setState(593);
      _errHandler->sync(this);

      _la = _input->LA(1);
      if ((((_la & ~ 0x3fULL) == 0) &&
        ((1ULL << _la) & ((1ULL << CHTLJavaScriptParser::CHTL_SELECTOR_START)
        | (1ULL << CHTLJavaScriptParser::ANIMATE)
        | (1ULL << CHTLJavaScriptParser::TEMPLATE_STRING)
        | (1ULL << CHTLJavaScriptParser::IDENTIFIER)
        | (1ULL << CHTLJavaScriptParser::TYPEOF)
        | (1ULL << CHTLJavaScriptParser::NEW)
        | (1ULL << CHTLJavaScriptParser::VOID)
        | (1ULL << CHTLJavaScriptParser::FUNCTION)
        | (1ULL << CHTLJavaScriptParser::THIS)
        | (1ULL << CHTLJavaScriptParser::DELETE)
        | (1ULL << CHTLJavaScriptParser::SUPER)
        | (1ULL << CHTLJavaScriptParser::ASYNC)
        | (1ULL << CHTLJavaScriptParser::AWAIT))) != 0) || ((((_la - 70) & ~ 0x3fULL) == 0) &&
        ((1ULL << (_la - 70)) & ((1ULL << (CHTLJavaScriptParser::NULL_LITERAL - 70))
        | (1ULL << (CHTLJavaScriptParser::BOOLEAN - 70))
        | (1ULL << (CHTLJavaScriptParser::UNDEFINED - 70))
        | (1ULL << (CHTLJavaScriptParser::LPAREN - 70))
        | (1ULL << (CHTLJavaScriptParser::LBRACE - 70))
        | (1ULL << (CHTLJavaScriptParser::LBRACKET - 70))
        | (1ULL << (CHTLJavaScriptParser::PLUSPLUS - 70))
        | (1ULL << (CHTLJavaScriptParser::MINUSMINUS - 70))
        | (1ULL << (CHTLJavaScriptParser::PLUS - 70))
        | (1ULL << (CHTLJavaScriptParser::MINUS - 70))
        | (1ULL << (CHTLJavaScriptParser::TILDE - 70))
        | (1ULL << (CHTLJavaScriptParser::EXCLAMATION - 70))
        | (1ULL << (CHTLJavaScriptParser::NUMBER - 70))
        | (1ULL << (CHTLJavaScriptParser::STRING - 70)))) != 0)) {
        setState(592);
        expressionSequence();
      }
      setState(595);
      match(CHTLJavaScriptParser::SEMICOLON);
      setState(597);
      _errHandler->sync(this);

      _la = _input->LA(1);
      if ((((_la & ~ 0x3fULL) == 0) &&
        ((1ULL << _la) & ((1ULL << CHTLJavaScriptParser::CHTL_SELECTOR_START)
        | (1ULL << CHTLJavaScriptParser::ANIMATE)
        | (1ULL << CHTLJavaScriptParser::TEMPLATE_STRING)
        | (1ULL << CHTLJavaScriptParser::IDENTIFIER)
        | (1ULL << CHTLJavaScriptParser::TYPEOF)
        | (1ULL << CHTLJavaScriptParser::NEW)
        | (1ULL << CHTLJavaScriptParser::VOID)
        | (1ULL << CHTLJavaScriptParser::FUNCTION)
        | (1ULL << CHTLJavaScriptParser::THIS)
        | (1ULL << CHTLJavaScriptParser::DELETE)
        | (1ULL << CHTLJavaScriptParser::SUPER)
        | (1ULL << CHTLJavaScriptParser::ASYNC)
        | (1ULL << CHTLJavaScriptParser::AWAIT))) != 0) || ((((_la - 70) & ~ 0x3fULL) == 0) &&
        ((1ULL << (_la - 70)) & ((1ULL << (CHTLJavaScriptParser::NULL_LITERAL - 70))
        | (1ULL << (CHTLJavaScriptParser::BOOLEAN - 70))
        | (1ULL << (CHTLJavaScriptParser::UNDEFINED - 70))
        | (1ULL << (CHTLJavaScriptParser::LPAREN - 70))
        | (1ULL << (CHTLJavaScriptParser::LBRACE - 70))
        | (1ULL << (CHTLJavaScriptParser::LBRACKET - 70))
        | (1ULL << (CHTLJavaScriptParser::PLUSPLUS - 70))
        | (1ULL << (CHTLJavaScriptParser::MINUSMINUS - 70))
        | (1ULL << (CHTLJavaScriptParser::PLUS - 70))
        | (1ULL << (CHTLJavaScriptParser::MINUS - 70))
        | (1ULL << (CHTLJavaScriptParser::TILDE - 70))
        | (1ULL << (CHTLJavaScriptParser::EXCLAMATION - 70))
        | (1ULL << (CHTLJavaScriptParser::NUMBER - 70))
        | (1ULL << (CHTLJavaScriptParser::STRING - 70)))) != 0)) {
        setState(596);
        expressionSequence();
      }
      setState(599);
      match(CHTLJavaScriptParser::RPAREN);
      setState(600);
      statement();
      break;
    }

    case 4: {
      enterOuterAlt(_localctx, 4);
      setState(601);
      match(CHTLJavaScriptParser::FOR);
      setState(602);
      match(CHTLJavaScriptParser::LPAREN);
      setState(605);
      _errHandler->sync(this);
      switch (_input->LA(1)) {
        case CHTLJavaScriptParser::CHTL_SELECTOR_START:
        case CHTLJavaScriptParser::ANIMATE:
        case CHTLJavaScriptParser::TEMPLATE_STRING:
        case CHTLJavaScriptParser::IDENTIFIER:
        case CHTLJavaScriptParser::TYPEOF:
        case CHTLJavaScriptParser::NEW:
        case CHTLJavaScriptParser::VOID:
        case CHTLJavaScriptParser::FUNCTION:
        case CHTLJavaScriptParser::THIS:
        case CHTLJavaScriptParser::DELETE:
        case CHTLJavaScriptParser::SUPER:
        case CHTLJavaScriptParser::ASYNC:
        case CHTLJavaScriptParser::AWAIT:
        case CHTLJavaScriptParser::NULL_LITERAL:
        case CHTLJavaScriptParser::BOOLEAN:
        case CHTLJavaScriptParser::UNDEFINED:
        case CHTLJavaScriptParser::LPAREN:
        case CHTLJavaScriptParser::LBRACE:
        case CHTLJavaScriptParser::LBRACKET:
        case CHTLJavaScriptParser::PLUSPLUS:
        case CHTLJavaScriptParser::MINUSMINUS:
        case CHTLJavaScriptParser::PLUS:
        case CHTLJavaScriptParser::MINUS:
        case CHTLJavaScriptParser::TILDE:
        case CHTLJavaScriptParser::EXCLAMATION:
        case CHTLJavaScriptParser::NUMBER:
        case CHTLJavaScriptParser::STRING: {
          setState(603);
          singleExpression(0);
          break;
        }

        case CHTLJavaScriptParser::VAR:
        case CHTLJavaScriptParser::CONST:
        case CHTLJavaScriptParser::LET: {
          setState(604);
          variableDeclarationList();
          break;
        }

      default:
        throw NoViableAltException(this);
      }
      setState(607);
      match(CHTLJavaScriptParser::IN);
      setState(608);
      expressionSequence();
      setState(609);
      match(CHTLJavaScriptParser::RPAREN);
      setState(610);
      statement();
      break;
    }

    case 5: {
      enterOuterAlt(_localctx, 5);
      setState(612);
      match(CHTLJavaScriptParser::FOR);
      setState(613);
      match(CHTLJavaScriptParser::LPAREN);
      setState(616);
      _errHandler->sync(this);
      switch (_input->LA(1)) {
        case CHTLJavaScriptParser::CHTL_SELECTOR_START:
        case CHTLJavaScriptParser::ANIMATE:
        case CHTLJavaScriptParser::TEMPLATE_STRING:
        case CHTLJavaScriptParser::IDENTIFIER:
        case CHTLJavaScriptParser::TYPEOF:
        case CHTLJavaScriptParser::NEW:
        case CHTLJavaScriptParser::VOID:
        case CHTLJavaScriptParser::FUNCTION:
        case CHTLJavaScriptParser::THIS:
        case CHTLJavaScriptParser::DELETE:
        case CHTLJavaScriptParser::SUPER:
        case CHTLJavaScriptParser::ASYNC:
        case CHTLJavaScriptParser::AWAIT:
        case CHTLJavaScriptParser::NULL_LITERAL:
        case CHTLJavaScriptParser::BOOLEAN:
        case CHTLJavaScriptParser::UNDEFINED:
        case CHTLJavaScriptParser::LPAREN:
        case CHTLJavaScriptParser::LBRACE:
        case CHTLJavaScriptParser::LBRACKET:
        case CHTLJavaScriptParser::PLUSPLUS:
        case CHTLJavaScriptParser::MINUSMINUS:
        case CHTLJavaScriptParser::PLUS:
        case CHTLJavaScriptParser::MINUS:
        case CHTLJavaScriptParser::TILDE:
        case CHTLJavaScriptParser::EXCLAMATION:
        case CHTLJavaScriptParser::NUMBER:
        case CHTLJavaScriptParser::STRING: {
          setState(614);
          singleExpression(0);
          break;
        }

        case CHTLJavaScriptParser::VAR:
        case CHTLJavaScriptParser::CONST:
        case CHTLJavaScriptParser::LET: {
          setState(615);
          variableDeclarationList();
          break;
        }

      default:
        throw NoViableAltException(this);
      }
      setState(618);
      match(CHTLJavaScriptParser::OF);
      setState(619);
      expressionSequence();
      setState(620);
      match(CHTLJavaScriptParser::RPAREN);
      setState(621);
      statement();
      break;
    }

    case 6: {
      enterOuterAlt(_localctx, 6);
      setState(623);
      match(CHTLJavaScriptParser::FOR);
      setState(624);
      match(CHTLJavaScriptParser::AWAIT);
      setState(625);
      match(CHTLJavaScriptParser::LPAREN);
      setState(628);
      _errHandler->sync(this);
      switch (_input->LA(1)) {
        case CHTLJavaScriptParser::CHTL_SELECTOR_START:
        case CHTLJavaScriptParser::ANIMATE:
        case CHTLJavaScriptParser::TEMPLATE_STRING:
        case CHTLJavaScriptParser::IDENTIFIER:
        case CHTLJavaScriptParser::TYPEOF:
        case CHTLJavaScriptParser::NEW:
        case CHTLJavaScriptParser::VOID:
        case CHTLJavaScriptParser::FUNCTION:
        case CHTLJavaScriptParser::THIS:
        case CHTLJavaScriptParser::DELETE:
        case CHTLJavaScriptParser::SUPER:
        case CHTLJavaScriptParser::ASYNC:
        case CHTLJavaScriptParser::AWAIT:
        case CHTLJavaScriptParser::NULL_LITERAL:
        case CHTLJavaScriptParser::BOOLEAN:
        case CHTLJavaScriptParser::UNDEFINED:
        case CHTLJavaScriptParser::LPAREN:
        case CHTLJavaScriptParser::LBRACE:
        case CHTLJavaScriptParser::LBRACKET:
        case CHTLJavaScriptParser::PLUSPLUS:
        case CHTLJavaScriptParser::MINUSMINUS:
        case CHTLJavaScriptParser::PLUS:
        case CHTLJavaScriptParser::MINUS:
        case CHTLJavaScriptParser::TILDE:
        case CHTLJavaScriptParser::EXCLAMATION:
        case CHTLJavaScriptParser::NUMBER:
        case CHTLJavaScriptParser::STRING: {
          setState(626);
          singleExpression(0);
          break;
        }

        case CHTLJavaScriptParser::VAR:
        case CHTLJavaScriptParser::CONST:
        case CHTLJavaScriptParser::LET: {
          setState(627);
          variableDeclarationList();
          break;
        }

      default:
        throw NoViableAltException(this);
      }
      setState(630);
      match(CHTLJavaScriptParser::OF);
      setState(631);
      expressionSequence();
      setState(632);
      match(CHTLJavaScriptParser::RPAREN);
      setState(633);
      statement();
      break;
    }

    default:
      break;
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- ContinueStatementContext ------------------------------------------------------------------

CHTLJavaScriptParser::ContinueStatementContext::ContinueStatementContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* CHTLJavaScriptParser::ContinueStatementContext::CONTINUE() {
  return getToken(CHTLJavaScriptParser::CONTINUE, 0);
}

tree::TerminalNode* CHTLJavaScriptParser::ContinueStatementContext::SEMICOLON() {
  return getToken(CHTLJavaScriptParser::SEMICOLON, 0);
}

tree::TerminalNode* CHTLJavaScriptParser::ContinueStatementContext::IDENTIFIER() {
  return getToken(CHTLJavaScriptParser::IDENTIFIER, 0);
}


size_t CHTLJavaScriptParser::ContinueStatementContext::getRuleIndex() const {
  return CHTLJavaScriptParser::RuleContinueStatement;
}


std::any CHTLJavaScriptParser::ContinueStatementContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<CHTLJavaScriptVisitor*>(visitor))
    return parserVisitor->visitContinueStatement(this);
  else
    return visitor->visitChildren(this);
}

CHTLJavaScriptParser::ContinueStatementContext* CHTLJavaScriptParser::continueStatement() {
  ContinueStatementContext *_localctx = _tracker.createInstance<ContinueStatementContext>(_ctx, getState());
  enterRule(_localctx, 62, CHTLJavaScriptParser::RuleContinueStatement);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(637);
    match(CHTLJavaScriptParser::CONTINUE);
    setState(639);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (_la == CHTLJavaScriptParser::IDENTIFIER) {
      setState(638);
      match(CHTLJavaScriptParser::IDENTIFIER);
    }
    setState(641);
    match(CHTLJavaScriptParser::SEMICOLON);
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- BreakStatementContext ------------------------------------------------------------------

CHTLJavaScriptParser::BreakStatementContext::BreakStatementContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* CHTLJavaScriptParser::BreakStatementContext::BREAK() {
  return getToken(CHTLJavaScriptParser::BREAK, 0);
}

tree::TerminalNode* CHTLJavaScriptParser::BreakStatementContext::SEMICOLON() {
  return getToken(CHTLJavaScriptParser::SEMICOLON, 0);
}

tree::TerminalNode* CHTLJavaScriptParser::BreakStatementContext::IDENTIFIER() {
  return getToken(CHTLJavaScriptParser::IDENTIFIER, 0);
}


size_t CHTLJavaScriptParser::BreakStatementContext::getRuleIndex() const {
  return CHTLJavaScriptParser::RuleBreakStatement;
}


std::any CHTLJavaScriptParser::BreakStatementContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<CHTLJavaScriptVisitor*>(visitor))
    return parserVisitor->visitBreakStatement(this);
  else
    return visitor->visitChildren(this);
}

CHTLJavaScriptParser::BreakStatementContext* CHTLJavaScriptParser::breakStatement() {
  BreakStatementContext *_localctx = _tracker.createInstance<BreakStatementContext>(_ctx, getState());
  enterRule(_localctx, 64, CHTLJavaScriptParser::RuleBreakStatement);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(643);
    match(CHTLJavaScriptParser::BREAK);
    setState(645);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (_la == CHTLJavaScriptParser::IDENTIFIER) {
      setState(644);
      match(CHTLJavaScriptParser::IDENTIFIER);
    }
    setState(647);
    match(CHTLJavaScriptParser::SEMICOLON);
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- ReturnStatementContext ------------------------------------------------------------------

CHTLJavaScriptParser::ReturnStatementContext::ReturnStatementContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* CHTLJavaScriptParser::ReturnStatementContext::RETURN() {
  return getToken(CHTLJavaScriptParser::RETURN, 0);
}

tree::TerminalNode* CHTLJavaScriptParser::ReturnStatementContext::SEMICOLON() {
  return getToken(CHTLJavaScriptParser::SEMICOLON, 0);
}

CHTLJavaScriptParser::ExpressionSequenceContext* CHTLJavaScriptParser::ReturnStatementContext::expressionSequence() {
  return getRuleContext<CHTLJavaScriptParser::ExpressionSequenceContext>(0);
}


size_t CHTLJavaScriptParser::ReturnStatementContext::getRuleIndex() const {
  return CHTLJavaScriptParser::RuleReturnStatement;
}


std::any CHTLJavaScriptParser::ReturnStatementContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<CHTLJavaScriptVisitor*>(visitor))
    return parserVisitor->visitReturnStatement(this);
  else
    return visitor->visitChildren(this);
}

CHTLJavaScriptParser::ReturnStatementContext* CHTLJavaScriptParser::returnStatement() {
  ReturnStatementContext *_localctx = _tracker.createInstance<ReturnStatementContext>(_ctx, getState());
  enterRule(_localctx, 66, CHTLJavaScriptParser::RuleReturnStatement);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(649);
    match(CHTLJavaScriptParser::RETURN);
    setState(651);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if ((((_la & ~ 0x3fULL) == 0) &&
      ((1ULL << _la) & ((1ULL << CHTLJavaScriptParser::CHTL_SELECTOR_START)
      | (1ULL << CHTLJavaScriptParser::ANIMATE)
      | (1ULL << CHTLJavaScriptParser::TEMPLATE_STRING)
      | (1ULL << CHTLJavaScriptParser::IDENTIFIER)
      | (1ULL << CHTLJavaScriptParser::TYPEOF)
      | (1ULL << CHTLJavaScriptParser::NEW)
      | (1ULL << CHTLJavaScriptParser::VOID)
      | (1ULL << CHTLJavaScriptParser::FUNCTION)
      | (1ULL << CHTLJavaScriptParser::THIS)
      | (1ULL << CHTLJavaScriptParser::DELETE)
      | (1ULL << CHTLJavaScriptParser::SUPER)
      | (1ULL << CHTLJavaScriptParser::ASYNC)
      | (1ULL << CHTLJavaScriptParser::AWAIT))) != 0) || ((((_la - 70) & ~ 0x3fULL) == 0) &&
      ((1ULL << (_la - 70)) & ((1ULL << (CHTLJavaScriptParser::NULL_LITERAL - 70))
      | (1ULL << (CHTLJavaScriptParser::BOOLEAN - 70))
      | (1ULL << (CHTLJavaScriptParser::UNDEFINED - 70))
      | (1ULL << (CHTLJavaScriptParser::LPAREN - 70))
      | (1ULL << (CHTLJavaScriptParser::LBRACE - 70))
      | (1ULL << (CHTLJavaScriptParser::LBRACKET - 70))
      | (1ULL << (CHTLJavaScriptParser::PLUSPLUS - 70))
      | (1ULL << (CHTLJavaScriptParser::MINUSMINUS - 70))
      | (1ULL << (CHTLJavaScriptParser::PLUS - 70))
      | (1ULL << (CHTLJavaScriptParser::MINUS - 70))
      | (1ULL << (CHTLJavaScriptParser::TILDE - 70))
      | (1ULL << (CHTLJavaScriptParser::EXCLAMATION - 70))
      | (1ULL << (CHTLJavaScriptParser::NUMBER - 70))
      | (1ULL << (CHTLJavaScriptParser::STRING - 70)))) != 0)) {
      setState(650);
      expressionSequence();
    }
    setState(653);
    match(CHTLJavaScriptParser::SEMICOLON);
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- WithStatementContext ------------------------------------------------------------------

CHTLJavaScriptParser::WithStatementContext::WithStatementContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* CHTLJavaScriptParser::WithStatementContext::WITH() {
  return getToken(CHTLJavaScriptParser::WITH, 0);
}

tree::TerminalNode* CHTLJavaScriptParser::WithStatementContext::LPAREN() {
  return getToken(CHTLJavaScriptParser::LPAREN, 0);
}

CHTLJavaScriptParser::ExpressionSequenceContext* CHTLJavaScriptParser::WithStatementContext::expressionSequence() {
  return getRuleContext<CHTLJavaScriptParser::ExpressionSequenceContext>(0);
}

tree::TerminalNode* CHTLJavaScriptParser::WithStatementContext::RPAREN() {
  return getToken(CHTLJavaScriptParser::RPAREN, 0);
}

CHTLJavaScriptParser::StatementContext* CHTLJavaScriptParser::WithStatementContext::statement() {
  return getRuleContext<CHTLJavaScriptParser::StatementContext>(0);
}


size_t CHTLJavaScriptParser::WithStatementContext::getRuleIndex() const {
  return CHTLJavaScriptParser::RuleWithStatement;
}


std::any CHTLJavaScriptParser::WithStatementContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<CHTLJavaScriptVisitor*>(visitor))
    return parserVisitor->visitWithStatement(this);
  else
    return visitor->visitChildren(this);
}

CHTLJavaScriptParser::WithStatementContext* CHTLJavaScriptParser::withStatement() {
  WithStatementContext *_localctx = _tracker.createInstance<WithStatementContext>(_ctx, getState());
  enterRule(_localctx, 68, CHTLJavaScriptParser::RuleWithStatement);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(655);
    match(CHTLJavaScriptParser::WITH);
    setState(656);
    match(CHTLJavaScriptParser::LPAREN);
    setState(657);
    expressionSequence();
    setState(658);
    match(CHTLJavaScriptParser::RPAREN);
    setState(659);
    statement();
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- LabelledStatementContext ------------------------------------------------------------------

CHTLJavaScriptParser::LabelledStatementContext::LabelledStatementContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* CHTLJavaScriptParser::LabelledStatementContext::IDENTIFIER() {
  return getToken(CHTLJavaScriptParser::IDENTIFIER, 0);
}

tree::TerminalNode* CHTLJavaScriptParser::LabelledStatementContext::COLON() {
  return getToken(CHTLJavaScriptParser::COLON, 0);
}

CHTLJavaScriptParser::StatementContext* CHTLJavaScriptParser::LabelledStatementContext::statement() {
  return getRuleContext<CHTLJavaScriptParser::StatementContext>(0);
}


size_t CHTLJavaScriptParser::LabelledStatementContext::getRuleIndex() const {
  return CHTLJavaScriptParser::RuleLabelledStatement;
}


std::any CHTLJavaScriptParser::LabelledStatementContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<CHTLJavaScriptVisitor*>(visitor))
    return parserVisitor->visitLabelledStatement(this);
  else
    return visitor->visitChildren(this);
}

CHTLJavaScriptParser::LabelledStatementContext* CHTLJavaScriptParser::labelledStatement() {
  LabelledStatementContext *_localctx = _tracker.createInstance<LabelledStatementContext>(_ctx, getState());
  enterRule(_localctx, 70, CHTLJavaScriptParser::RuleLabelledStatement);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(661);
    match(CHTLJavaScriptParser::IDENTIFIER);
    setState(662);
    match(CHTLJavaScriptParser::COLON);
    setState(663);
    statement();
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- SwitchStatementContext ------------------------------------------------------------------

CHTLJavaScriptParser::SwitchStatementContext::SwitchStatementContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* CHTLJavaScriptParser::SwitchStatementContext::SWITCH() {
  return getToken(CHTLJavaScriptParser::SWITCH, 0);
}

tree::TerminalNode* CHTLJavaScriptParser::SwitchStatementContext::LPAREN() {
  return getToken(CHTLJavaScriptParser::LPAREN, 0);
}

CHTLJavaScriptParser::ExpressionSequenceContext* CHTLJavaScriptParser::SwitchStatementContext::expressionSequence() {
  return getRuleContext<CHTLJavaScriptParser::ExpressionSequenceContext>(0);
}

tree::TerminalNode* CHTLJavaScriptParser::SwitchStatementContext::RPAREN() {
  return getToken(CHTLJavaScriptParser::RPAREN, 0);
}

CHTLJavaScriptParser::CaseBlockContext* CHTLJavaScriptParser::SwitchStatementContext::caseBlock() {
  return getRuleContext<CHTLJavaScriptParser::CaseBlockContext>(0);
}


size_t CHTLJavaScriptParser::SwitchStatementContext::getRuleIndex() const {
  return CHTLJavaScriptParser::RuleSwitchStatement;
}


std::any CHTLJavaScriptParser::SwitchStatementContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<CHTLJavaScriptVisitor*>(visitor))
    return parserVisitor->visitSwitchStatement(this);
  else
    return visitor->visitChildren(this);
}

CHTLJavaScriptParser::SwitchStatementContext* CHTLJavaScriptParser::switchStatement() {
  SwitchStatementContext *_localctx = _tracker.createInstance<SwitchStatementContext>(_ctx, getState());
  enterRule(_localctx, 72, CHTLJavaScriptParser::RuleSwitchStatement);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(665);
    match(CHTLJavaScriptParser::SWITCH);
    setState(666);
    match(CHTLJavaScriptParser::LPAREN);
    setState(667);
    expressionSequence();
    setState(668);
    match(CHTLJavaScriptParser::RPAREN);
    setState(669);
    caseBlock();
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- CaseBlockContext ------------------------------------------------------------------

CHTLJavaScriptParser::CaseBlockContext::CaseBlockContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* CHTLJavaScriptParser::CaseBlockContext::LBRACE() {
  return getToken(CHTLJavaScriptParser::LBRACE, 0);
}

tree::TerminalNode* CHTLJavaScriptParser::CaseBlockContext::RBRACE() {
  return getToken(CHTLJavaScriptParser::RBRACE, 0);
}

std::vector<CHTLJavaScriptParser::CaseClausesContext *> CHTLJavaScriptParser::CaseBlockContext::caseClauses() {
  return getRuleContexts<CHTLJavaScriptParser::CaseClausesContext>();
}

CHTLJavaScriptParser::CaseClausesContext* CHTLJavaScriptParser::CaseBlockContext::caseClauses(size_t i) {
  return getRuleContext<CHTLJavaScriptParser::CaseClausesContext>(i);
}

CHTLJavaScriptParser::DefaultClauseContext* CHTLJavaScriptParser::CaseBlockContext::defaultClause() {
  return getRuleContext<CHTLJavaScriptParser::DefaultClauseContext>(0);
}


size_t CHTLJavaScriptParser::CaseBlockContext::getRuleIndex() const {
  return CHTLJavaScriptParser::RuleCaseBlock;
}


std::any CHTLJavaScriptParser::CaseBlockContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<CHTLJavaScriptVisitor*>(visitor))
    return parserVisitor->visitCaseBlock(this);
  else
    return visitor->visitChildren(this);
}

CHTLJavaScriptParser::CaseBlockContext* CHTLJavaScriptParser::caseBlock() {
  CaseBlockContext *_localctx = _tracker.createInstance<CaseBlockContext>(_ctx, getState());
  enterRule(_localctx, 74, CHTLJavaScriptParser::RuleCaseBlock);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(671);
    match(CHTLJavaScriptParser::LBRACE);
    setState(673);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (_la == CHTLJavaScriptParser::CASE) {
      setState(672);
      caseClauses();
    }
    setState(679);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (_la == CHTLJavaScriptParser::DEFAULT) {
      setState(675);
      defaultClause();
      setState(677);
      _errHandler->sync(this);

      _la = _input->LA(1);
      if (_la == CHTLJavaScriptParser::CASE) {
        setState(676);
        caseClauses();
      }
    }
    setState(681);
    match(CHTLJavaScriptParser::RBRACE);
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- CaseClausesContext ------------------------------------------------------------------

CHTLJavaScriptParser::CaseClausesContext::CaseClausesContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

std::vector<CHTLJavaScriptParser::CaseClauseContext *> CHTLJavaScriptParser::CaseClausesContext::caseClause() {
  return getRuleContexts<CHTLJavaScriptParser::CaseClauseContext>();
}

CHTLJavaScriptParser::CaseClauseContext* CHTLJavaScriptParser::CaseClausesContext::caseClause(size_t i) {
  return getRuleContext<CHTLJavaScriptParser::CaseClauseContext>(i);
}


size_t CHTLJavaScriptParser::CaseClausesContext::getRuleIndex() const {
  return CHTLJavaScriptParser::RuleCaseClauses;
}


std::any CHTLJavaScriptParser::CaseClausesContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<CHTLJavaScriptVisitor*>(visitor))
    return parserVisitor->visitCaseClauses(this);
  else
    return visitor->visitChildren(this);
}

CHTLJavaScriptParser::CaseClausesContext* CHTLJavaScriptParser::caseClauses() {
  CaseClausesContext *_localctx = _tracker.createInstance<CaseClausesContext>(_ctx, getState());
  enterRule(_localctx, 76, CHTLJavaScriptParser::RuleCaseClauses);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(684); 
    _errHandler->sync(this);
    _la = _input->LA(1);
    do {
      setState(683);
      caseClause();
      setState(686); 
      _errHandler->sync(this);
      _la = _input->LA(1);
    } while (_la == CHTLJavaScriptParser::CASE);
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- CaseClauseContext ------------------------------------------------------------------

CHTLJavaScriptParser::CaseClauseContext::CaseClauseContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* CHTLJavaScriptParser::CaseClauseContext::CASE() {
  return getToken(CHTLJavaScriptParser::CASE, 0);
}

CHTLJavaScriptParser::ExpressionSequenceContext* CHTLJavaScriptParser::CaseClauseContext::expressionSequence() {
  return getRuleContext<CHTLJavaScriptParser::ExpressionSequenceContext>(0);
}

tree::TerminalNode* CHTLJavaScriptParser::CaseClauseContext::COLON() {
  return getToken(CHTLJavaScriptParser::COLON, 0);
}

std::vector<CHTLJavaScriptParser::StatementContext *> CHTLJavaScriptParser::CaseClauseContext::statement() {
  return getRuleContexts<CHTLJavaScriptParser::StatementContext>();
}

CHTLJavaScriptParser::StatementContext* CHTLJavaScriptParser::CaseClauseContext::statement(size_t i) {
  return getRuleContext<CHTLJavaScriptParser::StatementContext>(i);
}


size_t CHTLJavaScriptParser::CaseClauseContext::getRuleIndex() const {
  return CHTLJavaScriptParser::RuleCaseClause;
}


std::any CHTLJavaScriptParser::CaseClauseContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<CHTLJavaScriptVisitor*>(visitor))
    return parserVisitor->visitCaseClause(this);
  else
    return visitor->visitChildren(this);
}

CHTLJavaScriptParser::CaseClauseContext* CHTLJavaScriptParser::caseClause() {
  CaseClauseContext *_localctx = _tracker.createInstance<CaseClauseContext>(_ctx, getState());
  enterRule(_localctx, 78, CHTLJavaScriptParser::RuleCaseClause);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(688);
    match(CHTLJavaScriptParser::CASE);
    setState(689);
    expressionSequence();
    setState(690);
    match(CHTLJavaScriptParser::COLON);
    setState(694);
    _errHandler->sync(this);
    _la = _input->LA(1);
    while ((((_la & ~ 0x3fULL) == 0) &&
      ((1ULL << _la) & ((1ULL << CHTLJavaScriptParser::CHTL_SELECTOR_START)
      | (1ULL << CHTLJavaScriptParser::ANIMATE)
      | (1ULL << CHTLJavaScriptParser::TEMPLATE_STRING)
      | (1ULL << CHTLJavaScriptParser::IDENTIFIER)
      | (1ULL << CHTLJavaScriptParser::BREAK)
      | (1ULL << CHTLJavaScriptParser::DO)
      | (1ULL << CHTLJavaScriptParser::TYPEOF)
      | (1ULL << CHTLJavaScriptParser::NEW)
      | (1ULL << CHTLJavaScriptParser::VAR)
      | (1ULL << CHTLJavaScriptParser::RETURN)
      | (1ULL << CHTLJavaScriptParser::VOID)
      | (1ULL << CHTLJavaScriptParser::CONTINUE)
      | (1ULL << CHTLJavaScriptParser::FOR)
      | (1ULL << CHTLJavaScriptParser::SWITCH)
      | (1ULL << CHTLJavaScriptParser::WHILE)
      | (1ULL << CHTLJavaScriptParser::FUNCTION)
      | (1ULL << CHTLJavaScriptParser::THIS)
      | (1ULL << CHTLJavaScriptParser::WITH)
      | (1ULL << CHTLJavaScriptParser::IF)
      | (1ULL << CHTLJavaScriptParser::THROW)
      | (1ULL << CHTLJavaScriptParser::DELETE)
      | (1ULL << CHTLJavaScriptParser::TRY)
      | (1ULL << CHTLJavaScriptParser::CLASS)
      | (1ULL << CHTLJavaScriptParser::SUPER)
      | (1ULL << CHTLJavaScriptParser::CONST)
      | (1ULL << CHTLJavaScriptParser::EXPORT)
      | (1ULL << CHTLJavaScriptParser::IMPORT)
      | (1ULL << CHTLJavaScriptParser::ASYNC)
      | (1ULL << CHTLJavaScriptParser::AWAIT)
      | (1ULL << CHTLJavaScriptParser::LET))) != 0) || ((((_la - 70) & ~ 0x3fULL) == 0) &&
      ((1ULL << (_la - 70)) & ((1ULL << (CHTLJavaScriptParser::NULL_LITERAL - 70))
      | (1ULL << (CHTLJavaScriptParser::BOOLEAN - 70))
      | (1ULL << (CHTLJavaScriptParser::UNDEFINED - 70))
      | (1ULL << (CHTLJavaScriptParser::LPAREN - 70))
      | (1ULL << (CHTLJavaScriptParser::LBRACE - 70))
      | (1ULL << (CHTLJavaScriptParser::LBRACKET - 70))
      | (1ULL << (CHTLJavaScriptParser::SEMICOLON - 70))
      | (1ULL << (CHTLJavaScriptParser::PLUSPLUS - 70))
      | (1ULL << (CHTLJavaScriptParser::MINUSMINUS - 70))
      | (1ULL << (CHTLJavaScriptParser::PLUS - 70))
      | (1ULL << (CHTLJavaScriptParser::MINUS - 70))
      | (1ULL << (CHTLJavaScriptParser::TILDE - 70))
      | (1ULL << (CHTLJavaScriptParser::EXCLAMATION - 70))
      | (1ULL << (CHTLJavaScriptParser::NUMBER - 70))
      | (1ULL << (CHTLJavaScriptParser::STRING - 70)))) != 0)) {
      setState(691);
      statement();
      setState(696);
      _errHandler->sync(this);
      _la = _input->LA(1);
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- DefaultClauseContext ------------------------------------------------------------------

CHTLJavaScriptParser::DefaultClauseContext::DefaultClauseContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* CHTLJavaScriptParser::DefaultClauseContext::DEFAULT() {
  return getToken(CHTLJavaScriptParser::DEFAULT, 0);
}

tree::TerminalNode* CHTLJavaScriptParser::DefaultClauseContext::COLON() {
  return getToken(CHTLJavaScriptParser::COLON, 0);
}

std::vector<CHTLJavaScriptParser::StatementContext *> CHTLJavaScriptParser::DefaultClauseContext::statement() {
  return getRuleContexts<CHTLJavaScriptParser::StatementContext>();
}

CHTLJavaScriptParser::StatementContext* CHTLJavaScriptParser::DefaultClauseContext::statement(size_t i) {
  return getRuleContext<CHTLJavaScriptParser::StatementContext>(i);
}


size_t CHTLJavaScriptParser::DefaultClauseContext::getRuleIndex() const {
  return CHTLJavaScriptParser::RuleDefaultClause;
}


std::any CHTLJavaScriptParser::DefaultClauseContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<CHTLJavaScriptVisitor*>(visitor))
    return parserVisitor->visitDefaultClause(this);
  else
    return visitor->visitChildren(this);
}

CHTLJavaScriptParser::DefaultClauseContext* CHTLJavaScriptParser::defaultClause() {
  DefaultClauseContext *_localctx = _tracker.createInstance<DefaultClauseContext>(_ctx, getState());
  enterRule(_localctx, 80, CHTLJavaScriptParser::RuleDefaultClause);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(697);
    match(CHTLJavaScriptParser::DEFAULT);
    setState(698);
    match(CHTLJavaScriptParser::COLON);
    setState(702);
    _errHandler->sync(this);
    _la = _input->LA(1);
    while ((((_la & ~ 0x3fULL) == 0) &&
      ((1ULL << _la) & ((1ULL << CHTLJavaScriptParser::CHTL_SELECTOR_START)
      | (1ULL << CHTLJavaScriptParser::ANIMATE)
      | (1ULL << CHTLJavaScriptParser::TEMPLATE_STRING)
      | (1ULL << CHTLJavaScriptParser::IDENTIFIER)
      | (1ULL << CHTLJavaScriptParser::BREAK)
      | (1ULL << CHTLJavaScriptParser::DO)
      | (1ULL << CHTLJavaScriptParser::TYPEOF)
      | (1ULL << CHTLJavaScriptParser::NEW)
      | (1ULL << CHTLJavaScriptParser::VAR)
      | (1ULL << CHTLJavaScriptParser::RETURN)
      | (1ULL << CHTLJavaScriptParser::VOID)
      | (1ULL << CHTLJavaScriptParser::CONTINUE)
      | (1ULL << CHTLJavaScriptParser::FOR)
      | (1ULL << CHTLJavaScriptParser::SWITCH)
      | (1ULL << CHTLJavaScriptParser::WHILE)
      | (1ULL << CHTLJavaScriptParser::FUNCTION)
      | (1ULL << CHTLJavaScriptParser::THIS)
      | (1ULL << CHTLJavaScriptParser::WITH)
      | (1ULL << CHTLJavaScriptParser::IF)
      | (1ULL << CHTLJavaScriptParser::THROW)
      | (1ULL << CHTLJavaScriptParser::DELETE)
      | (1ULL << CHTLJavaScriptParser::TRY)
      | (1ULL << CHTLJavaScriptParser::CLASS)
      | (1ULL << CHTLJavaScriptParser::SUPER)
      | (1ULL << CHTLJavaScriptParser::CONST)
      | (1ULL << CHTLJavaScriptParser::EXPORT)
      | (1ULL << CHTLJavaScriptParser::IMPORT)
      | (1ULL << CHTLJavaScriptParser::ASYNC)
      | (1ULL << CHTLJavaScriptParser::AWAIT)
      | (1ULL << CHTLJavaScriptParser::LET))) != 0) || ((((_la - 70) & ~ 0x3fULL) == 0) &&
      ((1ULL << (_la - 70)) & ((1ULL << (CHTLJavaScriptParser::NULL_LITERAL - 70))
      | (1ULL << (CHTLJavaScriptParser::BOOLEAN - 70))
      | (1ULL << (CHTLJavaScriptParser::UNDEFINED - 70))
      | (1ULL << (CHTLJavaScriptParser::LPAREN - 70))
      | (1ULL << (CHTLJavaScriptParser::LBRACE - 70))
      | (1ULL << (CHTLJavaScriptParser::LBRACKET - 70))
      | (1ULL << (CHTLJavaScriptParser::SEMICOLON - 70))
      | (1ULL << (CHTLJavaScriptParser::PLUSPLUS - 70))
      | (1ULL << (CHTLJavaScriptParser::MINUSMINUS - 70))
      | (1ULL << (CHTLJavaScriptParser::PLUS - 70))
      | (1ULL << (CHTLJavaScriptParser::MINUS - 70))
      | (1ULL << (CHTLJavaScriptParser::TILDE - 70))
      | (1ULL << (CHTLJavaScriptParser::EXCLAMATION - 70))
      | (1ULL << (CHTLJavaScriptParser::NUMBER - 70))
      | (1ULL << (CHTLJavaScriptParser::STRING - 70)))) != 0)) {
      setState(699);
      statement();
      setState(704);
      _errHandler->sync(this);
      _la = _input->LA(1);
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- ThrowStatementContext ------------------------------------------------------------------

CHTLJavaScriptParser::ThrowStatementContext::ThrowStatementContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* CHTLJavaScriptParser::ThrowStatementContext::THROW() {
  return getToken(CHTLJavaScriptParser::THROW, 0);
}

CHTLJavaScriptParser::ExpressionSequenceContext* CHTLJavaScriptParser::ThrowStatementContext::expressionSequence() {
  return getRuleContext<CHTLJavaScriptParser::ExpressionSequenceContext>(0);
}

tree::TerminalNode* CHTLJavaScriptParser::ThrowStatementContext::SEMICOLON() {
  return getToken(CHTLJavaScriptParser::SEMICOLON, 0);
}


size_t CHTLJavaScriptParser::ThrowStatementContext::getRuleIndex() const {
  return CHTLJavaScriptParser::RuleThrowStatement;
}


std::any CHTLJavaScriptParser::ThrowStatementContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<CHTLJavaScriptVisitor*>(visitor))
    return parserVisitor->visitThrowStatement(this);
  else
    return visitor->visitChildren(this);
}

CHTLJavaScriptParser::ThrowStatementContext* CHTLJavaScriptParser::throwStatement() {
  ThrowStatementContext *_localctx = _tracker.createInstance<ThrowStatementContext>(_ctx, getState());
  enterRule(_localctx, 82, CHTLJavaScriptParser::RuleThrowStatement);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(705);
    match(CHTLJavaScriptParser::THROW);
    setState(706);
    expressionSequence();
    setState(707);
    match(CHTLJavaScriptParser::SEMICOLON);
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- TryStatementContext ------------------------------------------------------------------

CHTLJavaScriptParser::TryStatementContext::TryStatementContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* CHTLJavaScriptParser::TryStatementContext::TRY() {
  return getToken(CHTLJavaScriptParser::TRY, 0);
}

CHTLJavaScriptParser::BlockContext* CHTLJavaScriptParser::TryStatementContext::block() {
  return getRuleContext<CHTLJavaScriptParser::BlockContext>(0);
}

CHTLJavaScriptParser::CatchClauseContext* CHTLJavaScriptParser::TryStatementContext::catchClause() {
  return getRuleContext<CHTLJavaScriptParser::CatchClauseContext>(0);
}

CHTLJavaScriptParser::FinallyClauseContext* CHTLJavaScriptParser::TryStatementContext::finallyClause() {
  return getRuleContext<CHTLJavaScriptParser::FinallyClauseContext>(0);
}


size_t CHTLJavaScriptParser::TryStatementContext::getRuleIndex() const {
  return CHTLJavaScriptParser::RuleTryStatement;
}


std::any CHTLJavaScriptParser::TryStatementContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<CHTLJavaScriptVisitor*>(visitor))
    return parserVisitor->visitTryStatement(this);
  else
    return visitor->visitChildren(this);
}

CHTLJavaScriptParser::TryStatementContext* CHTLJavaScriptParser::tryStatement() {
  TryStatementContext *_localctx = _tracker.createInstance<TryStatementContext>(_ctx, getState());
  enterRule(_localctx, 84, CHTLJavaScriptParser::RuleTryStatement);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(709);
    match(CHTLJavaScriptParser::TRY);
    setState(710);
    block();
    setState(716);
    _errHandler->sync(this);
    switch (_input->LA(1)) {
      case CHTLJavaScriptParser::CATCH: {
        setState(711);
        catchClause();
        setState(713);
        _errHandler->sync(this);

        _la = _input->LA(1);
        if (_la == CHTLJavaScriptParser::FINALLY) {
          setState(712);
          finallyClause();
        }
        break;
      }

      case CHTLJavaScriptParser::FINALLY: {
        setState(715);
        finallyClause();
        break;
      }

    default:
      throw NoViableAltException(this);
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- CatchClauseContext ------------------------------------------------------------------

CHTLJavaScriptParser::CatchClauseContext::CatchClauseContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* CHTLJavaScriptParser::CatchClauseContext::CATCH() {
  return getToken(CHTLJavaScriptParser::CATCH, 0);
}

CHTLJavaScriptParser::BlockContext* CHTLJavaScriptParser::CatchClauseContext::block() {
  return getRuleContext<CHTLJavaScriptParser::BlockContext>(0);
}

tree::TerminalNode* CHTLJavaScriptParser::CatchClauseContext::LPAREN() {
  return getToken(CHTLJavaScriptParser::LPAREN, 0);
}

CHTLJavaScriptParser::AssignableContext* CHTLJavaScriptParser::CatchClauseContext::assignable() {
  return getRuleContext<CHTLJavaScriptParser::AssignableContext>(0);
}

tree::TerminalNode* CHTLJavaScriptParser::CatchClauseContext::RPAREN() {
  return getToken(CHTLJavaScriptParser::RPAREN, 0);
}


size_t CHTLJavaScriptParser::CatchClauseContext::getRuleIndex() const {
  return CHTLJavaScriptParser::RuleCatchClause;
}


std::any CHTLJavaScriptParser::CatchClauseContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<CHTLJavaScriptVisitor*>(visitor))
    return parserVisitor->visitCatchClause(this);
  else
    return visitor->visitChildren(this);
}

CHTLJavaScriptParser::CatchClauseContext* CHTLJavaScriptParser::catchClause() {
  CatchClauseContext *_localctx = _tracker.createInstance<CatchClauseContext>(_ctx, getState());
  enterRule(_localctx, 86, CHTLJavaScriptParser::RuleCatchClause);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(718);
    match(CHTLJavaScriptParser::CATCH);
    setState(723);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (_la == CHTLJavaScriptParser::LPAREN) {
      setState(719);
      match(CHTLJavaScriptParser::LPAREN);
      setState(720);
      assignable();
      setState(721);
      match(CHTLJavaScriptParser::RPAREN);
    }
    setState(725);
    block();
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- FinallyClauseContext ------------------------------------------------------------------

CHTLJavaScriptParser::FinallyClauseContext::FinallyClauseContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* CHTLJavaScriptParser::FinallyClauseContext::FINALLY() {
  return getToken(CHTLJavaScriptParser::FINALLY, 0);
}

CHTLJavaScriptParser::BlockContext* CHTLJavaScriptParser::FinallyClauseContext::block() {
  return getRuleContext<CHTLJavaScriptParser::BlockContext>(0);
}


size_t CHTLJavaScriptParser::FinallyClauseContext::getRuleIndex() const {
  return CHTLJavaScriptParser::RuleFinallyClause;
}


std::any CHTLJavaScriptParser::FinallyClauseContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<CHTLJavaScriptVisitor*>(visitor))
    return parserVisitor->visitFinallyClause(this);
  else
    return visitor->visitChildren(this);
}

CHTLJavaScriptParser::FinallyClauseContext* CHTLJavaScriptParser::finallyClause() {
  FinallyClauseContext *_localctx = _tracker.createInstance<FinallyClauseContext>(_ctx, getState());
  enterRule(_localctx, 88, CHTLJavaScriptParser::RuleFinallyClause);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(727);
    match(CHTLJavaScriptParser::FINALLY);
    setState(728);
    block();
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- FunctionDeclarationContext ------------------------------------------------------------------

CHTLJavaScriptParser::FunctionDeclarationContext::FunctionDeclarationContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* CHTLJavaScriptParser::FunctionDeclarationContext::FUNCTION() {
  return getToken(CHTLJavaScriptParser::FUNCTION, 0);
}

tree::TerminalNode* CHTLJavaScriptParser::FunctionDeclarationContext::IDENTIFIER() {
  return getToken(CHTLJavaScriptParser::IDENTIFIER, 0);
}

tree::TerminalNode* CHTLJavaScriptParser::FunctionDeclarationContext::LPAREN() {
  return getToken(CHTLJavaScriptParser::LPAREN, 0);
}

tree::TerminalNode* CHTLJavaScriptParser::FunctionDeclarationContext::RPAREN() {
  return getToken(CHTLJavaScriptParser::RPAREN, 0);
}

CHTLJavaScriptParser::BlockContext* CHTLJavaScriptParser::FunctionDeclarationContext::block() {
  return getRuleContext<CHTLJavaScriptParser::BlockContext>(0);
}

tree::TerminalNode* CHTLJavaScriptParser::FunctionDeclarationContext::ASYNC() {
  return getToken(CHTLJavaScriptParser::ASYNC, 0);
}

tree::TerminalNode* CHTLJavaScriptParser::FunctionDeclarationContext::STAR() {
  return getToken(CHTLJavaScriptParser::STAR, 0);
}

CHTLJavaScriptParser::FormalParameterListContext* CHTLJavaScriptParser::FunctionDeclarationContext::formalParameterList() {
  return getRuleContext<CHTLJavaScriptParser::FormalParameterListContext>(0);
}


size_t CHTLJavaScriptParser::FunctionDeclarationContext::getRuleIndex() const {
  return CHTLJavaScriptParser::RuleFunctionDeclaration;
}


std::any CHTLJavaScriptParser::FunctionDeclarationContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<CHTLJavaScriptVisitor*>(visitor))
    return parserVisitor->visitFunctionDeclaration(this);
  else
    return visitor->visitChildren(this);
}

CHTLJavaScriptParser::FunctionDeclarationContext* CHTLJavaScriptParser::functionDeclaration() {
  FunctionDeclarationContext *_localctx = _tracker.createInstance<FunctionDeclarationContext>(_ctx, getState());
  enterRule(_localctx, 90, CHTLJavaScriptParser::RuleFunctionDeclaration);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(731);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (_la == CHTLJavaScriptParser::ASYNC) {
      setState(730);
      match(CHTLJavaScriptParser::ASYNC);
    }
    setState(733);
    match(CHTLJavaScriptParser::FUNCTION);
    setState(735);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (_la == CHTLJavaScriptParser::STAR) {
      setState(734);
      match(CHTLJavaScriptParser::STAR);
    }
    setState(737);
    match(CHTLJavaScriptParser::IDENTIFIER);
    setState(738);
    match(CHTLJavaScriptParser::LPAREN);
    setState(740);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (((((_la - 23) & ~ 0x3fULL) == 0) &&
      ((1ULL << (_la - 23)) & ((1ULL << (CHTLJavaScriptParser::IDENTIFIER - 23))
      | (1ULL << (CHTLJavaScriptParser::LBRACE - 23))
      | (1ULL << (CHTLJavaScriptParser::LBRACKET - 23))
      | (1ULL << (CHTLJavaScriptParser::ELLIPSIS - 23)))) != 0)) {
      setState(739);
      formalParameterList();
    }
    setState(742);
    match(CHTLJavaScriptParser::RPAREN);
    setState(743);
    block();
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- ClassDeclarationContext ------------------------------------------------------------------

CHTLJavaScriptParser::ClassDeclarationContext::ClassDeclarationContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* CHTLJavaScriptParser::ClassDeclarationContext::CLASS() {
  return getToken(CHTLJavaScriptParser::CLASS, 0);
}

tree::TerminalNode* CHTLJavaScriptParser::ClassDeclarationContext::IDENTIFIER() {
  return getToken(CHTLJavaScriptParser::IDENTIFIER, 0);
}

CHTLJavaScriptParser::ClassTailContext* CHTLJavaScriptParser::ClassDeclarationContext::classTail() {
  return getRuleContext<CHTLJavaScriptParser::ClassTailContext>(0);
}

tree::TerminalNode* CHTLJavaScriptParser::ClassDeclarationContext::EXTENDS() {
  return getToken(CHTLJavaScriptParser::EXTENDS, 0);
}

CHTLJavaScriptParser::SingleExpressionContext* CHTLJavaScriptParser::ClassDeclarationContext::singleExpression() {
  return getRuleContext<CHTLJavaScriptParser::SingleExpressionContext>(0);
}


size_t CHTLJavaScriptParser::ClassDeclarationContext::getRuleIndex() const {
  return CHTLJavaScriptParser::RuleClassDeclaration;
}


std::any CHTLJavaScriptParser::ClassDeclarationContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<CHTLJavaScriptVisitor*>(visitor))
    return parserVisitor->visitClassDeclaration(this);
  else
    return visitor->visitChildren(this);
}

CHTLJavaScriptParser::ClassDeclarationContext* CHTLJavaScriptParser::classDeclaration() {
  ClassDeclarationContext *_localctx = _tracker.createInstance<ClassDeclarationContext>(_ctx, getState());
  enterRule(_localctx, 92, CHTLJavaScriptParser::RuleClassDeclaration);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(745);
    match(CHTLJavaScriptParser::CLASS);
    setState(746);
    match(CHTLJavaScriptParser::IDENTIFIER);
    setState(749);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (_la == CHTLJavaScriptParser::EXTENDS) {
      setState(747);
      match(CHTLJavaScriptParser::EXTENDS);
      setState(748);
      singleExpression(0);
    }
    setState(751);
    classTail();
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- ClassTailContext ------------------------------------------------------------------

CHTLJavaScriptParser::ClassTailContext::ClassTailContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* CHTLJavaScriptParser::ClassTailContext::LBRACE() {
  return getToken(CHTLJavaScriptParser::LBRACE, 0);
}

tree::TerminalNode* CHTLJavaScriptParser::ClassTailContext::RBRACE() {
  return getToken(CHTLJavaScriptParser::RBRACE, 0);
}

std::vector<CHTLJavaScriptParser::ClassElementContext *> CHTLJavaScriptParser::ClassTailContext::classElement() {
  return getRuleContexts<CHTLJavaScriptParser::ClassElementContext>();
}

CHTLJavaScriptParser::ClassElementContext* CHTLJavaScriptParser::ClassTailContext::classElement(size_t i) {
  return getRuleContext<CHTLJavaScriptParser::ClassElementContext>(i);
}


size_t CHTLJavaScriptParser::ClassTailContext::getRuleIndex() const {
  return CHTLJavaScriptParser::RuleClassTail;
}


std::any CHTLJavaScriptParser::ClassTailContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<CHTLJavaScriptVisitor*>(visitor))
    return parserVisitor->visitClassTail(this);
  else
    return visitor->visitChildren(this);
}

CHTLJavaScriptParser::ClassTailContext* CHTLJavaScriptParser::classTail() {
  ClassTailContext *_localctx = _tracker.createInstance<ClassTailContext>(_ctx, getState());
  enterRule(_localctx, 94, CHTLJavaScriptParser::RuleClassTail);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(753);
    match(CHTLJavaScriptParser::LBRACE);
    setState(757);
    _errHandler->sync(this);
    _la = _input->LA(1);
    while (((((_la - 23) & ~ 0x3fULL) == 0) &&
      ((1ULL << (_la - 23)) & ((1ULL << (CHTLJavaScriptParser::IDENTIFIER - 23))
      | (1ULL << (CHTLJavaScriptParser::BREAK - 23))
      | (1ULL << (CHTLJavaScriptParser::DO - 23))
      | (1ULL << (CHTLJavaScriptParser::INSTANCEOF - 23))
      | (1ULL << (CHTLJavaScriptParser::TYPEOF - 23))
      | (1ULL << (CHTLJavaScriptParser::CASE - 23))
      | (1ULL << (CHTLJavaScriptParser::ELSE - 23))
      | (1ULL << (CHTLJavaScriptParser::NEW - 23))
      | (1ULL << (CHTLJavaScriptParser::VAR - 23))
      | (1ULL << (CHTLJavaScriptParser::CATCH - 23))
      | (1ULL << (CHTLJavaScriptParser::FINALLY - 23))
      | (1ULL << (CHTLJavaScriptParser::RETURN - 23))
      | (1ULL << (CHTLJavaScriptParser::VOID - 23))
      | (1ULL << (CHTLJavaScriptParser::CONTINUE - 23))
      | (1ULL << (CHTLJavaScriptParser::FOR - 23))
      | (1ULL << (CHTLJavaScriptParser::SWITCH - 23))
      | (1ULL << (CHTLJavaScriptParser::WHILE - 23))
      | (1ULL << (CHTLJavaScriptParser::DEBUGGER - 23))
      | (1ULL << (CHTLJavaScriptParser::FUNCTION - 23))
      | (1ULL << (CHTLJavaScriptParser::THIS - 23))
      | (1ULL << (CHTLJavaScriptParser::WITH - 23))
      | (1ULL << (CHTLJavaScriptParser::DEFAULT - 23))
      | (1ULL << (CHTLJavaScriptParser::IF - 23))
      | (1ULL << (CHTLJavaScriptParser::THROW - 23))
      | (1ULL << (CHTLJavaScriptParser::DELETE - 23))
      | (1ULL << (CHTLJavaScriptParser::IN - 23))
      | (1ULL << (CHTLJavaScriptParser::TRY - 23))
      | (1ULL << (CHTLJavaScriptParser::CLASS - 23))
      | (1ULL << (CHTLJavaScriptParser::ENUM - 23))
      | (1ULL << (CHTLJavaScriptParser::EXTENDS - 23))
      | (1ULL << (CHTLJavaScriptParser::SUPER - 23))
      | (1ULL << (CHTLJavaScriptParser::CONST - 23))
      | (1ULL << (CHTLJavaScriptParser::EXPORT - 23))
      | (1ULL << (CHTLJavaScriptParser::IMPORT - 23))
      | (1ULL << (CHTLJavaScriptParser::ASYNC - 23))
      | (1ULL << (CHTLJavaScriptParser::AWAIT - 23))
      | (1ULL << (CHTLJavaScriptParser::YIELD - 23))
      | (1ULL << (CHTLJavaScriptParser::LET - 23))
      | (1ULL << (CHTLJavaScriptParser::STATIC - 23))
      | (1ULL << (CHTLJavaScriptParser::FROM - 23))
      | (1ULL << (CHTLJavaScriptParser::AS - 23))
      | (1ULL << (CHTLJavaScriptParser::OF - 23))
      | (1ULL << (CHTLJavaScriptParser::GET - 23))
      | (1ULL << (CHTLJavaScriptParser::SET - 23))
      | (1ULL << (CHTLJavaScriptParser::NULL_LITERAL - 23))
      | (1ULL << (CHTLJavaScriptParser::BOOLEAN - 23))
      | (1ULL << (CHTLJavaScriptParser::LBRACKET - 23))
      | (1ULL << (CHTLJavaScriptParser::SEMICOLON - 23)))) != 0) || ((((_la - 106) & ~ 0x3fULL) == 0) &&
      ((1ULL << (_la - 106)) & ((1ULL << (CHTLJavaScriptParser::STAR - 106))
      | (1ULL << (CHTLJavaScriptParser::NUMBER - 106))
      | (1ULL << (CHTLJavaScriptParser::STRING - 106)))) != 0)) {
      setState(754);
      classElement();
      setState(759);
      _errHandler->sync(this);
      _la = _input->LA(1);
    }
    setState(760);
    match(CHTLJavaScriptParser::RBRACE);
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- ClassElementContext ------------------------------------------------------------------

CHTLJavaScriptParser::ClassElementContext::ClassElementContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

CHTLJavaScriptParser::MethodDefinitionContext* CHTLJavaScriptParser::ClassElementContext::methodDefinition() {
  return getRuleContext<CHTLJavaScriptParser::MethodDefinitionContext>(0);
}

tree::TerminalNode* CHTLJavaScriptParser::ClassElementContext::STATIC() {
  return getToken(CHTLJavaScriptParser::STATIC, 0);
}

CHTLJavaScriptParser::EmptyStatementContext* CHTLJavaScriptParser::ClassElementContext::emptyStatement() {
  return getRuleContext<CHTLJavaScriptParser::EmptyStatementContext>(0);
}

CHTLJavaScriptParser::PropertyNameContext* CHTLJavaScriptParser::ClassElementContext::propertyName() {
  return getRuleContext<CHTLJavaScriptParser::PropertyNameContext>(0);
}

tree::TerminalNode* CHTLJavaScriptParser::ClassElementContext::EQUALS() {
  return getToken(CHTLJavaScriptParser::EQUALS, 0);
}

CHTLJavaScriptParser::SingleExpressionContext* CHTLJavaScriptParser::ClassElementContext::singleExpression() {
  return getRuleContext<CHTLJavaScriptParser::SingleExpressionContext>(0);
}

tree::TerminalNode* CHTLJavaScriptParser::ClassElementContext::SEMICOLON() {
  return getToken(CHTLJavaScriptParser::SEMICOLON, 0);
}


size_t CHTLJavaScriptParser::ClassElementContext::getRuleIndex() const {
  return CHTLJavaScriptParser::RuleClassElement;
}


std::any CHTLJavaScriptParser::ClassElementContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<CHTLJavaScriptVisitor*>(visitor))
    return parserVisitor->visitClassElement(this);
  else
    return visitor->visitChildren(this);
}

CHTLJavaScriptParser::ClassElementContext* CHTLJavaScriptParser::classElement() {
  ClassElementContext *_localctx = _tracker.createInstance<ClassElementContext>(_ctx, getState());
  enterRule(_localctx, 96, CHTLJavaScriptParser::RuleClassElement);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    setState(772);
    _errHandler->sync(this);
    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 54, _ctx)) {
    case 1: {
      enterOuterAlt(_localctx, 1);
      setState(763);
      _errHandler->sync(this);

      switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 53, _ctx)) {
      case 1: {
        setState(762);
        match(CHTLJavaScriptParser::STATIC);
        break;
      }

      default:
        break;
      }
      setState(765);
      methodDefinition();
      break;
    }

    case 2: {
      enterOuterAlt(_localctx, 2);
      setState(766);
      emptyStatement();
      break;
    }

    case 3: {
      enterOuterAlt(_localctx, 3);
      setState(767);
      propertyName();
      setState(768);
      match(CHTLJavaScriptParser::EQUALS);
      setState(769);
      singleExpression(0);
      setState(770);
      match(CHTLJavaScriptParser::SEMICOLON);
      break;
    }

    default:
      break;
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- MethodDefinitionContext ------------------------------------------------------------------

CHTLJavaScriptParser::MethodDefinitionContext::MethodDefinitionContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

CHTLJavaScriptParser::PropertyNameContext* CHTLJavaScriptParser::MethodDefinitionContext::propertyName() {
  return getRuleContext<CHTLJavaScriptParser::PropertyNameContext>(0);
}

tree::TerminalNode* CHTLJavaScriptParser::MethodDefinitionContext::LPAREN() {
  return getToken(CHTLJavaScriptParser::LPAREN, 0);
}

tree::TerminalNode* CHTLJavaScriptParser::MethodDefinitionContext::RPAREN() {
  return getToken(CHTLJavaScriptParser::RPAREN, 0);
}

CHTLJavaScriptParser::BlockContext* CHTLJavaScriptParser::MethodDefinitionContext::block() {
  return getRuleContext<CHTLJavaScriptParser::BlockContext>(0);
}

CHTLJavaScriptParser::FormalParameterListContext* CHTLJavaScriptParser::MethodDefinitionContext::formalParameterList() {
  return getRuleContext<CHTLJavaScriptParser::FormalParameterListContext>(0);
}

CHTLJavaScriptParser::GetterContext* CHTLJavaScriptParser::MethodDefinitionContext::getter() {
  return getRuleContext<CHTLJavaScriptParser::GetterContext>(0);
}

CHTLJavaScriptParser::SetterContext* CHTLJavaScriptParser::MethodDefinitionContext::setter() {
  return getRuleContext<CHTLJavaScriptParser::SetterContext>(0);
}

CHTLJavaScriptParser::GeneratorMethodContext* CHTLJavaScriptParser::MethodDefinitionContext::generatorMethod() {
  return getRuleContext<CHTLJavaScriptParser::GeneratorMethodContext>(0);
}

CHTLJavaScriptParser::AsyncMethodContext* CHTLJavaScriptParser::MethodDefinitionContext::asyncMethod() {
  return getRuleContext<CHTLJavaScriptParser::AsyncMethodContext>(0);
}


size_t CHTLJavaScriptParser::MethodDefinitionContext::getRuleIndex() const {
  return CHTLJavaScriptParser::RuleMethodDefinition;
}


std::any CHTLJavaScriptParser::MethodDefinitionContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<CHTLJavaScriptVisitor*>(visitor))
    return parserVisitor->visitMethodDefinition(this);
  else
    return visitor->visitChildren(this);
}

CHTLJavaScriptParser::MethodDefinitionContext* CHTLJavaScriptParser::methodDefinition() {
  MethodDefinitionContext *_localctx = _tracker.createInstance<MethodDefinitionContext>(_ctx, getState());
  enterRule(_localctx, 98, CHTLJavaScriptParser::RuleMethodDefinition);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    setState(786);
    _errHandler->sync(this);
    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 56, _ctx)) {
    case 1: {
      enterOuterAlt(_localctx, 1);
      setState(774);
      propertyName();
      setState(775);
      match(CHTLJavaScriptParser::LPAREN);
      setState(777);
      _errHandler->sync(this);

      _la = _input->LA(1);
      if (((((_la - 23) & ~ 0x3fULL) == 0) &&
        ((1ULL << (_la - 23)) & ((1ULL << (CHTLJavaScriptParser::IDENTIFIER - 23))
        | (1ULL << (CHTLJavaScriptParser::LBRACE - 23))
        | (1ULL << (CHTLJavaScriptParser::LBRACKET - 23))
        | (1ULL << (CHTLJavaScriptParser::ELLIPSIS - 23)))) != 0)) {
        setState(776);
        formalParameterList();
      }
      setState(779);
      match(CHTLJavaScriptParser::RPAREN);
      setState(780);
      block();
      break;
    }

    case 2: {
      enterOuterAlt(_localctx, 2);
      setState(782);
      getter();
      break;
    }

    case 3: {
      enterOuterAlt(_localctx, 3);
      setState(783);
      setter();
      break;
    }

    case 4: {
      enterOuterAlt(_localctx, 4);
      setState(784);
      generatorMethod();
      break;
    }

    case 5: {
      enterOuterAlt(_localctx, 5);
      setState(785);
      asyncMethod();
      break;
    }

    default:
      break;
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- GetterContext ------------------------------------------------------------------

CHTLJavaScriptParser::GetterContext::GetterContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* CHTLJavaScriptParser::GetterContext::GET() {
  return getToken(CHTLJavaScriptParser::GET, 0);
}

CHTLJavaScriptParser::PropertyNameContext* CHTLJavaScriptParser::GetterContext::propertyName() {
  return getRuleContext<CHTLJavaScriptParser::PropertyNameContext>(0);
}

tree::TerminalNode* CHTLJavaScriptParser::GetterContext::LPAREN() {
  return getToken(CHTLJavaScriptParser::LPAREN, 0);
}

tree::TerminalNode* CHTLJavaScriptParser::GetterContext::RPAREN() {
  return getToken(CHTLJavaScriptParser::RPAREN, 0);
}

CHTLJavaScriptParser::BlockContext* CHTLJavaScriptParser::GetterContext::block() {
  return getRuleContext<CHTLJavaScriptParser::BlockContext>(0);
}


size_t CHTLJavaScriptParser::GetterContext::getRuleIndex() const {
  return CHTLJavaScriptParser::RuleGetter;
}


std::any CHTLJavaScriptParser::GetterContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<CHTLJavaScriptVisitor*>(visitor))
    return parserVisitor->visitGetter(this);
  else
    return visitor->visitChildren(this);
}

CHTLJavaScriptParser::GetterContext* CHTLJavaScriptParser::getter() {
  GetterContext *_localctx = _tracker.createInstance<GetterContext>(_ctx, getState());
  enterRule(_localctx, 100, CHTLJavaScriptParser::RuleGetter);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(788);
    match(CHTLJavaScriptParser::GET);
    setState(789);
    propertyName();
    setState(790);
    match(CHTLJavaScriptParser::LPAREN);
    setState(791);
    match(CHTLJavaScriptParser::RPAREN);
    setState(792);
    block();
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- SetterContext ------------------------------------------------------------------

CHTLJavaScriptParser::SetterContext::SetterContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* CHTLJavaScriptParser::SetterContext::SET() {
  return getToken(CHTLJavaScriptParser::SET, 0);
}

CHTLJavaScriptParser::PropertyNameContext* CHTLJavaScriptParser::SetterContext::propertyName() {
  return getRuleContext<CHTLJavaScriptParser::PropertyNameContext>(0);
}

tree::TerminalNode* CHTLJavaScriptParser::SetterContext::LPAREN() {
  return getToken(CHTLJavaScriptParser::LPAREN, 0);
}

CHTLJavaScriptParser::FormalParameterListContext* CHTLJavaScriptParser::SetterContext::formalParameterList() {
  return getRuleContext<CHTLJavaScriptParser::FormalParameterListContext>(0);
}

tree::TerminalNode* CHTLJavaScriptParser::SetterContext::RPAREN() {
  return getToken(CHTLJavaScriptParser::RPAREN, 0);
}

CHTLJavaScriptParser::BlockContext* CHTLJavaScriptParser::SetterContext::block() {
  return getRuleContext<CHTLJavaScriptParser::BlockContext>(0);
}


size_t CHTLJavaScriptParser::SetterContext::getRuleIndex() const {
  return CHTLJavaScriptParser::RuleSetter;
}


std::any CHTLJavaScriptParser::SetterContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<CHTLJavaScriptVisitor*>(visitor))
    return parserVisitor->visitSetter(this);
  else
    return visitor->visitChildren(this);
}

CHTLJavaScriptParser::SetterContext* CHTLJavaScriptParser::setter() {
  SetterContext *_localctx = _tracker.createInstance<SetterContext>(_ctx, getState());
  enterRule(_localctx, 102, CHTLJavaScriptParser::RuleSetter);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(794);
    match(CHTLJavaScriptParser::SET);
    setState(795);
    propertyName();
    setState(796);
    match(CHTLJavaScriptParser::LPAREN);
    setState(797);
    formalParameterList();
    setState(798);
    match(CHTLJavaScriptParser::RPAREN);
    setState(799);
    block();
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- GeneratorMethodContext ------------------------------------------------------------------

CHTLJavaScriptParser::GeneratorMethodContext::GeneratorMethodContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* CHTLJavaScriptParser::GeneratorMethodContext::STAR() {
  return getToken(CHTLJavaScriptParser::STAR, 0);
}

CHTLJavaScriptParser::PropertyNameContext* CHTLJavaScriptParser::GeneratorMethodContext::propertyName() {
  return getRuleContext<CHTLJavaScriptParser::PropertyNameContext>(0);
}

tree::TerminalNode* CHTLJavaScriptParser::GeneratorMethodContext::LPAREN() {
  return getToken(CHTLJavaScriptParser::LPAREN, 0);
}

tree::TerminalNode* CHTLJavaScriptParser::GeneratorMethodContext::RPAREN() {
  return getToken(CHTLJavaScriptParser::RPAREN, 0);
}

CHTLJavaScriptParser::BlockContext* CHTLJavaScriptParser::GeneratorMethodContext::block() {
  return getRuleContext<CHTLJavaScriptParser::BlockContext>(0);
}

CHTLJavaScriptParser::FormalParameterListContext* CHTLJavaScriptParser::GeneratorMethodContext::formalParameterList() {
  return getRuleContext<CHTLJavaScriptParser::FormalParameterListContext>(0);
}


size_t CHTLJavaScriptParser::GeneratorMethodContext::getRuleIndex() const {
  return CHTLJavaScriptParser::RuleGeneratorMethod;
}


std::any CHTLJavaScriptParser::GeneratorMethodContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<CHTLJavaScriptVisitor*>(visitor))
    return parserVisitor->visitGeneratorMethod(this);
  else
    return visitor->visitChildren(this);
}

CHTLJavaScriptParser::GeneratorMethodContext* CHTLJavaScriptParser::generatorMethod() {
  GeneratorMethodContext *_localctx = _tracker.createInstance<GeneratorMethodContext>(_ctx, getState());
  enterRule(_localctx, 104, CHTLJavaScriptParser::RuleGeneratorMethod);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(801);
    match(CHTLJavaScriptParser::STAR);
    setState(802);
    propertyName();
    setState(803);
    match(CHTLJavaScriptParser::LPAREN);
    setState(805);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (((((_la - 23) & ~ 0x3fULL) == 0) &&
      ((1ULL << (_la - 23)) & ((1ULL << (CHTLJavaScriptParser::IDENTIFIER - 23))
      | (1ULL << (CHTLJavaScriptParser::LBRACE - 23))
      | (1ULL << (CHTLJavaScriptParser::LBRACKET - 23))
      | (1ULL << (CHTLJavaScriptParser::ELLIPSIS - 23)))) != 0)) {
      setState(804);
      formalParameterList();
    }
    setState(807);
    match(CHTLJavaScriptParser::RPAREN);
    setState(808);
    block();
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- AsyncMethodContext ------------------------------------------------------------------

CHTLJavaScriptParser::AsyncMethodContext::AsyncMethodContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* CHTLJavaScriptParser::AsyncMethodContext::ASYNC() {
  return getToken(CHTLJavaScriptParser::ASYNC, 0);
}

CHTLJavaScriptParser::PropertyNameContext* CHTLJavaScriptParser::AsyncMethodContext::propertyName() {
  return getRuleContext<CHTLJavaScriptParser::PropertyNameContext>(0);
}

tree::TerminalNode* CHTLJavaScriptParser::AsyncMethodContext::LPAREN() {
  return getToken(CHTLJavaScriptParser::LPAREN, 0);
}

tree::TerminalNode* CHTLJavaScriptParser::AsyncMethodContext::RPAREN() {
  return getToken(CHTLJavaScriptParser::RPAREN, 0);
}

CHTLJavaScriptParser::BlockContext* CHTLJavaScriptParser::AsyncMethodContext::block() {
  return getRuleContext<CHTLJavaScriptParser::BlockContext>(0);
}

CHTLJavaScriptParser::FormalParameterListContext* CHTLJavaScriptParser::AsyncMethodContext::formalParameterList() {
  return getRuleContext<CHTLJavaScriptParser::FormalParameterListContext>(0);
}


size_t CHTLJavaScriptParser::AsyncMethodContext::getRuleIndex() const {
  return CHTLJavaScriptParser::RuleAsyncMethod;
}


std::any CHTLJavaScriptParser::AsyncMethodContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<CHTLJavaScriptVisitor*>(visitor))
    return parserVisitor->visitAsyncMethod(this);
  else
    return visitor->visitChildren(this);
}

CHTLJavaScriptParser::AsyncMethodContext* CHTLJavaScriptParser::asyncMethod() {
  AsyncMethodContext *_localctx = _tracker.createInstance<AsyncMethodContext>(_ctx, getState());
  enterRule(_localctx, 106, CHTLJavaScriptParser::RuleAsyncMethod);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(810);
    match(CHTLJavaScriptParser::ASYNC);
    setState(811);
    propertyName();
    setState(812);
    match(CHTLJavaScriptParser::LPAREN);
    setState(814);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (((((_la - 23) & ~ 0x3fULL) == 0) &&
      ((1ULL << (_la - 23)) & ((1ULL << (CHTLJavaScriptParser::IDENTIFIER - 23))
      | (1ULL << (CHTLJavaScriptParser::LBRACE - 23))
      | (1ULL << (CHTLJavaScriptParser::LBRACKET - 23))
      | (1ULL << (CHTLJavaScriptParser::ELLIPSIS - 23)))) != 0)) {
      setState(813);
      formalParameterList();
    }
    setState(816);
    match(CHTLJavaScriptParser::RPAREN);
    setState(817);
    block();
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- ImportStatementContext ------------------------------------------------------------------

CHTLJavaScriptParser::ImportStatementContext::ImportStatementContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* CHTLJavaScriptParser::ImportStatementContext::IMPORT() {
  return getToken(CHTLJavaScriptParser::IMPORT, 0);
}

tree::TerminalNode* CHTLJavaScriptParser::ImportStatementContext::SEMICOLON() {
  return getToken(CHTLJavaScriptParser::SEMICOLON, 0);
}

CHTLJavaScriptParser::ImportFromBlockContext* CHTLJavaScriptParser::ImportStatementContext::importFromBlock() {
  return getRuleContext<CHTLJavaScriptParser::ImportFromBlockContext>(0);
}

tree::TerminalNode* CHTLJavaScriptParser::ImportStatementContext::STRING() {
  return getToken(CHTLJavaScriptParser::STRING, 0);
}


size_t CHTLJavaScriptParser::ImportStatementContext::getRuleIndex() const {
  return CHTLJavaScriptParser::RuleImportStatement;
}


std::any CHTLJavaScriptParser::ImportStatementContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<CHTLJavaScriptVisitor*>(visitor))
    return parserVisitor->visitImportStatement(this);
  else
    return visitor->visitChildren(this);
}

CHTLJavaScriptParser::ImportStatementContext* CHTLJavaScriptParser::importStatement() {
  ImportStatementContext *_localctx = _tracker.createInstance<ImportStatementContext>(_ctx, getState());
  enterRule(_localctx, 108, CHTLJavaScriptParser::RuleImportStatement);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(819);
    match(CHTLJavaScriptParser::IMPORT);
    setState(822);
    _errHandler->sync(this);
    switch (_input->LA(1)) {
      case CHTLJavaScriptParser::LBRACE:
      case CHTLJavaScriptParser::STAR: {
        setState(820);
        importFromBlock();
        break;
      }

      case CHTLJavaScriptParser::STRING: {
        setState(821);
        match(CHTLJavaScriptParser::STRING);
        break;
      }

    default:
      throw NoViableAltException(this);
    }
    setState(824);
    match(CHTLJavaScriptParser::SEMICOLON);
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- ImportFromBlockContext ------------------------------------------------------------------

CHTLJavaScriptParser::ImportFromBlockContext::ImportFromBlockContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* CHTLJavaScriptParser::ImportFromBlockContext::FROM() {
  return getToken(CHTLJavaScriptParser::FROM, 0);
}

tree::TerminalNode* CHTLJavaScriptParser::ImportFromBlockContext::STRING() {
  return getToken(CHTLJavaScriptParser::STRING, 0);
}

tree::TerminalNode* CHTLJavaScriptParser::ImportFromBlockContext::STAR() {
  return getToken(CHTLJavaScriptParser::STAR, 0);
}

tree::TerminalNode* CHTLJavaScriptParser::ImportFromBlockContext::AS() {
  return getToken(CHTLJavaScriptParser::AS, 0);
}

tree::TerminalNode* CHTLJavaScriptParser::ImportFromBlockContext::IDENTIFIER() {
  return getToken(CHTLJavaScriptParser::IDENTIFIER, 0);
}

CHTLJavaScriptParser::ImportNamespaceContext* CHTLJavaScriptParser::ImportFromBlockContext::importNamespace() {
  return getRuleContext<CHTLJavaScriptParser::ImportNamespaceContext>(0);
}


size_t CHTLJavaScriptParser::ImportFromBlockContext::getRuleIndex() const {
  return CHTLJavaScriptParser::RuleImportFromBlock;
}


std::any CHTLJavaScriptParser::ImportFromBlockContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<CHTLJavaScriptVisitor*>(visitor))
    return parserVisitor->visitImportFromBlock(this);
  else
    return visitor->visitChildren(this);
}

CHTLJavaScriptParser::ImportFromBlockContext* CHTLJavaScriptParser::importFromBlock() {
  ImportFromBlockContext *_localctx = _tracker.createInstance<ImportFromBlockContext>(_ctx, getState());
  enterRule(_localctx, 110, CHTLJavaScriptParser::RuleImportFromBlock);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(830);
    _errHandler->sync(this);
    switch (_input->LA(1)) {
      case CHTLJavaScriptParser::STAR: {
        setState(826);
        match(CHTLJavaScriptParser::STAR);
        setState(827);
        match(CHTLJavaScriptParser::AS);
        setState(828);
        match(CHTLJavaScriptParser::IDENTIFIER);
        break;
      }

      case CHTLJavaScriptParser::LBRACE: {
        setState(829);
        importNamespace();
        break;
      }

    default:
      throw NoViableAltException(this);
    }
    setState(832);
    match(CHTLJavaScriptParser::FROM);
    setState(833);
    match(CHTLJavaScriptParser::STRING);
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- ImportNamespaceContext ------------------------------------------------------------------

CHTLJavaScriptParser::ImportNamespaceContext::ImportNamespaceContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* CHTLJavaScriptParser::ImportNamespaceContext::LBRACE() {
  return getToken(CHTLJavaScriptParser::LBRACE, 0);
}

tree::TerminalNode* CHTLJavaScriptParser::ImportNamespaceContext::RBRACE() {
  return getToken(CHTLJavaScriptParser::RBRACE, 0);
}

std::vector<CHTLJavaScriptParser::ImportSpecifierContext *> CHTLJavaScriptParser::ImportNamespaceContext::importSpecifier() {
  return getRuleContexts<CHTLJavaScriptParser::ImportSpecifierContext>();
}

CHTLJavaScriptParser::ImportSpecifierContext* CHTLJavaScriptParser::ImportNamespaceContext::importSpecifier(size_t i) {
  return getRuleContext<CHTLJavaScriptParser::ImportSpecifierContext>(i);
}

std::vector<tree::TerminalNode *> CHTLJavaScriptParser::ImportNamespaceContext::COMMA() {
  return getTokens(CHTLJavaScriptParser::COMMA);
}

tree::TerminalNode* CHTLJavaScriptParser::ImportNamespaceContext::COMMA(size_t i) {
  return getToken(CHTLJavaScriptParser::COMMA, i);
}


size_t CHTLJavaScriptParser::ImportNamespaceContext::getRuleIndex() const {
  return CHTLJavaScriptParser::RuleImportNamespace;
}


std::any CHTLJavaScriptParser::ImportNamespaceContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<CHTLJavaScriptVisitor*>(visitor))
    return parserVisitor->visitImportNamespace(this);
  else
    return visitor->visitChildren(this);
}

CHTLJavaScriptParser::ImportNamespaceContext* CHTLJavaScriptParser::importNamespace() {
  ImportNamespaceContext *_localctx = _tracker.createInstance<ImportNamespaceContext>(_ctx, getState());
  enterRule(_localctx, 112, CHTLJavaScriptParser::RuleImportNamespace);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(835);
    match(CHTLJavaScriptParser::LBRACE);
    setState(844);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (_la == CHTLJavaScriptParser::IDENTIFIER || _la == CHTLJavaScriptParser::STRING) {
      setState(836);
      importSpecifier();
      setState(841);
      _errHandler->sync(this);
      _la = _input->LA(1);
      while (_la == CHTLJavaScriptParser::COMMA) {
        setState(837);
        match(CHTLJavaScriptParser::COMMA);
        setState(838);
        importSpecifier();
        setState(843);
        _errHandler->sync(this);
        _la = _input->LA(1);
      }
    }
    setState(846);
    match(CHTLJavaScriptParser::RBRACE);
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- ImportSpecifierContext ------------------------------------------------------------------

CHTLJavaScriptParser::ImportSpecifierContext::ImportSpecifierContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

std::vector<tree::TerminalNode *> CHTLJavaScriptParser::ImportSpecifierContext::IDENTIFIER() {
  return getTokens(CHTLJavaScriptParser::IDENTIFIER);
}

tree::TerminalNode* CHTLJavaScriptParser::ImportSpecifierContext::IDENTIFIER(size_t i) {
  return getToken(CHTLJavaScriptParser::IDENTIFIER, i);
}

CHTLJavaScriptParser::ModuleExportNameContext* CHTLJavaScriptParser::ImportSpecifierContext::moduleExportName() {
  return getRuleContext<CHTLJavaScriptParser::ModuleExportNameContext>(0);
}

tree::TerminalNode* CHTLJavaScriptParser::ImportSpecifierContext::AS() {
  return getToken(CHTLJavaScriptParser::AS, 0);
}


size_t CHTLJavaScriptParser::ImportSpecifierContext::getRuleIndex() const {
  return CHTLJavaScriptParser::RuleImportSpecifier;
}


std::any CHTLJavaScriptParser::ImportSpecifierContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<CHTLJavaScriptVisitor*>(visitor))
    return parserVisitor->visitImportSpecifier(this);
  else
    return visitor->visitChildren(this);
}

CHTLJavaScriptParser::ImportSpecifierContext* CHTLJavaScriptParser::importSpecifier() {
  ImportSpecifierContext *_localctx = _tracker.createInstance<ImportSpecifierContext>(_ctx, getState());
  enterRule(_localctx, 114, CHTLJavaScriptParser::RuleImportSpecifier);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(850);
    _errHandler->sync(this);
    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 63, _ctx)) {
    case 1: {
      setState(848);
      match(CHTLJavaScriptParser::IDENTIFIER);
      break;
    }

    case 2: {
      setState(849);
      moduleExportName();
      break;
    }

    default:
      break;
    }
    setState(854);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (_la == CHTLJavaScriptParser::AS) {
      setState(852);
      match(CHTLJavaScriptParser::AS);
      setState(853);
      match(CHTLJavaScriptParser::IDENTIFIER);
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- ModuleExportNameContext ------------------------------------------------------------------

CHTLJavaScriptParser::ModuleExportNameContext::ModuleExportNameContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* CHTLJavaScriptParser::ModuleExportNameContext::STRING() {
  return getToken(CHTLJavaScriptParser::STRING, 0);
}

tree::TerminalNode* CHTLJavaScriptParser::ModuleExportNameContext::IDENTIFIER() {
  return getToken(CHTLJavaScriptParser::IDENTIFIER, 0);
}


size_t CHTLJavaScriptParser::ModuleExportNameContext::getRuleIndex() const {
  return CHTLJavaScriptParser::RuleModuleExportName;
}


std::any CHTLJavaScriptParser::ModuleExportNameContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<CHTLJavaScriptVisitor*>(visitor))
    return parserVisitor->visitModuleExportName(this);
  else
    return visitor->visitChildren(this);
}

CHTLJavaScriptParser::ModuleExportNameContext* CHTLJavaScriptParser::moduleExportName() {
  ModuleExportNameContext *_localctx = _tracker.createInstance<ModuleExportNameContext>(_ctx, getState());
  enterRule(_localctx, 116, CHTLJavaScriptParser::RuleModuleExportName);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(856);
    _la = _input->LA(1);
    if (!(_la == CHTLJavaScriptParser::IDENTIFIER || _la == CHTLJavaScriptParser::STRING)) {
    _errHandler->recoverInline(this);
    }
    else {
      _errHandler->reportMatch(this);
      consume();
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- ExportStatementContext ------------------------------------------------------------------

CHTLJavaScriptParser::ExportStatementContext::ExportStatementContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* CHTLJavaScriptParser::ExportStatementContext::EXPORT() {
  return getToken(CHTLJavaScriptParser::EXPORT, 0);
}

tree::TerminalNode* CHTLJavaScriptParser::ExportStatementContext::SEMICOLON() {
  return getToken(CHTLJavaScriptParser::SEMICOLON, 0);
}

CHTLJavaScriptParser::ExportFromBlockContext* CHTLJavaScriptParser::ExportStatementContext::exportFromBlock() {
  return getRuleContext<CHTLJavaScriptParser::ExportFromBlockContext>(0);
}

CHTLJavaScriptParser::DeclarationContext* CHTLJavaScriptParser::ExportStatementContext::declaration() {
  return getRuleContext<CHTLJavaScriptParser::DeclarationContext>(0);
}

tree::TerminalNode* CHTLJavaScriptParser::ExportStatementContext::DEFAULT() {
  return getToken(CHTLJavaScriptParser::DEFAULT, 0);
}

CHTLJavaScriptParser::SingleExpressionContext* CHTLJavaScriptParser::ExportStatementContext::singleExpression() {
  return getRuleContext<CHTLJavaScriptParser::SingleExpressionContext>(0);
}


size_t CHTLJavaScriptParser::ExportStatementContext::getRuleIndex() const {
  return CHTLJavaScriptParser::RuleExportStatement;
}


std::any CHTLJavaScriptParser::ExportStatementContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<CHTLJavaScriptVisitor*>(visitor))
    return parserVisitor->visitExportStatement(this);
  else
    return visitor->visitChildren(this);
}

CHTLJavaScriptParser::ExportStatementContext* CHTLJavaScriptParser::exportStatement() {
  ExportStatementContext *_localctx = _tracker.createInstance<ExportStatementContext>(_ctx, getState());
  enterRule(_localctx, 118, CHTLJavaScriptParser::RuleExportStatement);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    setState(870);
    _errHandler->sync(this);
    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 66, _ctx)) {
    case 1: {
      enterOuterAlt(_localctx, 1);
      setState(858);
      match(CHTLJavaScriptParser::EXPORT);
      setState(861);
      _errHandler->sync(this);
      switch (_input->LA(1)) {
        case CHTLJavaScriptParser::LBRACE:
        case CHTLJavaScriptParser::STAR: {
          setState(859);
          exportFromBlock();
          break;
        }

        case CHTLJavaScriptParser::VAR:
        case CHTLJavaScriptParser::FUNCTION:
        case CHTLJavaScriptParser::CLASS:
        case CHTLJavaScriptParser::CONST:
        case CHTLJavaScriptParser::ASYNC:
        case CHTLJavaScriptParser::LET: {
          setState(860);
          declaration();
          break;
        }

      default:
        throw NoViableAltException(this);
      }
      setState(863);
      match(CHTLJavaScriptParser::SEMICOLON);
      break;
    }

    case 2: {
      enterOuterAlt(_localctx, 2);
      setState(865);
      match(CHTLJavaScriptParser::EXPORT);
      setState(866);
      match(CHTLJavaScriptParser::DEFAULT);
      setState(867);
      singleExpression(0);
      setState(868);
      match(CHTLJavaScriptParser::SEMICOLON);
      break;
    }

    default:
      break;
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- ExportFromBlockContext ------------------------------------------------------------------

CHTLJavaScriptParser::ExportFromBlockContext::ExportFromBlockContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* CHTLJavaScriptParser::ExportFromBlockContext::FROM() {
  return getToken(CHTLJavaScriptParser::FROM, 0);
}

tree::TerminalNode* CHTLJavaScriptParser::ExportFromBlockContext::STRING() {
  return getToken(CHTLJavaScriptParser::STRING, 0);
}

tree::TerminalNode* CHTLJavaScriptParser::ExportFromBlockContext::STAR() {
  return getToken(CHTLJavaScriptParser::STAR, 0);
}

CHTLJavaScriptParser::ExportNamespaceContext* CHTLJavaScriptParser::ExportFromBlockContext::exportNamespace() {
  return getRuleContext<CHTLJavaScriptParser::ExportNamespaceContext>(0);
}


size_t CHTLJavaScriptParser::ExportFromBlockContext::getRuleIndex() const {
  return CHTLJavaScriptParser::RuleExportFromBlock;
}


std::any CHTLJavaScriptParser::ExportFromBlockContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<CHTLJavaScriptVisitor*>(visitor))
    return parserVisitor->visitExportFromBlock(this);
  else
    return visitor->visitChildren(this);
}

CHTLJavaScriptParser::ExportFromBlockContext* CHTLJavaScriptParser::exportFromBlock() {
  ExportFromBlockContext *_localctx = _tracker.createInstance<ExportFromBlockContext>(_ctx, getState());
  enterRule(_localctx, 120, CHTLJavaScriptParser::RuleExportFromBlock);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(874);
    _errHandler->sync(this);
    switch (_input->LA(1)) {
      case CHTLJavaScriptParser::STAR: {
        setState(872);
        match(CHTLJavaScriptParser::STAR);
        break;
      }

      case CHTLJavaScriptParser::LBRACE: {
        setState(873);
        exportNamespace();
        break;
      }

    default:
      throw NoViableAltException(this);
    }
    setState(876);
    match(CHTLJavaScriptParser::FROM);
    setState(877);
    match(CHTLJavaScriptParser::STRING);
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- ExportNamespaceContext ------------------------------------------------------------------

CHTLJavaScriptParser::ExportNamespaceContext::ExportNamespaceContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* CHTLJavaScriptParser::ExportNamespaceContext::LBRACE() {
  return getToken(CHTLJavaScriptParser::LBRACE, 0);
}

tree::TerminalNode* CHTLJavaScriptParser::ExportNamespaceContext::RBRACE() {
  return getToken(CHTLJavaScriptParser::RBRACE, 0);
}

std::vector<CHTLJavaScriptParser::ExportSpecifierContext *> CHTLJavaScriptParser::ExportNamespaceContext::exportSpecifier() {
  return getRuleContexts<CHTLJavaScriptParser::ExportSpecifierContext>();
}

CHTLJavaScriptParser::ExportSpecifierContext* CHTLJavaScriptParser::ExportNamespaceContext::exportSpecifier(size_t i) {
  return getRuleContext<CHTLJavaScriptParser::ExportSpecifierContext>(i);
}

std::vector<tree::TerminalNode *> CHTLJavaScriptParser::ExportNamespaceContext::COMMA() {
  return getTokens(CHTLJavaScriptParser::COMMA);
}

tree::TerminalNode* CHTLJavaScriptParser::ExportNamespaceContext::COMMA(size_t i) {
  return getToken(CHTLJavaScriptParser::COMMA, i);
}


size_t CHTLJavaScriptParser::ExportNamespaceContext::getRuleIndex() const {
  return CHTLJavaScriptParser::RuleExportNamespace;
}


std::any CHTLJavaScriptParser::ExportNamespaceContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<CHTLJavaScriptVisitor*>(visitor))
    return parserVisitor->visitExportNamespace(this);
  else
    return visitor->visitChildren(this);
}

CHTLJavaScriptParser::ExportNamespaceContext* CHTLJavaScriptParser::exportNamespace() {
  ExportNamespaceContext *_localctx = _tracker.createInstance<ExportNamespaceContext>(_ctx, getState());
  enterRule(_localctx, 122, CHTLJavaScriptParser::RuleExportNamespace);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(879);
    match(CHTLJavaScriptParser::LBRACE);
    setState(888);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (_la == CHTLJavaScriptParser::IDENTIFIER || _la == CHTLJavaScriptParser::STRING) {
      setState(880);
      exportSpecifier();
      setState(885);
      _errHandler->sync(this);
      _la = _input->LA(1);
      while (_la == CHTLJavaScriptParser::COMMA) {
        setState(881);
        match(CHTLJavaScriptParser::COMMA);
        setState(882);
        exportSpecifier();
        setState(887);
        _errHandler->sync(this);
        _la = _input->LA(1);
      }
    }
    setState(890);
    match(CHTLJavaScriptParser::RBRACE);
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- ExportSpecifierContext ------------------------------------------------------------------

CHTLJavaScriptParser::ExportSpecifierContext::ExportSpecifierContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* CHTLJavaScriptParser::ExportSpecifierContext::IDENTIFIER() {
  return getToken(CHTLJavaScriptParser::IDENTIFIER, 0);
}

std::vector<CHTLJavaScriptParser::ModuleExportNameContext *> CHTLJavaScriptParser::ExportSpecifierContext::moduleExportName() {
  return getRuleContexts<CHTLJavaScriptParser::ModuleExportNameContext>();
}

CHTLJavaScriptParser::ModuleExportNameContext* CHTLJavaScriptParser::ExportSpecifierContext::moduleExportName(size_t i) {
  return getRuleContext<CHTLJavaScriptParser::ModuleExportNameContext>(i);
}

tree::TerminalNode* CHTLJavaScriptParser::ExportSpecifierContext::AS() {
  return getToken(CHTLJavaScriptParser::AS, 0);
}


size_t CHTLJavaScriptParser::ExportSpecifierContext::getRuleIndex() const {
  return CHTLJavaScriptParser::RuleExportSpecifier;
}


std::any CHTLJavaScriptParser::ExportSpecifierContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<CHTLJavaScriptVisitor*>(visitor))
    return parserVisitor->visitExportSpecifier(this);
  else
    return visitor->visitChildren(this);
}

CHTLJavaScriptParser::ExportSpecifierContext* CHTLJavaScriptParser::exportSpecifier() {
  ExportSpecifierContext *_localctx = _tracker.createInstance<ExportSpecifierContext>(_ctx, getState());
  enterRule(_localctx, 124, CHTLJavaScriptParser::RuleExportSpecifier);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(894);
    _errHandler->sync(this);
    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 70, _ctx)) {
    case 1: {
      setState(892);
      match(CHTLJavaScriptParser::IDENTIFIER);
      break;
    }

    case 2: {
      setState(893);
      moduleExportName();
      break;
    }

    default:
      break;
    }
    setState(898);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (_la == CHTLJavaScriptParser::AS) {
      setState(896);
      match(CHTLJavaScriptParser::AS);
      setState(897);
      moduleExportName();
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- DeclarationContext ------------------------------------------------------------------

CHTLJavaScriptParser::DeclarationContext::DeclarationContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

CHTLJavaScriptParser::VariableStatementContext* CHTLJavaScriptParser::DeclarationContext::variableStatement() {
  return getRuleContext<CHTLJavaScriptParser::VariableStatementContext>(0);
}

CHTLJavaScriptParser::ClassDeclarationContext* CHTLJavaScriptParser::DeclarationContext::classDeclaration() {
  return getRuleContext<CHTLJavaScriptParser::ClassDeclarationContext>(0);
}

CHTLJavaScriptParser::FunctionDeclarationContext* CHTLJavaScriptParser::DeclarationContext::functionDeclaration() {
  return getRuleContext<CHTLJavaScriptParser::FunctionDeclarationContext>(0);
}


size_t CHTLJavaScriptParser::DeclarationContext::getRuleIndex() const {
  return CHTLJavaScriptParser::RuleDeclaration;
}


std::any CHTLJavaScriptParser::DeclarationContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<CHTLJavaScriptVisitor*>(visitor))
    return parserVisitor->visitDeclaration(this);
  else
    return visitor->visitChildren(this);
}

CHTLJavaScriptParser::DeclarationContext* CHTLJavaScriptParser::declaration() {
  DeclarationContext *_localctx = _tracker.createInstance<DeclarationContext>(_ctx, getState());
  enterRule(_localctx, 126, CHTLJavaScriptParser::RuleDeclaration);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    setState(903);
    _errHandler->sync(this);
    switch (_input->LA(1)) {
      case CHTLJavaScriptParser::VAR:
      case CHTLJavaScriptParser::CONST:
      case CHTLJavaScriptParser::LET: {
        enterOuterAlt(_localctx, 1);
        setState(900);
        variableStatement();
        break;
      }

      case CHTLJavaScriptParser::CLASS: {
        enterOuterAlt(_localctx, 2);
        setState(901);
        classDeclaration();
        break;
      }

      case CHTLJavaScriptParser::FUNCTION:
      case CHTLJavaScriptParser::ASYNC: {
        enterOuterAlt(_localctx, 3);
        setState(902);
        functionDeclaration();
        break;
      }

    default:
      throw NoViableAltException(this);
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- FormalParameterListContext ------------------------------------------------------------------

CHTLJavaScriptParser::FormalParameterListContext::FormalParameterListContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

std::vector<CHTLJavaScriptParser::FormalParameterContext *> CHTLJavaScriptParser::FormalParameterListContext::formalParameter() {
  return getRuleContexts<CHTLJavaScriptParser::FormalParameterContext>();
}

CHTLJavaScriptParser::FormalParameterContext* CHTLJavaScriptParser::FormalParameterListContext::formalParameter(size_t i) {
  return getRuleContext<CHTLJavaScriptParser::FormalParameterContext>(i);
}

std::vector<tree::TerminalNode *> CHTLJavaScriptParser::FormalParameterListContext::COMMA() {
  return getTokens(CHTLJavaScriptParser::COMMA);
}

tree::TerminalNode* CHTLJavaScriptParser::FormalParameterListContext::COMMA(size_t i) {
  return getToken(CHTLJavaScriptParser::COMMA, i);
}

CHTLJavaScriptParser::RestParameterContext* CHTLJavaScriptParser::FormalParameterListContext::restParameter() {
  return getRuleContext<CHTLJavaScriptParser::RestParameterContext>(0);
}


size_t CHTLJavaScriptParser::FormalParameterListContext::getRuleIndex() const {
  return CHTLJavaScriptParser::RuleFormalParameterList;
}


std::any CHTLJavaScriptParser::FormalParameterListContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<CHTLJavaScriptVisitor*>(visitor))
    return parserVisitor->visitFormalParameterList(this);
  else
    return visitor->visitChildren(this);
}

CHTLJavaScriptParser::FormalParameterListContext* CHTLJavaScriptParser::formalParameterList() {
  FormalParameterListContext *_localctx = _tracker.createInstance<FormalParameterListContext>(_ctx, getState());
  enterRule(_localctx, 128, CHTLJavaScriptParser::RuleFormalParameterList);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    size_t alt;
    setState(918);
    _errHandler->sync(this);
    switch (_input->LA(1)) {
      case CHTLJavaScriptParser::IDENTIFIER:
      case CHTLJavaScriptParser::LBRACE:
      case CHTLJavaScriptParser::LBRACKET: {
        enterOuterAlt(_localctx, 1);
        setState(905);
        formalParameter();
        setState(910);
        _errHandler->sync(this);
        alt = getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 73, _ctx);
        while (alt != 2 && alt != atn::ATN::INVALID_ALT_NUMBER) {
          if (alt == 1) {
            setState(906);
            match(CHTLJavaScriptParser::COMMA);
            setState(907);
            formalParameter(); 
          }
          setState(912);
          _errHandler->sync(this);
          alt = getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 73, _ctx);
        }
        setState(915);
        _errHandler->sync(this);

        _la = _input->LA(1);
        if (_la == CHTLJavaScriptParser::COMMA) {
          setState(913);
          match(CHTLJavaScriptParser::COMMA);
          setState(914);
          restParameter();
        }
        break;
      }

      case CHTLJavaScriptParser::ELLIPSIS: {
        enterOuterAlt(_localctx, 2);
        setState(917);
        restParameter();
        break;
      }

    default:
      throw NoViableAltException(this);
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- FormalParameterContext ------------------------------------------------------------------

CHTLJavaScriptParser::FormalParameterContext::FormalParameterContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

CHTLJavaScriptParser::AssignableContext* CHTLJavaScriptParser::FormalParameterContext::assignable() {
  return getRuleContext<CHTLJavaScriptParser::AssignableContext>(0);
}

tree::TerminalNode* CHTLJavaScriptParser::FormalParameterContext::EQUALS() {
  return getToken(CHTLJavaScriptParser::EQUALS, 0);
}

CHTLJavaScriptParser::SingleExpressionContext* CHTLJavaScriptParser::FormalParameterContext::singleExpression() {
  return getRuleContext<CHTLJavaScriptParser::SingleExpressionContext>(0);
}


size_t CHTLJavaScriptParser::FormalParameterContext::getRuleIndex() const {
  return CHTLJavaScriptParser::RuleFormalParameter;
}


std::any CHTLJavaScriptParser::FormalParameterContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<CHTLJavaScriptVisitor*>(visitor))
    return parserVisitor->visitFormalParameter(this);
  else
    return visitor->visitChildren(this);
}

CHTLJavaScriptParser::FormalParameterContext* CHTLJavaScriptParser::formalParameter() {
  FormalParameterContext *_localctx = _tracker.createInstance<FormalParameterContext>(_ctx, getState());
  enterRule(_localctx, 130, CHTLJavaScriptParser::RuleFormalParameter);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(920);
    assignable();
    setState(923);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (_la == CHTLJavaScriptParser::EQUALS) {
      setState(921);
      match(CHTLJavaScriptParser::EQUALS);
      setState(922);
      singleExpression(0);
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- RestParameterContext ------------------------------------------------------------------

CHTLJavaScriptParser::RestParameterContext::RestParameterContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* CHTLJavaScriptParser::RestParameterContext::ELLIPSIS() {
  return getToken(CHTLJavaScriptParser::ELLIPSIS, 0);
}

CHTLJavaScriptParser::AssignableContext* CHTLJavaScriptParser::RestParameterContext::assignable() {
  return getRuleContext<CHTLJavaScriptParser::AssignableContext>(0);
}


size_t CHTLJavaScriptParser::RestParameterContext::getRuleIndex() const {
  return CHTLJavaScriptParser::RuleRestParameter;
}


std::any CHTLJavaScriptParser::RestParameterContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<CHTLJavaScriptVisitor*>(visitor))
    return parserVisitor->visitRestParameter(this);
  else
    return visitor->visitChildren(this);
}

CHTLJavaScriptParser::RestParameterContext* CHTLJavaScriptParser::restParameter() {
  RestParameterContext *_localctx = _tracker.createInstance<RestParameterContext>(_ctx, getState());
  enterRule(_localctx, 132, CHTLJavaScriptParser::RuleRestParameter);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(925);
    match(CHTLJavaScriptParser::ELLIPSIS);
    setState(926);
    assignable();
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- AssignableContext ------------------------------------------------------------------

CHTLJavaScriptParser::AssignableContext::AssignableContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* CHTLJavaScriptParser::AssignableContext::IDENTIFIER() {
  return getToken(CHTLJavaScriptParser::IDENTIFIER, 0);
}

CHTLJavaScriptParser::ArrayLiteralContext* CHTLJavaScriptParser::AssignableContext::arrayLiteral() {
  return getRuleContext<CHTLJavaScriptParser::ArrayLiteralContext>(0);
}

CHTLJavaScriptParser::ObjectLiteralContext* CHTLJavaScriptParser::AssignableContext::objectLiteral() {
  return getRuleContext<CHTLJavaScriptParser::ObjectLiteralContext>(0);
}


size_t CHTLJavaScriptParser::AssignableContext::getRuleIndex() const {
  return CHTLJavaScriptParser::RuleAssignable;
}


std::any CHTLJavaScriptParser::AssignableContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<CHTLJavaScriptVisitor*>(visitor))
    return parserVisitor->visitAssignable(this);
  else
    return visitor->visitChildren(this);
}

CHTLJavaScriptParser::AssignableContext* CHTLJavaScriptParser::assignable() {
  AssignableContext *_localctx = _tracker.createInstance<AssignableContext>(_ctx, getState());
  enterRule(_localctx, 134, CHTLJavaScriptParser::RuleAssignable);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    setState(931);
    _errHandler->sync(this);
    switch (_input->LA(1)) {
      case CHTLJavaScriptParser::IDENTIFIER: {
        enterOuterAlt(_localctx, 1);
        setState(928);
        match(CHTLJavaScriptParser::IDENTIFIER);
        break;
      }

      case CHTLJavaScriptParser::LBRACKET: {
        enterOuterAlt(_localctx, 2);
        setState(929);
        arrayLiteral();
        break;
      }

      case CHTLJavaScriptParser::LBRACE: {
        enterOuterAlt(_localctx, 3);
        setState(930);
        objectLiteral();
        break;
      }

    default:
      throw NoViableAltException(this);
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- PropertyNameContext ------------------------------------------------------------------

CHTLJavaScriptParser::PropertyNameContext::PropertyNameContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

CHTLJavaScriptParser::IdentifierNameContext* CHTLJavaScriptParser::PropertyNameContext::identifierName() {
  return getRuleContext<CHTLJavaScriptParser::IdentifierNameContext>(0);
}

tree::TerminalNode* CHTLJavaScriptParser::PropertyNameContext::STRING() {
  return getToken(CHTLJavaScriptParser::STRING, 0);
}

tree::TerminalNode* CHTLJavaScriptParser::PropertyNameContext::NUMBER() {
  return getToken(CHTLJavaScriptParser::NUMBER, 0);
}

tree::TerminalNode* CHTLJavaScriptParser::PropertyNameContext::LBRACKET() {
  return getToken(CHTLJavaScriptParser::LBRACKET, 0);
}

CHTLJavaScriptParser::SingleExpressionContext* CHTLJavaScriptParser::PropertyNameContext::singleExpression() {
  return getRuleContext<CHTLJavaScriptParser::SingleExpressionContext>(0);
}

tree::TerminalNode* CHTLJavaScriptParser::PropertyNameContext::RBRACKET() {
  return getToken(CHTLJavaScriptParser::RBRACKET, 0);
}


size_t CHTLJavaScriptParser::PropertyNameContext::getRuleIndex() const {
  return CHTLJavaScriptParser::RulePropertyName;
}


std::any CHTLJavaScriptParser::PropertyNameContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<CHTLJavaScriptVisitor*>(visitor))
    return parserVisitor->visitPropertyName(this);
  else
    return visitor->visitChildren(this);
}

CHTLJavaScriptParser::PropertyNameContext* CHTLJavaScriptParser::propertyName() {
  PropertyNameContext *_localctx = _tracker.createInstance<PropertyNameContext>(_ctx, getState());
  enterRule(_localctx, 136, CHTLJavaScriptParser::RulePropertyName);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    setState(940);
    _errHandler->sync(this);
    switch (_input->LA(1)) {
      case CHTLJavaScriptParser::IDENTIFIER:
      case CHTLJavaScriptParser::BREAK:
      case CHTLJavaScriptParser::DO:
      case CHTLJavaScriptParser::INSTANCEOF:
      case CHTLJavaScriptParser::TYPEOF:
      case CHTLJavaScriptParser::CASE:
      case CHTLJavaScriptParser::ELSE:
      case CHTLJavaScriptParser::NEW:
      case CHTLJavaScriptParser::VAR:
      case CHTLJavaScriptParser::CATCH:
      case CHTLJavaScriptParser::FINALLY:
      case CHTLJavaScriptParser::RETURN:
      case CHTLJavaScriptParser::VOID:
      case CHTLJavaScriptParser::CONTINUE:
      case CHTLJavaScriptParser::FOR:
      case CHTLJavaScriptParser::SWITCH:
      case CHTLJavaScriptParser::WHILE:
      case CHTLJavaScriptParser::DEBUGGER:
      case CHTLJavaScriptParser::FUNCTION:
      case CHTLJavaScriptParser::THIS:
      case CHTLJavaScriptParser::WITH:
      case CHTLJavaScriptParser::DEFAULT:
      case CHTLJavaScriptParser::IF:
      case CHTLJavaScriptParser::THROW:
      case CHTLJavaScriptParser::DELETE:
      case CHTLJavaScriptParser::IN:
      case CHTLJavaScriptParser::TRY:
      case CHTLJavaScriptParser::CLASS:
      case CHTLJavaScriptParser::ENUM:
      case CHTLJavaScriptParser::EXTENDS:
      case CHTLJavaScriptParser::SUPER:
      case CHTLJavaScriptParser::CONST:
      case CHTLJavaScriptParser::EXPORT:
      case CHTLJavaScriptParser::IMPORT:
      case CHTLJavaScriptParser::ASYNC:
      case CHTLJavaScriptParser::AWAIT:
      case CHTLJavaScriptParser::YIELD:
      case CHTLJavaScriptParser::LET:
      case CHTLJavaScriptParser::STATIC:
      case CHTLJavaScriptParser::FROM:
      case CHTLJavaScriptParser::AS:
      case CHTLJavaScriptParser::OF:
      case CHTLJavaScriptParser::NULL_LITERAL:
      case CHTLJavaScriptParser::BOOLEAN: {
        enterOuterAlt(_localctx, 1);
        setState(933);
        identifierName();
        break;
      }

      case CHTLJavaScriptParser::STRING: {
        enterOuterAlt(_localctx, 2);
        setState(934);
        match(CHTLJavaScriptParser::STRING);
        break;
      }

      case CHTLJavaScriptParser::NUMBER: {
        enterOuterAlt(_localctx, 3);
        setState(935);
        match(CHTLJavaScriptParser::NUMBER);
        break;
      }

      case CHTLJavaScriptParser::LBRACKET: {
        enterOuterAlt(_localctx, 4);
        setState(936);
        match(CHTLJavaScriptParser::LBRACKET);
        setState(937);
        singleExpression(0);
        setState(938);
        match(CHTLJavaScriptParser::RBRACKET);
        break;
      }

    default:
      throw NoViableAltException(this);
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- ExpressionSequenceContext ------------------------------------------------------------------

CHTLJavaScriptParser::ExpressionSequenceContext::ExpressionSequenceContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

std::vector<CHTLJavaScriptParser::SingleExpressionContext *> CHTLJavaScriptParser::ExpressionSequenceContext::singleExpression() {
  return getRuleContexts<CHTLJavaScriptParser::SingleExpressionContext>();
}

CHTLJavaScriptParser::SingleExpressionContext* CHTLJavaScriptParser::ExpressionSequenceContext::singleExpression(size_t i) {
  return getRuleContext<CHTLJavaScriptParser::SingleExpressionContext>(i);
}

std::vector<tree::TerminalNode *> CHTLJavaScriptParser::ExpressionSequenceContext::COMMA() {
  return getTokens(CHTLJavaScriptParser::COMMA);
}

tree::TerminalNode* CHTLJavaScriptParser::ExpressionSequenceContext::COMMA(size_t i) {
  return getToken(CHTLJavaScriptParser::COMMA, i);
}


size_t CHTLJavaScriptParser::ExpressionSequenceContext::getRuleIndex() const {
  return CHTLJavaScriptParser::RuleExpressionSequence;
}


std::any CHTLJavaScriptParser::ExpressionSequenceContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<CHTLJavaScriptVisitor*>(visitor))
    return parserVisitor->visitExpressionSequence(this);
  else
    return visitor->visitChildren(this);
}

CHTLJavaScriptParser::ExpressionSequenceContext* CHTLJavaScriptParser::expressionSequence() {
  ExpressionSequenceContext *_localctx = _tracker.createInstance<ExpressionSequenceContext>(_ctx, getState());
  enterRule(_localctx, 138, CHTLJavaScriptParser::RuleExpressionSequence);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(942);
    singleExpression(0);
    setState(947);
    _errHandler->sync(this);
    _la = _input->LA(1);
    while (_la == CHTLJavaScriptParser::COMMA) {
      setState(943);
      match(CHTLJavaScriptParser::COMMA);
      setState(944);
      singleExpression(0);
      setState(949);
      _errHandler->sync(this);
      _la = _input->LA(1);
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- AssignmentOperatorContext ------------------------------------------------------------------

CHTLJavaScriptParser::AssignmentOperatorContext::AssignmentOperatorContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* CHTLJavaScriptParser::AssignmentOperatorContext::STAR_EQUALS() {
  return getToken(CHTLJavaScriptParser::STAR_EQUALS, 0);
}

tree::TerminalNode* CHTLJavaScriptParser::AssignmentOperatorContext::SLASH_EQUALS() {
  return getToken(CHTLJavaScriptParser::SLASH_EQUALS, 0);
}

tree::TerminalNode* CHTLJavaScriptParser::AssignmentOperatorContext::PERCENT_EQUALS() {
  return getToken(CHTLJavaScriptParser::PERCENT_EQUALS, 0);
}

tree::TerminalNode* CHTLJavaScriptParser::AssignmentOperatorContext::PLUS_EQUALS() {
  return getToken(CHTLJavaScriptParser::PLUS_EQUALS, 0);
}

tree::TerminalNode* CHTLJavaScriptParser::AssignmentOperatorContext::MINUS_EQUALS() {
  return getToken(CHTLJavaScriptParser::MINUS_EQUALS, 0);
}

tree::TerminalNode* CHTLJavaScriptParser::AssignmentOperatorContext::LSHIFT_EQUALS() {
  return getToken(CHTLJavaScriptParser::LSHIFT_EQUALS, 0);
}

tree::TerminalNode* CHTLJavaScriptParser::AssignmentOperatorContext::RSHIFT_EQUALS() {
  return getToken(CHTLJavaScriptParser::RSHIFT_EQUALS, 0);
}

tree::TerminalNode* CHTLJavaScriptParser::AssignmentOperatorContext::URSHIFT_EQUALS() {
  return getToken(CHTLJavaScriptParser::URSHIFT_EQUALS, 0);
}

tree::TerminalNode* CHTLJavaScriptParser::AssignmentOperatorContext::AMPERSAND_EQUALS() {
  return getToken(CHTLJavaScriptParser::AMPERSAND_EQUALS, 0);
}

tree::TerminalNode* CHTLJavaScriptParser::AssignmentOperatorContext::CARET_EQUALS() {
  return getToken(CHTLJavaScriptParser::CARET_EQUALS, 0);
}

tree::TerminalNode* CHTLJavaScriptParser::AssignmentOperatorContext::PIPE_EQUALS() {
  return getToken(CHTLJavaScriptParser::PIPE_EQUALS, 0);
}

tree::TerminalNode* CHTLJavaScriptParser::AssignmentOperatorContext::POWER_EQUALS() {
  return getToken(CHTLJavaScriptParser::POWER_EQUALS, 0);
}

tree::TerminalNode* CHTLJavaScriptParser::AssignmentOperatorContext::NULLISH_EQUALS() {
  return getToken(CHTLJavaScriptParser::NULLISH_EQUALS, 0);
}


size_t CHTLJavaScriptParser::AssignmentOperatorContext::getRuleIndex() const {
  return CHTLJavaScriptParser::RuleAssignmentOperator;
}


std::any CHTLJavaScriptParser::AssignmentOperatorContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<CHTLJavaScriptVisitor*>(visitor))
    return parserVisitor->visitAssignmentOperator(this);
  else
    return visitor->visitChildren(this);
}

CHTLJavaScriptParser::AssignmentOperatorContext* CHTLJavaScriptParser::assignmentOperator() {
  AssignmentOperatorContext *_localctx = _tracker.createInstance<AssignmentOperatorContext>(_ctx, getState());
  enterRule(_localctx, 140, CHTLJavaScriptParser::RuleAssignmentOperator);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(950);
    _la = _input->LA(1);
    if (!(((((_la - 86) & ~ 0x3fULL) == 0) &&
      ((1ULL << (_la - 86)) & ((1ULL << (CHTLJavaScriptParser::STAR_EQUALS - 86))
      | (1ULL << (CHTLJavaScriptParser::SLASH_EQUALS - 86))
      | (1ULL << (CHTLJavaScriptParser::PERCENT_EQUALS - 86))
      | (1ULL << (CHTLJavaScriptParser::PLUS_EQUALS - 86))
      | (1ULL << (CHTLJavaScriptParser::MINUS_EQUALS - 86))
      | (1ULL << (CHTLJavaScriptParser::LSHIFT_EQUALS - 86))
      | (1ULL << (CHTLJavaScriptParser::RSHIFT_EQUALS - 86))
      | (1ULL << (CHTLJavaScriptParser::URSHIFT_EQUALS - 86))
      | (1ULL << (CHTLJavaScriptParser::AMPERSAND_EQUALS - 86))
      | (1ULL << (CHTLJavaScriptParser::CARET_EQUALS - 86))
      | (1ULL << (CHTLJavaScriptParser::PIPE_EQUALS - 86))
      | (1ULL << (CHTLJavaScriptParser::POWER_EQUALS - 86))
      | (1ULL << (CHTLJavaScriptParser::NULLISH_EQUALS - 86)))) != 0))) {
    _errHandler->recoverInline(this);
    }
    else {
      _errHandler->reportMatch(this);
      consume();
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- ArrayLiteralContext ------------------------------------------------------------------

CHTLJavaScriptParser::ArrayLiteralContext::ArrayLiteralContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* CHTLJavaScriptParser::ArrayLiteralContext::LBRACKET() {
  return getToken(CHTLJavaScriptParser::LBRACKET, 0);
}

tree::TerminalNode* CHTLJavaScriptParser::ArrayLiteralContext::RBRACKET() {
  return getToken(CHTLJavaScriptParser::RBRACKET, 0);
}

CHTLJavaScriptParser::ElementListContext* CHTLJavaScriptParser::ArrayLiteralContext::elementList() {
  return getRuleContext<CHTLJavaScriptParser::ElementListContext>(0);
}


size_t CHTLJavaScriptParser::ArrayLiteralContext::getRuleIndex() const {
  return CHTLJavaScriptParser::RuleArrayLiteral;
}


std::any CHTLJavaScriptParser::ArrayLiteralContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<CHTLJavaScriptVisitor*>(visitor))
    return parserVisitor->visitArrayLiteral(this);
  else
    return visitor->visitChildren(this);
}

CHTLJavaScriptParser::ArrayLiteralContext* CHTLJavaScriptParser::arrayLiteral() {
  ArrayLiteralContext *_localctx = _tracker.createInstance<ArrayLiteralContext>(_ctx, getState());
  enterRule(_localctx, 142, CHTLJavaScriptParser::RuleArrayLiteral);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(952);
    match(CHTLJavaScriptParser::LBRACKET);
    setState(954);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if ((((_la & ~ 0x3fULL) == 0) &&
      ((1ULL << _la) & ((1ULL << CHTLJavaScriptParser::CHTL_SELECTOR_START)
      | (1ULL << CHTLJavaScriptParser::ANIMATE)
      | (1ULL << CHTLJavaScriptParser::TEMPLATE_STRING)
      | (1ULL << CHTLJavaScriptParser::IDENTIFIER)
      | (1ULL << CHTLJavaScriptParser::TYPEOF)
      | (1ULL << CHTLJavaScriptParser::NEW)
      | (1ULL << CHTLJavaScriptParser::VOID)
      | (1ULL << CHTLJavaScriptParser::FUNCTION)
      | (1ULL << CHTLJavaScriptParser::THIS)
      | (1ULL << CHTLJavaScriptParser::DELETE)
      | (1ULL << CHTLJavaScriptParser::SUPER)
      | (1ULL << CHTLJavaScriptParser::ASYNC)
      | (1ULL << CHTLJavaScriptParser::AWAIT))) != 0) || ((((_la - 70) & ~ 0x3fULL) == 0) &&
      ((1ULL << (_la - 70)) & ((1ULL << (CHTLJavaScriptParser::NULL_LITERAL - 70))
      | (1ULL << (CHTLJavaScriptParser::BOOLEAN - 70))
      | (1ULL << (CHTLJavaScriptParser::UNDEFINED - 70))
      | (1ULL << (CHTLJavaScriptParser::LPAREN - 70))
      | (1ULL << (CHTLJavaScriptParser::LBRACE - 70))
      | (1ULL << (CHTLJavaScriptParser::LBRACKET - 70))
      | (1ULL << (CHTLJavaScriptParser::COMMA - 70))
      | (1ULL << (CHTLJavaScriptParser::ELLIPSIS - 70))
      | (1ULL << (CHTLJavaScriptParser::PLUSPLUS - 70))
      | (1ULL << (CHTLJavaScriptParser::MINUSMINUS - 70))
      | (1ULL << (CHTLJavaScriptParser::PLUS - 70))
      | (1ULL << (CHTLJavaScriptParser::MINUS - 70))
      | (1ULL << (CHTLJavaScriptParser::TILDE - 70))
      | (1ULL << (CHTLJavaScriptParser::EXCLAMATION - 70))
      | (1ULL << (CHTLJavaScriptParser::NUMBER - 70))
      | (1ULL << (CHTLJavaScriptParser::STRING - 70)))) != 0)) {
      setState(953);
      elementList();
    }
    setState(956);
    match(CHTLJavaScriptParser::RBRACKET);
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- ElementListContext ------------------------------------------------------------------

CHTLJavaScriptParser::ElementListContext::ElementListContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

std::vector<CHTLJavaScriptParser::ArrayElementContext *> CHTLJavaScriptParser::ElementListContext::arrayElement() {
  return getRuleContexts<CHTLJavaScriptParser::ArrayElementContext>();
}

CHTLJavaScriptParser::ArrayElementContext* CHTLJavaScriptParser::ElementListContext::arrayElement(size_t i) {
  return getRuleContext<CHTLJavaScriptParser::ArrayElementContext>(i);
}

std::vector<tree::TerminalNode *> CHTLJavaScriptParser::ElementListContext::COMMA() {
  return getTokens(CHTLJavaScriptParser::COMMA);
}

tree::TerminalNode* CHTLJavaScriptParser::ElementListContext::COMMA(size_t i) {
  return getToken(CHTLJavaScriptParser::COMMA, i);
}


size_t CHTLJavaScriptParser::ElementListContext::getRuleIndex() const {
  return CHTLJavaScriptParser::RuleElementList;
}


std::any CHTLJavaScriptParser::ElementListContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<CHTLJavaScriptVisitor*>(visitor))
    return parserVisitor->visitElementList(this);
  else
    return visitor->visitChildren(this);
}

CHTLJavaScriptParser::ElementListContext* CHTLJavaScriptParser::elementList() {
  ElementListContext *_localctx = _tracker.createInstance<ElementListContext>(_ctx, getState());
  enterRule(_localctx, 144, CHTLJavaScriptParser::RuleElementList);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(958);
    arrayElement();
    setState(963);
    _errHandler->sync(this);
    _la = _input->LA(1);
    while (_la == CHTLJavaScriptParser::COMMA) {
      setState(959);
      match(CHTLJavaScriptParser::COMMA);
      setState(960);
      arrayElement();
      setState(965);
      _errHandler->sync(this);
      _la = _input->LA(1);
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- ArrayElementContext ------------------------------------------------------------------

CHTLJavaScriptParser::ArrayElementContext::ArrayElementContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

CHTLJavaScriptParser::SingleExpressionContext* CHTLJavaScriptParser::ArrayElementContext::singleExpression() {
  return getRuleContext<CHTLJavaScriptParser::SingleExpressionContext>(0);
}

tree::TerminalNode* CHTLJavaScriptParser::ArrayElementContext::ELLIPSIS() {
  return getToken(CHTLJavaScriptParser::ELLIPSIS, 0);
}

tree::TerminalNode* CHTLJavaScriptParser::ArrayElementContext::COMMA() {
  return getToken(CHTLJavaScriptParser::COMMA, 0);
}


size_t CHTLJavaScriptParser::ArrayElementContext::getRuleIndex() const {
  return CHTLJavaScriptParser::RuleArrayElement;
}


std::any CHTLJavaScriptParser::ArrayElementContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<CHTLJavaScriptVisitor*>(visitor))
    return parserVisitor->visitArrayElement(this);
  else
    return visitor->visitChildren(this);
}

CHTLJavaScriptParser::ArrayElementContext* CHTLJavaScriptParser::arrayElement() {
  ArrayElementContext *_localctx = _tracker.createInstance<ArrayElementContext>(_ctx, getState());
  enterRule(_localctx, 146, CHTLJavaScriptParser::RuleArrayElement);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    setState(971);
    _errHandler->sync(this);
    switch (_input->LA(1)) {
      case CHTLJavaScriptParser::CHTL_SELECTOR_START:
      case CHTLJavaScriptParser::ANIMATE:
      case CHTLJavaScriptParser::TEMPLATE_STRING:
      case CHTLJavaScriptParser::IDENTIFIER:
      case CHTLJavaScriptParser::TYPEOF:
      case CHTLJavaScriptParser::NEW:
      case CHTLJavaScriptParser::VOID:
      case CHTLJavaScriptParser::FUNCTION:
      case CHTLJavaScriptParser::THIS:
      case CHTLJavaScriptParser::DELETE:
      case CHTLJavaScriptParser::SUPER:
      case CHTLJavaScriptParser::ASYNC:
      case CHTLJavaScriptParser::AWAIT:
      case CHTLJavaScriptParser::NULL_LITERAL:
      case CHTLJavaScriptParser::BOOLEAN:
      case CHTLJavaScriptParser::UNDEFINED:
      case CHTLJavaScriptParser::LPAREN:
      case CHTLJavaScriptParser::LBRACE:
      case CHTLJavaScriptParser::LBRACKET:
      case CHTLJavaScriptParser::ELLIPSIS:
      case CHTLJavaScriptParser::PLUSPLUS:
      case CHTLJavaScriptParser::MINUSMINUS:
      case CHTLJavaScriptParser::PLUS:
      case CHTLJavaScriptParser::MINUS:
      case CHTLJavaScriptParser::TILDE:
      case CHTLJavaScriptParser::EXCLAMATION:
      case CHTLJavaScriptParser::NUMBER:
      case CHTLJavaScriptParser::STRING: {
        enterOuterAlt(_localctx, 1);
        setState(967);
        _errHandler->sync(this);

        _la = _input->LA(1);
        if (_la == CHTLJavaScriptParser::ELLIPSIS) {
          setState(966);
          match(CHTLJavaScriptParser::ELLIPSIS);
        }
        setState(969);
        singleExpression(0);
        break;
      }

      case CHTLJavaScriptParser::COMMA: {
        enterOuterAlt(_localctx, 2);
        setState(970);
        match(CHTLJavaScriptParser::COMMA);
        break;
      }

    default:
      throw NoViableAltException(this);
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- ObjectLiteralContext ------------------------------------------------------------------

CHTLJavaScriptParser::ObjectLiteralContext::ObjectLiteralContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* CHTLJavaScriptParser::ObjectLiteralContext::LBRACE() {
  return getToken(CHTLJavaScriptParser::LBRACE, 0);
}

std::vector<CHTLJavaScriptParser::PropertyAssignmentContext *> CHTLJavaScriptParser::ObjectLiteralContext::propertyAssignment() {
  return getRuleContexts<CHTLJavaScriptParser::PropertyAssignmentContext>();
}

CHTLJavaScriptParser::PropertyAssignmentContext* CHTLJavaScriptParser::ObjectLiteralContext::propertyAssignment(size_t i) {
  return getRuleContext<CHTLJavaScriptParser::PropertyAssignmentContext>(i);
}

tree::TerminalNode* CHTLJavaScriptParser::ObjectLiteralContext::RBRACE() {
  return getToken(CHTLJavaScriptParser::RBRACE, 0);
}

std::vector<tree::TerminalNode *> CHTLJavaScriptParser::ObjectLiteralContext::COMMA() {
  return getTokens(CHTLJavaScriptParser::COMMA);
}

tree::TerminalNode* CHTLJavaScriptParser::ObjectLiteralContext::COMMA(size_t i) {
  return getToken(CHTLJavaScriptParser::COMMA, i);
}


size_t CHTLJavaScriptParser::ObjectLiteralContext::getRuleIndex() const {
  return CHTLJavaScriptParser::RuleObjectLiteral;
}


std::any CHTLJavaScriptParser::ObjectLiteralContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<CHTLJavaScriptVisitor*>(visitor))
    return parserVisitor->visitObjectLiteral(this);
  else
    return visitor->visitChildren(this);
}

CHTLJavaScriptParser::ObjectLiteralContext* CHTLJavaScriptParser::objectLiteral() {
  ObjectLiteralContext *_localctx = _tracker.createInstance<ObjectLiteralContext>(_ctx, getState());
  enterRule(_localctx, 148, CHTLJavaScriptParser::RuleObjectLiteral);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    size_t alt;
    enterOuterAlt(_localctx, 1);
    setState(973);
    match(CHTLJavaScriptParser::LBRACE);
    setState(974);
    propertyAssignment();
    setState(979);
    _errHandler->sync(this);
    alt = getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 84, _ctx);
    while (alt != 2 && alt != atn::ATN::INVALID_ALT_NUMBER) {
      if (alt == 1) {
        setState(975);
        match(CHTLJavaScriptParser::COMMA);
        setState(976);
        propertyAssignment(); 
      }
      setState(981);
      _errHandler->sync(this);
      alt = getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 84, _ctx);
    }
    setState(983);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (_la == CHTLJavaScriptParser::COMMA) {
      setState(982);
      match(CHTLJavaScriptParser::COMMA);
    }
    setState(985);
    match(CHTLJavaScriptParser::RBRACE);
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- PropertyAssignmentContext ------------------------------------------------------------------

CHTLJavaScriptParser::PropertyAssignmentContext::PropertyAssignmentContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

CHTLJavaScriptParser::PropertyNameContext* CHTLJavaScriptParser::PropertyAssignmentContext::propertyName() {
  return getRuleContext<CHTLJavaScriptParser::PropertyNameContext>(0);
}

tree::TerminalNode* CHTLJavaScriptParser::PropertyAssignmentContext::COLON() {
  return getToken(CHTLJavaScriptParser::COLON, 0);
}

std::vector<CHTLJavaScriptParser::SingleExpressionContext *> CHTLJavaScriptParser::PropertyAssignmentContext::singleExpression() {
  return getRuleContexts<CHTLJavaScriptParser::SingleExpressionContext>();
}

CHTLJavaScriptParser::SingleExpressionContext* CHTLJavaScriptParser::PropertyAssignmentContext::singleExpression(size_t i) {
  return getRuleContext<CHTLJavaScriptParser::SingleExpressionContext>(i);
}

tree::TerminalNode* CHTLJavaScriptParser::PropertyAssignmentContext::LBRACKET() {
  return getToken(CHTLJavaScriptParser::LBRACKET, 0);
}

tree::TerminalNode* CHTLJavaScriptParser::PropertyAssignmentContext::RBRACKET() {
  return getToken(CHTLJavaScriptParser::RBRACKET, 0);
}

CHTLJavaScriptParser::MethodDefinitionContext* CHTLJavaScriptParser::PropertyAssignmentContext::methodDefinition() {
  return getRuleContext<CHTLJavaScriptParser::MethodDefinitionContext>(0);
}

tree::TerminalNode* CHTLJavaScriptParser::PropertyAssignmentContext::IDENTIFIER() {
  return getToken(CHTLJavaScriptParser::IDENTIFIER, 0);
}

tree::TerminalNode* CHTLJavaScriptParser::PropertyAssignmentContext::ELLIPSIS() {
  return getToken(CHTLJavaScriptParser::ELLIPSIS, 0);
}


size_t CHTLJavaScriptParser::PropertyAssignmentContext::getRuleIndex() const {
  return CHTLJavaScriptParser::RulePropertyAssignment;
}


std::any CHTLJavaScriptParser::PropertyAssignmentContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<CHTLJavaScriptVisitor*>(visitor))
    return parserVisitor->visitPropertyAssignment(this);
  else
    return visitor->visitChildren(this);
}

CHTLJavaScriptParser::PropertyAssignmentContext* CHTLJavaScriptParser::propertyAssignment() {
  PropertyAssignmentContext *_localctx = _tracker.createInstance<PropertyAssignmentContext>(_ctx, getState());
  enterRule(_localctx, 150, CHTLJavaScriptParser::RulePropertyAssignment);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    setState(1001);
    _errHandler->sync(this);
    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 86, _ctx)) {
    case 1: {
      enterOuterAlt(_localctx, 1);
      setState(987);
      propertyName();
      setState(988);
      match(CHTLJavaScriptParser::COLON);
      setState(989);
      singleExpression(0);
      break;
    }

    case 2: {
      enterOuterAlt(_localctx, 2);
      setState(991);
      match(CHTLJavaScriptParser::LBRACKET);
      setState(992);
      singleExpression(0);
      setState(993);
      match(CHTLJavaScriptParser::RBRACKET);
      setState(994);
      match(CHTLJavaScriptParser::COLON);
      setState(995);
      singleExpression(0);
      break;
    }

    case 3: {
      enterOuterAlt(_localctx, 3);
      setState(997);
      methodDefinition();
      break;
    }

    case 4: {
      enterOuterAlt(_localctx, 4);
      setState(998);
      match(CHTLJavaScriptParser::IDENTIFIER);
      break;
    }

    case 5: {
      enterOuterAlt(_localctx, 5);
      setState(999);
      match(CHTLJavaScriptParser::ELLIPSIS);
      setState(1000);
      singleExpression(0);
      break;
    }

    default:
      break;
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- ArgumentsContext ------------------------------------------------------------------

CHTLJavaScriptParser::ArgumentsContext::ArgumentsContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* CHTLJavaScriptParser::ArgumentsContext::LPAREN() {
  return getToken(CHTLJavaScriptParser::LPAREN, 0);
}

tree::TerminalNode* CHTLJavaScriptParser::ArgumentsContext::RPAREN() {
  return getToken(CHTLJavaScriptParser::RPAREN, 0);
}

CHTLJavaScriptParser::ArgumentListContext* CHTLJavaScriptParser::ArgumentsContext::argumentList() {
  return getRuleContext<CHTLJavaScriptParser::ArgumentListContext>(0);
}


size_t CHTLJavaScriptParser::ArgumentsContext::getRuleIndex() const {
  return CHTLJavaScriptParser::RuleArguments;
}


std::any CHTLJavaScriptParser::ArgumentsContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<CHTLJavaScriptVisitor*>(visitor))
    return parserVisitor->visitArguments(this);
  else
    return visitor->visitChildren(this);
}

CHTLJavaScriptParser::ArgumentsContext* CHTLJavaScriptParser::arguments() {
  ArgumentsContext *_localctx = _tracker.createInstance<ArgumentsContext>(_ctx, getState());
  enterRule(_localctx, 152, CHTLJavaScriptParser::RuleArguments);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(1003);
    match(CHTLJavaScriptParser::LPAREN);
    setState(1005);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if ((((_la & ~ 0x3fULL) == 0) &&
      ((1ULL << _la) & ((1ULL << CHTLJavaScriptParser::CHTL_SELECTOR_START)
      | (1ULL << CHTLJavaScriptParser::ANIMATE)
      | (1ULL << CHTLJavaScriptParser::TEMPLATE_STRING)
      | (1ULL << CHTLJavaScriptParser::IDENTIFIER)
      | (1ULL << CHTLJavaScriptParser::TYPEOF)
      | (1ULL << CHTLJavaScriptParser::NEW)
      | (1ULL << CHTLJavaScriptParser::VOID)
      | (1ULL << CHTLJavaScriptParser::FUNCTION)
      | (1ULL << CHTLJavaScriptParser::THIS)
      | (1ULL << CHTLJavaScriptParser::DELETE)
      | (1ULL << CHTLJavaScriptParser::SUPER)
      | (1ULL << CHTLJavaScriptParser::ASYNC)
      | (1ULL << CHTLJavaScriptParser::AWAIT))) != 0) || ((((_la - 70) & ~ 0x3fULL) == 0) &&
      ((1ULL << (_la - 70)) & ((1ULL << (CHTLJavaScriptParser::NULL_LITERAL - 70))
      | (1ULL << (CHTLJavaScriptParser::BOOLEAN - 70))
      | (1ULL << (CHTLJavaScriptParser::UNDEFINED - 70))
      | (1ULL << (CHTLJavaScriptParser::LPAREN - 70))
      | (1ULL << (CHTLJavaScriptParser::LBRACE - 70))
      | (1ULL << (CHTLJavaScriptParser::LBRACKET - 70))
      | (1ULL << (CHTLJavaScriptParser::ELLIPSIS - 70))
      | (1ULL << (CHTLJavaScriptParser::PLUSPLUS - 70))
      | (1ULL << (CHTLJavaScriptParser::MINUSMINUS - 70))
      | (1ULL << (CHTLJavaScriptParser::PLUS - 70))
      | (1ULL << (CHTLJavaScriptParser::MINUS - 70))
      | (1ULL << (CHTLJavaScriptParser::TILDE - 70))
      | (1ULL << (CHTLJavaScriptParser::EXCLAMATION - 70))
      | (1ULL << (CHTLJavaScriptParser::NUMBER - 70))
      | (1ULL << (CHTLJavaScriptParser::STRING - 70)))) != 0)) {
      setState(1004);
      argumentList();
    }
    setState(1007);
    match(CHTLJavaScriptParser::RPAREN);
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- ArgumentListContext ------------------------------------------------------------------

CHTLJavaScriptParser::ArgumentListContext::ArgumentListContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

std::vector<CHTLJavaScriptParser::ArgumentContext *> CHTLJavaScriptParser::ArgumentListContext::argument() {
  return getRuleContexts<CHTLJavaScriptParser::ArgumentContext>();
}

CHTLJavaScriptParser::ArgumentContext* CHTLJavaScriptParser::ArgumentListContext::argument(size_t i) {
  return getRuleContext<CHTLJavaScriptParser::ArgumentContext>(i);
}

std::vector<tree::TerminalNode *> CHTLJavaScriptParser::ArgumentListContext::COMMA() {
  return getTokens(CHTLJavaScriptParser::COMMA);
}

tree::TerminalNode* CHTLJavaScriptParser::ArgumentListContext::COMMA(size_t i) {
  return getToken(CHTLJavaScriptParser::COMMA, i);
}


size_t CHTLJavaScriptParser::ArgumentListContext::getRuleIndex() const {
  return CHTLJavaScriptParser::RuleArgumentList;
}


std::any CHTLJavaScriptParser::ArgumentListContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<CHTLJavaScriptVisitor*>(visitor))
    return parserVisitor->visitArgumentList(this);
  else
    return visitor->visitChildren(this);
}

CHTLJavaScriptParser::ArgumentListContext* CHTLJavaScriptParser::argumentList() {
  ArgumentListContext *_localctx = _tracker.createInstance<ArgumentListContext>(_ctx, getState());
  enterRule(_localctx, 154, CHTLJavaScriptParser::RuleArgumentList);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(1009);
    argument();
    setState(1014);
    _errHandler->sync(this);
    _la = _input->LA(1);
    while (_la == CHTLJavaScriptParser::COMMA) {
      setState(1010);
      match(CHTLJavaScriptParser::COMMA);
      setState(1011);
      argument();
      setState(1016);
      _errHandler->sync(this);
      _la = _input->LA(1);
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- ArgumentContext ------------------------------------------------------------------

CHTLJavaScriptParser::ArgumentContext::ArgumentContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

CHTLJavaScriptParser::SingleExpressionContext* CHTLJavaScriptParser::ArgumentContext::singleExpression() {
  return getRuleContext<CHTLJavaScriptParser::SingleExpressionContext>(0);
}

tree::TerminalNode* CHTLJavaScriptParser::ArgumentContext::ELLIPSIS() {
  return getToken(CHTLJavaScriptParser::ELLIPSIS, 0);
}


size_t CHTLJavaScriptParser::ArgumentContext::getRuleIndex() const {
  return CHTLJavaScriptParser::RuleArgument;
}


std::any CHTLJavaScriptParser::ArgumentContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<CHTLJavaScriptVisitor*>(visitor))
    return parserVisitor->visitArgument(this);
  else
    return visitor->visitChildren(this);
}

CHTLJavaScriptParser::ArgumentContext* CHTLJavaScriptParser::argument() {
  ArgumentContext *_localctx = _tracker.createInstance<ArgumentContext>(_ctx, getState());
  enterRule(_localctx, 156, CHTLJavaScriptParser::RuleArgument);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(1018);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (_la == CHTLJavaScriptParser::ELLIPSIS) {
      setState(1017);
      match(CHTLJavaScriptParser::ELLIPSIS);
    }
    setState(1020);
    singleExpression(0);
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- AnonymousFunctionContext ------------------------------------------------------------------

CHTLJavaScriptParser::AnonymousFunctionContext::AnonymousFunctionContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* CHTLJavaScriptParser::AnonymousFunctionContext::FUNCTION() {
  return getToken(CHTLJavaScriptParser::FUNCTION, 0);
}

tree::TerminalNode* CHTLJavaScriptParser::AnonymousFunctionContext::LPAREN() {
  return getToken(CHTLJavaScriptParser::LPAREN, 0);
}

tree::TerminalNode* CHTLJavaScriptParser::AnonymousFunctionContext::RPAREN() {
  return getToken(CHTLJavaScriptParser::RPAREN, 0);
}

CHTLJavaScriptParser::BlockContext* CHTLJavaScriptParser::AnonymousFunctionContext::block() {
  return getRuleContext<CHTLJavaScriptParser::BlockContext>(0);
}

tree::TerminalNode* CHTLJavaScriptParser::AnonymousFunctionContext::ASYNC() {
  return getToken(CHTLJavaScriptParser::ASYNC, 0);
}

tree::TerminalNode* CHTLJavaScriptParser::AnonymousFunctionContext::STAR() {
  return getToken(CHTLJavaScriptParser::STAR, 0);
}

CHTLJavaScriptParser::FormalParameterListContext* CHTLJavaScriptParser::AnonymousFunctionContext::formalParameterList() {
  return getRuleContext<CHTLJavaScriptParser::FormalParameterListContext>(0);
}


size_t CHTLJavaScriptParser::AnonymousFunctionContext::getRuleIndex() const {
  return CHTLJavaScriptParser::RuleAnonymousFunction;
}


std::any CHTLJavaScriptParser::AnonymousFunctionContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<CHTLJavaScriptVisitor*>(visitor))
    return parserVisitor->visitAnonymousFunction(this);
  else
    return visitor->visitChildren(this);
}

CHTLJavaScriptParser::AnonymousFunctionContext* CHTLJavaScriptParser::anonymousFunction() {
  AnonymousFunctionContext *_localctx = _tracker.createInstance<AnonymousFunctionContext>(_ctx, getState());
  enterRule(_localctx, 158, CHTLJavaScriptParser::RuleAnonymousFunction);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(1023);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (_la == CHTLJavaScriptParser::ASYNC) {
      setState(1022);
      match(CHTLJavaScriptParser::ASYNC);
    }
    setState(1025);
    match(CHTLJavaScriptParser::FUNCTION);
    setState(1027);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (_la == CHTLJavaScriptParser::STAR) {
      setState(1026);
      match(CHTLJavaScriptParser::STAR);
    }
    setState(1029);
    match(CHTLJavaScriptParser::LPAREN);
    setState(1031);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (((((_la - 23) & ~ 0x3fULL) == 0) &&
      ((1ULL << (_la - 23)) & ((1ULL << (CHTLJavaScriptParser::IDENTIFIER - 23))
      | (1ULL << (CHTLJavaScriptParser::LBRACE - 23))
      | (1ULL << (CHTLJavaScriptParser::LBRACKET - 23))
      | (1ULL << (CHTLJavaScriptParser::ELLIPSIS - 23)))) != 0)) {
      setState(1030);
      formalParameterList();
    }
    setState(1033);
    match(CHTLJavaScriptParser::RPAREN);
    setState(1034);
    block();
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- ArrowFunctionContext ------------------------------------------------------------------

CHTLJavaScriptParser::ArrowFunctionContext::ArrowFunctionContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

CHTLJavaScriptParser::ArrowFunctionParametersContext* CHTLJavaScriptParser::ArrowFunctionContext::arrowFunctionParameters() {
  return getRuleContext<CHTLJavaScriptParser::ArrowFunctionParametersContext>(0);
}

tree::TerminalNode* CHTLJavaScriptParser::ArrowFunctionContext::ARROW() {
  return getToken(CHTLJavaScriptParser::ARROW, 0);
}

CHTLJavaScriptParser::ArrowFunctionBodyContext* CHTLJavaScriptParser::ArrowFunctionContext::arrowFunctionBody() {
  return getRuleContext<CHTLJavaScriptParser::ArrowFunctionBodyContext>(0);
}

tree::TerminalNode* CHTLJavaScriptParser::ArrowFunctionContext::ASYNC() {
  return getToken(CHTLJavaScriptParser::ASYNC, 0);
}


size_t CHTLJavaScriptParser::ArrowFunctionContext::getRuleIndex() const {
  return CHTLJavaScriptParser::RuleArrowFunction;
}


std::any CHTLJavaScriptParser::ArrowFunctionContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<CHTLJavaScriptVisitor*>(visitor))
    return parserVisitor->visitArrowFunction(this);
  else
    return visitor->visitChildren(this);
}

CHTLJavaScriptParser::ArrowFunctionContext* CHTLJavaScriptParser::arrowFunction() {
  ArrowFunctionContext *_localctx = _tracker.createInstance<ArrowFunctionContext>(_ctx, getState());
  enterRule(_localctx, 160, CHTLJavaScriptParser::RuleArrowFunction);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(1037);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (_la == CHTLJavaScriptParser::ASYNC) {
      setState(1036);
      match(CHTLJavaScriptParser::ASYNC);
    }
    setState(1039);
    arrowFunctionParameters();
    setState(1040);
    match(CHTLJavaScriptParser::ARROW);
    setState(1041);
    arrowFunctionBody();
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- ArrowFunctionParametersContext ------------------------------------------------------------------

CHTLJavaScriptParser::ArrowFunctionParametersContext::ArrowFunctionParametersContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* CHTLJavaScriptParser::ArrowFunctionParametersContext::IDENTIFIER() {
  return getToken(CHTLJavaScriptParser::IDENTIFIER, 0);
}

tree::TerminalNode* CHTLJavaScriptParser::ArrowFunctionParametersContext::LPAREN() {
  return getToken(CHTLJavaScriptParser::LPAREN, 0);
}

tree::TerminalNode* CHTLJavaScriptParser::ArrowFunctionParametersContext::RPAREN() {
  return getToken(CHTLJavaScriptParser::RPAREN, 0);
}

CHTLJavaScriptParser::FormalParameterListContext* CHTLJavaScriptParser::ArrowFunctionParametersContext::formalParameterList() {
  return getRuleContext<CHTLJavaScriptParser::FormalParameterListContext>(0);
}


size_t CHTLJavaScriptParser::ArrowFunctionParametersContext::getRuleIndex() const {
  return CHTLJavaScriptParser::RuleArrowFunctionParameters;
}


std::any CHTLJavaScriptParser::ArrowFunctionParametersContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<CHTLJavaScriptVisitor*>(visitor))
    return parserVisitor->visitArrowFunctionParameters(this);
  else
    return visitor->visitChildren(this);
}

CHTLJavaScriptParser::ArrowFunctionParametersContext* CHTLJavaScriptParser::arrowFunctionParameters() {
  ArrowFunctionParametersContext *_localctx = _tracker.createInstance<ArrowFunctionParametersContext>(_ctx, getState());
  enterRule(_localctx, 162, CHTLJavaScriptParser::RuleArrowFunctionParameters);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    setState(1049);
    _errHandler->sync(this);
    switch (_input->LA(1)) {
      case CHTLJavaScriptParser::IDENTIFIER: {
        enterOuterAlt(_localctx, 1);
        setState(1043);
        match(CHTLJavaScriptParser::IDENTIFIER);
        break;
      }

      case CHTLJavaScriptParser::LPAREN: {
        enterOuterAlt(_localctx, 2);
        setState(1044);
        match(CHTLJavaScriptParser::LPAREN);
        setState(1046);
        _errHandler->sync(this);

        _la = _input->LA(1);
        if (((((_la - 23) & ~ 0x3fULL) == 0) &&
          ((1ULL << (_la - 23)) & ((1ULL << (CHTLJavaScriptParser::IDENTIFIER - 23))
          | (1ULL << (CHTLJavaScriptParser::LBRACE - 23))
          | (1ULL << (CHTLJavaScriptParser::LBRACKET - 23))
          | (1ULL << (CHTLJavaScriptParser::ELLIPSIS - 23)))) != 0)) {
          setState(1045);
          formalParameterList();
        }
        setState(1048);
        match(CHTLJavaScriptParser::RPAREN);
        break;
      }

    default:
      throw NoViableAltException(this);
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- ArrowFunctionBodyContext ------------------------------------------------------------------

CHTLJavaScriptParser::ArrowFunctionBodyContext::ArrowFunctionBodyContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

CHTLJavaScriptParser::SingleExpressionContext* CHTLJavaScriptParser::ArrowFunctionBodyContext::singleExpression() {
  return getRuleContext<CHTLJavaScriptParser::SingleExpressionContext>(0);
}

CHTLJavaScriptParser::BlockContext* CHTLJavaScriptParser::ArrowFunctionBodyContext::block() {
  return getRuleContext<CHTLJavaScriptParser::BlockContext>(0);
}


size_t CHTLJavaScriptParser::ArrowFunctionBodyContext::getRuleIndex() const {
  return CHTLJavaScriptParser::RuleArrowFunctionBody;
}


std::any CHTLJavaScriptParser::ArrowFunctionBodyContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<CHTLJavaScriptVisitor*>(visitor))
    return parserVisitor->visitArrowFunctionBody(this);
  else
    return visitor->visitChildren(this);
}

CHTLJavaScriptParser::ArrowFunctionBodyContext* CHTLJavaScriptParser::arrowFunctionBody() {
  ArrowFunctionBodyContext *_localctx = _tracker.createInstance<ArrowFunctionBodyContext>(_ctx, getState());
  enterRule(_localctx, 164, CHTLJavaScriptParser::RuleArrowFunctionBody);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    setState(1053);
    _errHandler->sync(this);
    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 96, _ctx)) {
    case 1: {
      enterOuterAlt(_localctx, 1);
      setState(1051);
      singleExpression(0);
      break;
    }

    case 2: {
      enterOuterAlt(_localctx, 2);
      setState(1052);
      block();
      break;
    }

    default:
      break;
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- TypeofExpressionContext ------------------------------------------------------------------

CHTLJavaScriptParser::TypeofExpressionContext::TypeofExpressionContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* CHTLJavaScriptParser::TypeofExpressionContext::TYPEOF() {
  return getToken(CHTLJavaScriptParser::TYPEOF, 0);
}

CHTLJavaScriptParser::SingleExpressionContext* CHTLJavaScriptParser::TypeofExpressionContext::singleExpression() {
  return getRuleContext<CHTLJavaScriptParser::SingleExpressionContext>(0);
}


size_t CHTLJavaScriptParser::TypeofExpressionContext::getRuleIndex() const {
  return CHTLJavaScriptParser::RuleTypeofExpression;
}


std::any CHTLJavaScriptParser::TypeofExpressionContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<CHTLJavaScriptVisitor*>(visitor))
    return parserVisitor->visitTypeofExpression(this);
  else
    return visitor->visitChildren(this);
}

CHTLJavaScriptParser::TypeofExpressionContext* CHTLJavaScriptParser::typeofExpression() {
  TypeofExpressionContext *_localctx = _tracker.createInstance<TypeofExpressionContext>(_ctx, getState());
  enterRule(_localctx, 166, CHTLJavaScriptParser::RuleTypeofExpression);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(1055);
    match(CHTLJavaScriptParser::TYPEOF);
    setState(1056);
    singleExpression(0);
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- IdentifierNameContext ------------------------------------------------------------------

CHTLJavaScriptParser::IdentifierNameContext::IdentifierNameContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* CHTLJavaScriptParser::IdentifierNameContext::IDENTIFIER() {
  return getToken(CHTLJavaScriptParser::IDENTIFIER, 0);
}

CHTLJavaScriptParser::ReservedWordContext* CHTLJavaScriptParser::IdentifierNameContext::reservedWord() {
  return getRuleContext<CHTLJavaScriptParser::ReservedWordContext>(0);
}


size_t CHTLJavaScriptParser::IdentifierNameContext::getRuleIndex() const {
  return CHTLJavaScriptParser::RuleIdentifierName;
}


std::any CHTLJavaScriptParser::IdentifierNameContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<CHTLJavaScriptVisitor*>(visitor))
    return parserVisitor->visitIdentifierName(this);
  else
    return visitor->visitChildren(this);
}

CHTLJavaScriptParser::IdentifierNameContext* CHTLJavaScriptParser::identifierName() {
  IdentifierNameContext *_localctx = _tracker.createInstance<IdentifierNameContext>(_ctx, getState());
  enterRule(_localctx, 168, CHTLJavaScriptParser::RuleIdentifierName);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    setState(1060);
    _errHandler->sync(this);
    switch (_input->LA(1)) {
      case CHTLJavaScriptParser::IDENTIFIER: {
        enterOuterAlt(_localctx, 1);
        setState(1058);
        match(CHTLJavaScriptParser::IDENTIFIER);
        break;
      }

      case CHTLJavaScriptParser::BREAK:
      case CHTLJavaScriptParser::DO:
      case CHTLJavaScriptParser::INSTANCEOF:
      case CHTLJavaScriptParser::TYPEOF:
      case CHTLJavaScriptParser::CASE:
      case CHTLJavaScriptParser::ELSE:
      case CHTLJavaScriptParser::NEW:
      case CHTLJavaScriptParser::VAR:
      case CHTLJavaScriptParser::CATCH:
      case CHTLJavaScriptParser::FINALLY:
      case CHTLJavaScriptParser::RETURN:
      case CHTLJavaScriptParser::VOID:
      case CHTLJavaScriptParser::CONTINUE:
      case CHTLJavaScriptParser::FOR:
      case CHTLJavaScriptParser::SWITCH:
      case CHTLJavaScriptParser::WHILE:
      case CHTLJavaScriptParser::DEBUGGER:
      case CHTLJavaScriptParser::FUNCTION:
      case CHTLJavaScriptParser::THIS:
      case CHTLJavaScriptParser::WITH:
      case CHTLJavaScriptParser::DEFAULT:
      case CHTLJavaScriptParser::IF:
      case CHTLJavaScriptParser::THROW:
      case CHTLJavaScriptParser::DELETE:
      case CHTLJavaScriptParser::IN:
      case CHTLJavaScriptParser::TRY:
      case CHTLJavaScriptParser::CLASS:
      case CHTLJavaScriptParser::ENUM:
      case CHTLJavaScriptParser::EXTENDS:
      case CHTLJavaScriptParser::SUPER:
      case CHTLJavaScriptParser::CONST:
      case CHTLJavaScriptParser::EXPORT:
      case CHTLJavaScriptParser::IMPORT:
      case CHTLJavaScriptParser::ASYNC:
      case CHTLJavaScriptParser::AWAIT:
      case CHTLJavaScriptParser::YIELD:
      case CHTLJavaScriptParser::LET:
      case CHTLJavaScriptParser::STATIC:
      case CHTLJavaScriptParser::FROM:
      case CHTLJavaScriptParser::AS:
      case CHTLJavaScriptParser::OF:
      case CHTLJavaScriptParser::NULL_LITERAL:
      case CHTLJavaScriptParser::BOOLEAN: {
        enterOuterAlt(_localctx, 2);
        setState(1059);
        reservedWord();
        break;
      }

    default:
      throw NoViableAltException(this);
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- ReservedWordContext ------------------------------------------------------------------

CHTLJavaScriptParser::ReservedWordContext::ReservedWordContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

CHTLJavaScriptParser::KeywordContext* CHTLJavaScriptParser::ReservedWordContext::keyword() {
  return getRuleContext<CHTLJavaScriptParser::KeywordContext>(0);
}

tree::TerminalNode* CHTLJavaScriptParser::ReservedWordContext::NULL_LITERAL() {
  return getToken(CHTLJavaScriptParser::NULL_LITERAL, 0);
}

tree::TerminalNode* CHTLJavaScriptParser::ReservedWordContext::BOOLEAN() {
  return getToken(CHTLJavaScriptParser::BOOLEAN, 0);
}


size_t CHTLJavaScriptParser::ReservedWordContext::getRuleIndex() const {
  return CHTLJavaScriptParser::RuleReservedWord;
}


std::any CHTLJavaScriptParser::ReservedWordContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<CHTLJavaScriptVisitor*>(visitor))
    return parserVisitor->visitReservedWord(this);
  else
    return visitor->visitChildren(this);
}

CHTLJavaScriptParser::ReservedWordContext* CHTLJavaScriptParser::reservedWord() {
  ReservedWordContext *_localctx = _tracker.createInstance<ReservedWordContext>(_ctx, getState());
  enterRule(_localctx, 170, CHTLJavaScriptParser::RuleReservedWord);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    setState(1065);
    _errHandler->sync(this);
    switch (_input->LA(1)) {
      case CHTLJavaScriptParser::BREAK:
      case CHTLJavaScriptParser::DO:
      case CHTLJavaScriptParser::INSTANCEOF:
      case CHTLJavaScriptParser::TYPEOF:
      case CHTLJavaScriptParser::CASE:
      case CHTLJavaScriptParser::ELSE:
      case CHTLJavaScriptParser::NEW:
      case CHTLJavaScriptParser::VAR:
      case CHTLJavaScriptParser::CATCH:
      case CHTLJavaScriptParser::FINALLY:
      case CHTLJavaScriptParser::RETURN:
      case CHTLJavaScriptParser::VOID:
      case CHTLJavaScriptParser::CONTINUE:
      case CHTLJavaScriptParser::FOR:
      case CHTLJavaScriptParser::SWITCH:
      case CHTLJavaScriptParser::WHILE:
      case CHTLJavaScriptParser::DEBUGGER:
      case CHTLJavaScriptParser::FUNCTION:
      case CHTLJavaScriptParser::THIS:
      case CHTLJavaScriptParser::WITH:
      case CHTLJavaScriptParser::DEFAULT:
      case CHTLJavaScriptParser::IF:
      case CHTLJavaScriptParser::THROW:
      case CHTLJavaScriptParser::DELETE:
      case CHTLJavaScriptParser::IN:
      case CHTLJavaScriptParser::TRY:
      case CHTLJavaScriptParser::CLASS:
      case CHTLJavaScriptParser::ENUM:
      case CHTLJavaScriptParser::EXTENDS:
      case CHTLJavaScriptParser::SUPER:
      case CHTLJavaScriptParser::CONST:
      case CHTLJavaScriptParser::EXPORT:
      case CHTLJavaScriptParser::IMPORT:
      case CHTLJavaScriptParser::ASYNC:
      case CHTLJavaScriptParser::AWAIT:
      case CHTLJavaScriptParser::YIELD:
      case CHTLJavaScriptParser::LET:
      case CHTLJavaScriptParser::STATIC:
      case CHTLJavaScriptParser::FROM:
      case CHTLJavaScriptParser::AS:
      case CHTLJavaScriptParser::OF: {
        enterOuterAlt(_localctx, 1);
        setState(1062);
        keyword();
        break;
      }

      case CHTLJavaScriptParser::NULL_LITERAL: {
        enterOuterAlt(_localctx, 2);
        setState(1063);
        match(CHTLJavaScriptParser::NULL_LITERAL);
        break;
      }

      case CHTLJavaScriptParser::BOOLEAN: {
        enterOuterAlt(_localctx, 3);
        setState(1064);
        match(CHTLJavaScriptParser::BOOLEAN);
        break;
      }

    default:
      throw NoViableAltException(this);
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- KeywordContext ------------------------------------------------------------------

CHTLJavaScriptParser::KeywordContext::KeywordContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* CHTLJavaScriptParser::KeywordContext::BREAK() {
  return getToken(CHTLJavaScriptParser::BREAK, 0);
}

tree::TerminalNode* CHTLJavaScriptParser::KeywordContext::DO() {
  return getToken(CHTLJavaScriptParser::DO, 0);
}

tree::TerminalNode* CHTLJavaScriptParser::KeywordContext::INSTANCEOF() {
  return getToken(CHTLJavaScriptParser::INSTANCEOF, 0);
}

tree::TerminalNode* CHTLJavaScriptParser::KeywordContext::TYPEOF() {
  return getToken(CHTLJavaScriptParser::TYPEOF, 0);
}

tree::TerminalNode* CHTLJavaScriptParser::KeywordContext::CASE() {
  return getToken(CHTLJavaScriptParser::CASE, 0);
}

tree::TerminalNode* CHTLJavaScriptParser::KeywordContext::ELSE() {
  return getToken(CHTLJavaScriptParser::ELSE, 0);
}

tree::TerminalNode* CHTLJavaScriptParser::KeywordContext::NEW() {
  return getToken(CHTLJavaScriptParser::NEW, 0);
}

tree::TerminalNode* CHTLJavaScriptParser::KeywordContext::VAR() {
  return getToken(CHTLJavaScriptParser::VAR, 0);
}

tree::TerminalNode* CHTLJavaScriptParser::KeywordContext::CATCH() {
  return getToken(CHTLJavaScriptParser::CATCH, 0);
}

tree::TerminalNode* CHTLJavaScriptParser::KeywordContext::FINALLY() {
  return getToken(CHTLJavaScriptParser::FINALLY, 0);
}

tree::TerminalNode* CHTLJavaScriptParser::KeywordContext::RETURN() {
  return getToken(CHTLJavaScriptParser::RETURN, 0);
}

tree::TerminalNode* CHTLJavaScriptParser::KeywordContext::VOID() {
  return getToken(CHTLJavaScriptParser::VOID, 0);
}

tree::TerminalNode* CHTLJavaScriptParser::KeywordContext::CONTINUE() {
  return getToken(CHTLJavaScriptParser::CONTINUE, 0);
}

tree::TerminalNode* CHTLJavaScriptParser::KeywordContext::FOR() {
  return getToken(CHTLJavaScriptParser::FOR, 0);
}

tree::TerminalNode* CHTLJavaScriptParser::KeywordContext::SWITCH() {
  return getToken(CHTLJavaScriptParser::SWITCH, 0);
}

tree::TerminalNode* CHTLJavaScriptParser::KeywordContext::WHILE() {
  return getToken(CHTLJavaScriptParser::WHILE, 0);
}

tree::TerminalNode* CHTLJavaScriptParser::KeywordContext::DEBUGGER() {
  return getToken(CHTLJavaScriptParser::DEBUGGER, 0);
}

tree::TerminalNode* CHTLJavaScriptParser::KeywordContext::FUNCTION() {
  return getToken(CHTLJavaScriptParser::FUNCTION, 0);
}

tree::TerminalNode* CHTLJavaScriptParser::KeywordContext::THIS() {
  return getToken(CHTLJavaScriptParser::THIS, 0);
}

tree::TerminalNode* CHTLJavaScriptParser::KeywordContext::WITH() {
  return getToken(CHTLJavaScriptParser::WITH, 0);
}

tree::TerminalNode* CHTLJavaScriptParser::KeywordContext::DEFAULT() {
  return getToken(CHTLJavaScriptParser::DEFAULT, 0);
}

tree::TerminalNode* CHTLJavaScriptParser::KeywordContext::IF() {
  return getToken(CHTLJavaScriptParser::IF, 0);
}

tree::TerminalNode* CHTLJavaScriptParser::KeywordContext::THROW() {
  return getToken(CHTLJavaScriptParser::THROW, 0);
}

tree::TerminalNode* CHTLJavaScriptParser::KeywordContext::DELETE() {
  return getToken(CHTLJavaScriptParser::DELETE, 0);
}

tree::TerminalNode* CHTLJavaScriptParser::KeywordContext::IN() {
  return getToken(CHTLJavaScriptParser::IN, 0);
}

tree::TerminalNode* CHTLJavaScriptParser::KeywordContext::TRY() {
  return getToken(CHTLJavaScriptParser::TRY, 0);
}

tree::TerminalNode* CHTLJavaScriptParser::KeywordContext::CLASS() {
  return getToken(CHTLJavaScriptParser::CLASS, 0);
}

tree::TerminalNode* CHTLJavaScriptParser::KeywordContext::ENUM() {
  return getToken(CHTLJavaScriptParser::ENUM, 0);
}

tree::TerminalNode* CHTLJavaScriptParser::KeywordContext::EXTENDS() {
  return getToken(CHTLJavaScriptParser::EXTENDS, 0);
}

tree::TerminalNode* CHTLJavaScriptParser::KeywordContext::SUPER() {
  return getToken(CHTLJavaScriptParser::SUPER, 0);
}

tree::TerminalNode* CHTLJavaScriptParser::KeywordContext::CONST() {
  return getToken(CHTLJavaScriptParser::CONST, 0);
}

tree::TerminalNode* CHTLJavaScriptParser::KeywordContext::EXPORT() {
  return getToken(CHTLJavaScriptParser::EXPORT, 0);
}

tree::TerminalNode* CHTLJavaScriptParser::KeywordContext::IMPORT() {
  return getToken(CHTLJavaScriptParser::IMPORT, 0);
}

tree::TerminalNode* CHTLJavaScriptParser::KeywordContext::ASYNC() {
  return getToken(CHTLJavaScriptParser::ASYNC, 0);
}

tree::TerminalNode* CHTLJavaScriptParser::KeywordContext::AWAIT() {
  return getToken(CHTLJavaScriptParser::AWAIT, 0);
}

tree::TerminalNode* CHTLJavaScriptParser::KeywordContext::YIELD() {
  return getToken(CHTLJavaScriptParser::YIELD, 0);
}

tree::TerminalNode* CHTLJavaScriptParser::KeywordContext::LET() {
  return getToken(CHTLJavaScriptParser::LET, 0);
}

tree::TerminalNode* CHTLJavaScriptParser::KeywordContext::STATIC() {
  return getToken(CHTLJavaScriptParser::STATIC, 0);
}

tree::TerminalNode* CHTLJavaScriptParser::KeywordContext::FROM() {
  return getToken(CHTLJavaScriptParser::FROM, 0);
}

tree::TerminalNode* CHTLJavaScriptParser::KeywordContext::AS() {
  return getToken(CHTLJavaScriptParser::AS, 0);
}

tree::TerminalNode* CHTLJavaScriptParser::KeywordContext::OF() {
  return getToken(CHTLJavaScriptParser::OF, 0);
}


size_t CHTLJavaScriptParser::KeywordContext::getRuleIndex() const {
  return CHTLJavaScriptParser::RuleKeyword;
}


std::any CHTLJavaScriptParser::KeywordContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<CHTLJavaScriptVisitor*>(visitor))
    return parserVisitor->visitKeyword(this);
  else
    return visitor->visitChildren(this);
}

CHTLJavaScriptParser::KeywordContext* CHTLJavaScriptParser::keyword() {
  KeywordContext *_localctx = _tracker.createInstance<KeywordContext>(_ctx, getState());
  enterRule(_localctx, 172, CHTLJavaScriptParser::RuleKeyword);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(1067);
    _la = _input->LA(1);
    if (!(((((_la - 27) & ~ 0x3fULL) == 0) &&
      ((1ULL << (_la - 27)) & ((1ULL << (CHTLJavaScriptParser::BREAK - 27))
      | (1ULL << (CHTLJavaScriptParser::DO - 27))
      | (1ULL << (CHTLJavaScriptParser::INSTANCEOF - 27))
      | (1ULL << (CHTLJavaScriptParser::TYPEOF - 27))
      | (1ULL << (CHTLJavaScriptParser::CASE - 27))
      | (1ULL << (CHTLJavaScriptParser::ELSE - 27))
      | (1ULL << (CHTLJavaScriptParser::NEW - 27))
      | (1ULL << (CHTLJavaScriptParser::VAR - 27))
      | (1ULL << (CHTLJavaScriptParser::CATCH - 27))
      | (1ULL << (CHTLJavaScriptParser::FINALLY - 27))
      | (1ULL << (CHTLJavaScriptParser::RETURN - 27))
      | (1ULL << (CHTLJavaScriptParser::VOID - 27))
      | (1ULL << (CHTLJavaScriptParser::CONTINUE - 27))
      | (1ULL << (CHTLJavaScriptParser::FOR - 27))
      | (1ULL << (CHTLJavaScriptParser::SWITCH - 27))
      | (1ULL << (CHTLJavaScriptParser::WHILE - 27))
      | (1ULL << (CHTLJavaScriptParser::DEBUGGER - 27))
      | (1ULL << (CHTLJavaScriptParser::FUNCTION - 27))
      | (1ULL << (CHTLJavaScriptParser::THIS - 27))
      | (1ULL << (CHTLJavaScriptParser::WITH - 27))
      | (1ULL << (CHTLJavaScriptParser::DEFAULT - 27))
      | (1ULL << (CHTLJavaScriptParser::IF - 27))
      | (1ULL << (CHTLJavaScriptParser::THROW - 27))
      | (1ULL << (CHTLJavaScriptParser::DELETE - 27))
      | (1ULL << (CHTLJavaScriptParser::IN - 27))
      | (1ULL << (CHTLJavaScriptParser::TRY - 27))
      | (1ULL << (CHTLJavaScriptParser::CLASS - 27))
      | (1ULL << (CHTLJavaScriptParser::ENUM - 27))
      | (1ULL << (CHTLJavaScriptParser::EXTENDS - 27))
      | (1ULL << (CHTLJavaScriptParser::SUPER - 27))
      | (1ULL << (CHTLJavaScriptParser::CONST - 27))
      | (1ULL << (CHTLJavaScriptParser::EXPORT - 27))
      | (1ULL << (CHTLJavaScriptParser::IMPORT - 27))
      | (1ULL << (CHTLJavaScriptParser::ASYNC - 27))
      | (1ULL << (CHTLJavaScriptParser::AWAIT - 27))
      | (1ULL << (CHTLJavaScriptParser::YIELD - 27))
      | (1ULL << (CHTLJavaScriptParser::LET - 27))
      | (1ULL << (CHTLJavaScriptParser::STATIC - 27))
      | (1ULL << (CHTLJavaScriptParser::FROM - 27))
      | (1ULL << (CHTLJavaScriptParser::AS - 27))
      | (1ULL << (CHTLJavaScriptParser::OF - 27)))) != 0))) {
    _errHandler->recoverInline(this);
    }
    else {
      _errHandler->reportMatch(this);
      consume();
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

bool CHTLJavaScriptParser::sempred(RuleContext *context, size_t ruleIndex, size_t predicateIndex) {
  switch (ruleIndex) {
    case 0: return singleExpressionSempred(antlrcpp::downCast<SingleExpressionContext *>(context), predicateIndex);

  default:
    break;
  }
  return true;
}

bool CHTLJavaScriptParser::singleExpressionSempred(SingleExpressionContext *_localctx, size_t predicateIndex) {
  switch (predicateIndex) {
    case 0: return precpred(_ctx, 25);
    case 1: return precpred(_ctx, 24);
    case 2: return precpred(_ctx, 23);
    case 3: return precpred(_ctx, 22);
    case 4: return precpred(_ctx, 21);
    case 5: return precpred(_ctx, 20);
    case 6: return precpred(_ctx, 19);
    case 7: return precpred(_ctx, 18);
    case 8: return precpred(_ctx, 17);
    case 9: return precpred(_ctx, 16);
    case 10: return precpred(_ctx, 15);
    case 11: return precpred(_ctx, 14);
    case 12: return precpred(_ctx, 13);
    case 13: return precpred(_ctx, 12);
    case 14: return precpred(_ctx, 11);
    case 15: return precpred(_ctx, 10);
    case 16: return precpred(_ctx, 9);
    case 17: return precpred(_ctx, 48);
    case 18: return precpred(_ctx, 47);
    case 19: return precpred(_ctx, 46);
    case 20: return precpred(_ctx, 45);
    case 21: return precpred(_ctx, 41);
    case 22: return precpred(_ctx, 40);
    case 23: return precpred(_ctx, 39);
    case 24: return precpred(_ctx, 37);
    case 25: return precpred(_ctx, 36);

  default:
    break;
  }
  return true;
}

void CHTLJavaScriptParser::initialize() {
  std::call_once(chtljavascriptParserOnceFlag, chtljavascriptParserInitialize);
}
