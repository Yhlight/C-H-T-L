package com.chtl.analyzer;

import com.chtl.ast.*;
import java.util.*;

/**
 * Semantic analyzer for CHTL - performs validation and symbol resolution
 */
public class SemanticAnalyzer implements ChtlVisitor<Void> {
    
    private SymbolTable symbolTable;
    private List<SemanticError> errors;
    private ElementNode currentElement;
    private NamespaceContext currentNamespace;
    
    public SemanticAnalyzer() {
        this.symbolTable = new SymbolTable();
        this.errors = new ArrayList<>();
    }
    
    public List<SemanticError> analyze(ChtlFileNode ast) {
        errors.clear();
        symbolTable.clear();
        visit(ast);
        return new ArrayList<>(errors);
    }
    
    @Override
    public Void visitChtlFile(ChtlFileNode node) {
        // First pass: collect all declarations
        for (ChtlNode decl : node.getDeclarations()) {
            if (decl instanceof TemplateNode) {
                registerTemplate((TemplateNode) decl);
            } else if (decl instanceof CustomNode) {
                registerCustom((CustomNode) decl);
            }
        }
        
        // Second pass: validate and resolve references
        for (ChtlNode decl : node.getDeclarations()) {
            decl.accept(this);
        }
        
        return null;
    }
    
    @Override
    public Void visitElement(ElementNode node) {
        ElementNode prevElement = currentElement;
        currentElement = node;
        
        // Check if element name is valid HTML tag
        if (!isValidHtmlTag(node.getTagName())) {
            addWarning(node, "'" + node.getTagName() + "' is not a standard HTML tag");
        }
        
        // Visit attributes
        for (AttributeNode attr : node.getAttributes()) {
            attr.accept(this);
        }
        
        // Visit content
        for (ChtlNode content : node.getContent()) {
            content.accept(this);
        }
        
        currentElement = prevElement;
        return null;
    }
    
    @Override
    public Void visitText(TextNode node) {
        // Text nodes don't need validation
        return null;
    }
    
    @Override
    public Void visitAttribute(AttributeNode node) {
        // Validate attribute names
        String name = node.getName();
        if (name.equals("class") && currentElement != null) {
            // Track classes for auto-generation
            String[] classes = node.getValue().split("\\s+");
            for (String className : classes) {
                symbolTable.addClassUsage(currentElement, className);
            }
        } else if (name.equals("id") && currentElement != null) {
            // Check for duplicate IDs
            if (!symbolTable.addId(node.getValue())) {
                addError(node, "Duplicate ID: " + node.getValue());
            }
        }
        return null;
    }
    
    @Override
    public Void visitStyle(StyleNode node) {
        // Process style content
        for (ChtlNode content : node.getContent()) {
            if (content instanceof CssRuleNode) {
                CssRuleNode rule = (CssRuleNode) content;
                processAutoGeneratedSelectors(rule);
            }
            content.accept(this);
        }
        return null;
    }
    
    @Override
    public Void visitScript(ScriptNode node) {
        // Process enhanced selectors in script
        String content = node.getContent();
        processEnhancedSelectors(content, node);
        return null;
    }
    
    @Override
    public Void visitTemplate(TemplateNode node) {
        // Templates are already registered, just validate content
        for (ChtlNode content : node.getContent()) {
            content.accept(this);
        }
        return null;
    }
    
    @Override
    public Void visitCustom(CustomNode node) {
        // Customs are already registered, just validate content
        for (ChtlNode content : node.getContent()) {
            content.accept(this);
        }
        return null;
    }
    
    @Override
    public Void visitImport(ImportNode node) {
        // Validate import paths
        String path = node.getSourcePath();
        if (path.isEmpty()) {
            addError(node, "Import path cannot be empty");
        }
        
        // Register imported symbols
        if (node.getAlias() != null) {
            symbolTable.addImportAlias(node.getAlias(), node);
        }
        
        return null;
    }
    
    @Override
    public Void visitNamespace(NamespaceNode node) {
        NamespaceContext prevNamespace = currentNamespace;
        currentNamespace = new NamespaceContext(node.getName(), prevNamespace);
        
        // Register namespace
        symbolTable.addNamespace(currentNamespace);
        
        // Visit content
        for (ChtlNode content : node.getContent()) {
            content.accept(this);
        }
        
        currentNamespace = prevNamespace;
        return null;
    }
    
    @Override
    public Void visitConfiguration(ConfigurationNode node) {
        // Validate configuration options
        return null;
    }
    
    @Override
    public Void visitOrigin(OriginNode node) {
        // Origin blocks don't need validation
        return null;
    }
    
    @Override
    public Void visitCssProperty(CssPropertyNode node) {
        // Validate CSS property names
        if (!isValidCssProperty(node.getProperty())) {
            addWarning(node, "Unknown CSS property: " + node.getProperty());
        }
        return null;
    }
    
    @Override
    public Void visitCssRule(CssRuleNode node) {
        // Process CSS rule selectors
        String selector = node.getSelector();
        
        if (selector.startsWith(".") && currentElement != null) {
            // Auto-generate class
            String className = selector.substring(1);
            currentElement.setGeneratedClass(className);
            symbolTable.addGeneratedClass(currentElement, className);
        } else if (selector.startsWith("#") && currentElement != null) {
            // Auto-generate ID
            String id = selector.substring(1);
            currentElement.setGeneratedId(id);
            if (!symbolTable.addId(id)) {
                addError(node, "Duplicate auto-generated ID: " + id);
            }
        }
        
        // Visit properties
        for (CssPropertyNode prop : node.getProperties()) {
            prop.accept(this);
        }
        
        return null;
    }
    
    @Override
    public Void visitEnhancedSelector(EnhancedSelectorNode node) {
        // Validate enhanced selector syntax
        String selector = node.getSelector();
        if (!symbolTable.hasSelector(selector)) {
            addWarning(node, "Selector '" + selector + "' may not match any elements");
        }
        return null;
    }
    
    @Override
    public Void visitDelete(DeleteNode node) {
        // Validate delete targets exist
        for (String target : node.getTargets()) {
            if (!symbolTable.hasSymbol(target)) {
                addError(node, "Cannot delete undefined symbol: " + target);
            }
        }
        return null;
    }
    
    @Override
    public Void visitInsert(InsertNode node) {
        // Validate insert position and target
        return null;
    }
    
    @Override
    public Void visitExcept(ExceptNode node) {
        // Validate except constraints
        return null;
    }
    
    @Override
    public Void visitInherit(InheritNode node) {
        // Validate inheritance target exists
        AtReferenceNode ref = node.getReference();
        if (!resolveReference(ref)) {
            addError(node, "Cannot inherit from undefined symbol: " + ref.getName());
        }
        return null;
    }
    
    @Override
    public Void visitAtReference(AtReferenceNode node) {
        // Validate reference exists
        if (!resolveReference(node)) {
            addError(node, "Undefined reference: " + node.getType() + " " + node.getName());
        }
        return null;
    }
    
    @Override
    public Void visitSpecialization(SpecializationNode node) {
        // Validate specialization
        return null;
    }
    
    // Helper methods
    private void registerTemplate(TemplateNode template) {
        String key = template.getType() + ":" + template.getName();
        if (!symbolTable.addSymbol(key, template)) {
            addError(template, "Duplicate template: " + template.getName());
        }
    }
    
    private void registerCustom(CustomNode custom) {
        String key = custom.getType() + ":" + custom.getName();
        if (!symbolTable.addSymbol(key, custom)) {
            addError(custom, "Duplicate custom: " + custom.getName());
        }
    }
    
    private boolean resolveReference(AtReferenceNode ref) {
        String key = ref.getType() + ":" + ref.getName();
        
        // Check current namespace first
        if (currentNamespace != null) {
            String nsKey = currentNamespace.getFullName() + "." + key;
            if (symbolTable.hasSymbol(nsKey)) {
                return true;
            }
        }
        
        // Check global namespace
        return symbolTable.hasSymbol(key);
    }
    
    private void processAutoGeneratedSelectors(CssRuleNode rule) {
        String selector = rule.getSelector();
        
        if (selector.equals("&") && currentElement != null) {
            // Context-based selector
            if (currentElement.getGeneratedClass() != null) {
                rule.setResolvedSelector("." + currentElement.getGeneratedClass());
            } else if (currentElement.getGeneratedId() != null) {
                rule.setResolvedSelector("#" + currentElement.getGeneratedId());
            }
        }
    }
    
    private void processEnhancedSelectors(String content, ChtlNode node) {
        // Find all {{selector}} patterns
        java.util.regex.Pattern pattern = java.util.regex.Pattern.compile("\\{\\{([^}]+)\\}\\}");
        java.util.regex.Matcher matcher = pattern.matcher(content);
        
        while (matcher.find()) {
            String selector = matcher.group(1);
            if (!symbolTable.hasSelector(selector)) {
                addWarning(node, "Enhanced selector may not match any elements: " + selector);
            }
        }
    }
    
    private boolean isValidHtmlTag(String tag) {
        // Simplified validation - in real implementation, use complete HTML5 tag list
        Set<String> commonTags = new HashSet<>(Arrays.asList(
            "div", "span", "p", "a", "img", "ul", "ol", "li", "table", "tr", "td", "th",
            "form", "input", "button", "select", "option", "textarea", "label",
            "h1", "h2", "h3", "h4", "h5", "h6", "header", "footer", "nav", "main",
            "section", "article", "aside", "figure", "figcaption", "video", "audio",
            "canvas", "svg", "iframe", "script", "style", "link", "meta", "title",
            "head", "body", "html", "br", "hr", "strong", "em", "b", "i", "u",
            "pre", "code", "blockquote", "cite", "abbr", "address", "time"
        ));
        return commonTags.contains(tag.toLowerCase());
    }
    
    private boolean isValidCssProperty(String property) {
        // Simplified validation - in real implementation, use complete CSS property list
        Set<String> commonProps = new HashSet<>(Arrays.asList(
            "color", "background-color", "background", "font-size", "font-family",
            "font-weight", "margin", "padding", "border", "width", "height",
            "display", "position", "top", "left", "right", "bottom", "z-index",
            "opacity", "visibility", "overflow", "text-align", "line-height",
            "text-decoration", "transform", "transition", "animation", "flex",
            "grid", "box-shadow", "text-shadow", "border-radius", "cursor"
        ));
        return commonProps.contains(property.toLowerCase());
    }
    
    private void addError(ChtlNode node, String message) {
        errors.add(new SemanticError(
            SemanticError.Severity.ERROR,
            message,
            node.getLine(),
            node.getColumn()
        ));
    }
    
    private void addWarning(ChtlNode node, String message) {
        errors.add(new SemanticError(
            SemanticError.Severity.WARNING,
            message,
            node.getLine(),
            node.getColumn()
        ));
    }
    
    private void addError(String message, ChtlNode node) {
        addError(node, message);
    }
    
    private void addWarning(String message, ChtlNode node) {
        addWarning(node, message);
    }
    
    @Override
    public Void visitInfo(InfoNode node) {
        // 验证Info节点的必需属性
        if (node.getName() == null || node.getName().isEmpty()) {
            addError("Info块缺少必需的'name'属性", node);
        }
        if (node.getVersion() == null || node.getVersion().isEmpty()) {
            addError("Info块缺少必需的'version'属性", node);
        }
        
        // 验证版本格式
        String version = node.getVersion();
        if (version != null && !version.matches("\\d+\\.\\d+\\.\\d+")) {
            addWarning("版本格式应为 x.y.z 格式: " + version, node);
        }
        
        return null;
    }
    
    @Override
    public Void visitExport(ExportNode node) {
        // 验证导出的项是否存在
        for (ExportNode.ExportItem item : node.getExports()) {
            for (String name : item.getNames()) {
                String key = item.getType() + ":" + name;
                if (!symbolTable.hasSymbol(key)) {
                    addWarning("导出的符号不存在: " + item.getType() + " " + name, node);
                }
            }
        }
        
        return null;
    }
}