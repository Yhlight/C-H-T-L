
// Generated from /workspace/grammar/CHTLJavaScript.g4 by ANTLR 4.13.1


#include "CHTLJavaScriptVisitor.h"

#include "CHTLJavaScriptParser.h"


using namespace antlrcpp;

using namespace antlr4;

namespace {

struct CHTLJavaScriptParserStaticData final {
  CHTLJavaScriptParserStaticData(std::vector<std::string> ruleNames,
                        std::vector<std::string> literalNames,
                        std::vector<std::string> symbolicNames)
      : ruleNames(std::move(ruleNames)), literalNames(std::move(literalNames)),
        symbolicNames(std::move(symbolicNames)),
        vocabulary(this->literalNames, this->symbolicNames) {}

  CHTLJavaScriptParserStaticData(const CHTLJavaScriptParserStaticData&) = delete;
  CHTLJavaScriptParserStaticData(CHTLJavaScriptParserStaticData&&) = delete;
  CHTLJavaScriptParserStaticData& operator=(const CHTLJavaScriptParserStaticData&) = delete;
  CHTLJavaScriptParserStaticData& operator=(CHTLJavaScriptParserStaticData&&) = delete;

  std::vector<antlr4::dfa::DFA> decisionToDFA;
  antlr4::atn::PredictionContextCache sharedContextCache;
  const std::vector<std::string> ruleNames;
  const std::vector<std::string> literalNames;
  const std::vector<std::string> symbolicNames;
  const antlr4::dfa::Vocabulary vocabulary;
  antlr4::atn::SerializedATNView serializedATN;
  std::unique_ptr<antlr4::atn::ATN> atn;
};

::antlr4::internal::OnceFlag chtljavascriptParserOnceFlag;
#if ANTLR4_USE_THREAD_LOCAL_CACHE
static thread_local
#endif
CHTLJavaScriptParserStaticData *chtljavascriptParserStaticData = nullptr;

void chtljavascriptParserInitialize() {
#if ANTLR4_USE_THREAD_LOCAL_CACHE
  if (chtljavascriptParserStaticData != nullptr) {
    return;
  }
#else
  assert(chtljavascriptParserStaticData == nullptr);
#endif
  auto staticData = std::make_unique<CHTLJavaScriptParserStaticData>(
    std::vector<std::string>{
      "singleExpression", "chtlSelectorList", "chtlSelector", "chtlSelectorContent", 
      "cssSelector", "cssSelectorPart", "listenObject", "eventBinding", 
      "delegateObject", "delegateProperty", "selectorArray", "animateCall", 
      "animateObject", "animateProperty", "cssObject", "cssProperty", "whenArray", 
      "whenObject", "whenProperty", "program", "statement", "block", "variableStatement", 
      "variableDeclarationList", "varModifier", "variableDeclaration", "emptyStatement", 
      "expressionStatement", "ifStatement", "iterationStatement", "continueStatement", 
      "breakStatement", "returnStatement", "withStatement", "labelledStatement", 
      "switchStatement", "caseBlock", "caseClauses", "caseClause", "defaultClause", 
      "throwStatement", "tryStatement", "catchClause", "finallyClause", 
      "functionDeclaration", "classDeclaration", "classTail", "classElement", 
      "methodDefinition", "getter", "setter", "generatorMethod", "asyncMethod", 
      "importStatement", "importFromBlock", "importNamespace", "importSpecifier", 
      "moduleExportName", "exportStatement", "exportFromBlock", "exportNamespace", 
      "exportSpecifier", "declaration", "formalParameterList", "formalParameter", 
      "restParameter", "assignable", "propertyName", "expressionSequence", 
      "assignmentOperator", "literal", "arrayLiteral", "elementList", "arrayElement", 
      "objectLiteral", "propertyAssignment", "arguments", "argumentList", 
      "argument", "anonymousFunction", "arrowFunction", "arrowFunctionParameters", 
      "arrowFunctionBody", "typeofExpression", "identifierName", "reservedWord", 
      "keyword"
    },
    std::vector<std::string>{
      "", "'->'", "'{{'", "'}}'", "'#'", "'@'", "' '", "'listen'", "'delegate'", 
      "'target'", "'animate'", "'duration'", "'easing'", "'begin'", "'end'", 
      "'when'", "'loop'", "'direction'", "'delay'", "'callback'", "'`'", 
      "", "", "", "", "", "", "'break'", "'do'", "'instanceof'", "'typeof'", 
      "'case'", "'else'", "'new'", "'var'", "'catch'", "'finally'", "'return'", 
      "'void'", "'continue'", "'for'", "'switch'", "'while'", "'debugger'", 
      "'function'", "'this'", "'with'", "'default'", "'if'", "'throw'", 
      "'delete'", "'in'", "'try'", "'class'", "'enum'", "'extends'", "'super'", 
      "'const'", "'export'", "'import'", "'async'", "'await'", "'yield'", 
      "'let'", "'static'", "'from'", "'as'", "'of'", "'get'", "'set'", "'null'", 
      "", "'undefined'", "'('", "')'", "'{'", "'}'", "'['", "']'", "';'", 
      "','", "'.'", "'\\u003F'", "':'", "'...'", "'='", "'*='", "'/='", 
      "'%='", "'+='", "'-='", "'<<='", "'>>='", "'>>>='", "'&='", "'^='", 
      "'|='", "'**='", "'\\u003F\\u003F='", "'=>'", "'++'", "'--'", "'+'", 
      "'-'", "'~'", "'!'", "'*'", "'/'", "'%'", "'**'", "'\\u003F\\u003F'", 
      "'<<'", "'>>'", "'>>>'", "'<'", "'>'", "'<='", "'>='", "'=='", "'!='", 
      "'==='", "'!=='", "'&'", "'^'", "'|'", "'&&'", "'||'"
    },
    std::vector<std::string>{
      "", "CHTL_ARROW", "CHTL_SELECTOR_START", "CHTL_SELECTOR_END", "HASH", 
      "AT", "SPACE", "LISTEN", "DELEGATE", "TARGET", "ANIMATE", "DURATION", 
      "EASING", "BEGIN_PROP", "END_PROP", "WHEN", "LOOP", "DIRECTION", "DELAY", 
      "CALLBACK", "BACKTICK", "TEMPLATE_STRING", "REGEX", "IDENTIFIER", 
      "LINE_COMMENT", "BLOCK_COMMENT", "WS", "BREAK", "DO", "INSTANCEOF", 
      "TYPEOF", "CASE", "ELSE", "NEW", "VAR", "CATCH", "FINALLY", "RETURN", 
      "VOID", "CONTINUE", "FOR", "SWITCH", "WHILE", "DEBUGGER", "FUNCTION", 
      "THIS", "WITH", "DEFAULT", "IF", "THROW", "DELETE", "IN", "TRY", "CLASS", 
      "ENUM", "EXTENDS", "SUPER", "CONST", "EXPORT", "IMPORT", "ASYNC", 
      "AWAIT", "YIELD", "LET", "STATIC", "FROM", "AS", "OF", "GET", "SET", 
      "NULL", "BOOLEAN", "UNDEFINED", "LPAREN", "RPAREN", "LBRACE", "RBRACE", 
      "LBRACKET", "RBRACKET", "SEMICOLON", "COMMA", "DOT", "QUESTION", "COLON", 
      "ELLIPSIS", "EQUALS", "STAR_EQUALS", "SLASH_EQUALS", "PERCENT_EQUALS", 
      "PLUS_EQUALS", "MINUS_EQUALS", "LSHIFT_EQUALS", "RSHIFT_EQUALS", "URSHIFT_EQUALS", 
      "AMPERSAND_EQUALS", "CARET_EQUALS", "PIPE_EQUALS", "POWER_EQUALS", 
      "NULLISH_EQUALS", "ARROW", "PLUSPLUS", "MINUSMINUS", "PLUS", "MINUS", 
      "TILDE", "EXCLAMATION", "STAR", "SLASH", "PERCENT", "POWER", "NULLISH_COALESCING", 
      "LSHIFT", "RSHIFT", "URSHIFT", "LT", "GT", "LE", "GE", "EQUALS_OP", 
      "NOT_EQUALS", "STRICT_EQUALS", "STRICT_NOT_EQUALS", "AMPERSAND", "CARET", 
      "PIPE", "AND_OP", "OR_OP", "NUMBER", "BIGINT", "STRING"
    }
  );
  static const int32_t serializedATNSegment[] = {
  	4,1,129,1070,2,0,7,0,2,1,7,1,2,2,7,2,2,3,7,3,2,4,7,4,2,5,7,5,2,6,7,6,
  	2,7,7,7,2,8,7,8,2,9,7,9,2,10,7,10,2,11,7,11,2,12,7,12,2,13,7,13,2,14,
  	7,14,2,15,7,15,2,16,7,16,2,17,7,17,2,18,7,18,2,19,7,19,2,20,7,20,2,21,
  	7,21,2,22,7,22,2,23,7,23,2,24,7,24,2,25,7,25,2,26,7,26,2,27,7,27,2,28,
  	7,28,2,29,7,29,2,30,7,30,2,31,7,31,2,32,7,32,2,33,7,33,2,34,7,34,2,35,
  	7,35,2,36,7,36,2,37,7,37,2,38,7,38,2,39,7,39,2,40,7,40,2,41,7,41,2,42,
  	7,42,2,43,7,43,2,44,7,44,2,45,7,45,2,46,7,46,2,47,7,47,2,48,7,48,2,49,
  	7,49,2,50,7,50,2,51,7,51,2,52,7,52,2,53,7,53,2,54,7,54,2,55,7,55,2,56,
  	7,56,2,57,7,57,2,58,7,58,2,59,7,59,2,60,7,60,2,61,7,61,2,62,7,62,2,63,
  	7,63,2,64,7,64,2,65,7,65,2,66,7,66,2,67,7,67,2,68,7,68,2,69,7,69,2,70,
  	7,70,2,71,7,71,2,72,7,72,2,73,7,73,2,74,7,74,2,75,7,75,2,76,7,76,2,77,
  	7,77,2,78,7,78,2,79,7,79,2,80,7,80,2,81,7,81,2,82,7,82,2,83,7,83,2,84,
  	7,84,2,85,7,85,2,86,7,86,1,0,1,0,1,0,1,0,1,0,1,0,1,0,1,0,3,0,183,8,0,
  	1,0,1,0,1,0,1,0,1,0,1,0,1,0,1,0,1,0,1,0,1,0,1,0,1,0,1,0,1,0,1,0,1,0,1,
  	0,1,0,1,0,1,0,1,0,1,0,1,0,1,0,1,0,1,0,1,0,1,0,1,0,1,0,3,0,216,8,0,1,0,
  	1,0,1,0,1,0,1,0,1,0,1,0,1,0,1,0,1,0,1,0,1,0,1,0,1,0,1,0,1,0,1,0,1,0,1,
  	0,1,0,1,0,1,0,1,0,1,0,1,0,1,0,1,0,1,0,1,0,1,0,1,0,1,0,1,0,1,0,1,0,1,0,
  	1,0,1,0,1,0,1,0,1,0,1,0,1,0,1,0,1,0,1,0,1,0,1,0,1,0,1,0,1,0,1,0,1,0,1,
  	0,1,0,1,0,1,0,1,0,1,0,1,0,1,0,1,0,1,0,1,0,1,0,1,0,1,0,1,0,1,0,1,0,1,0,
  	1,0,1,0,1,0,1,0,1,0,1,0,1,0,1,0,1,0,1,0,1,0,1,0,1,0,1,0,1,0,1,0,1,0,1,
  	0,1,0,1,0,5,0,309,8,0,10,0,12,0,312,9,0,1,1,1,1,1,1,5,1,317,8,1,10,1,
  	12,1,320,9,1,1,2,1,2,1,2,1,2,1,3,1,3,1,3,1,3,1,3,1,3,3,3,332,8,3,1,4,
  	4,4,335,8,4,11,4,12,4,336,1,5,1,5,1,5,1,5,1,5,1,5,1,5,1,5,1,5,3,5,348,
  	8,5,1,6,1,6,1,6,1,6,5,6,354,8,6,10,6,12,6,357,9,6,1,6,1,6,1,7,1,7,1,7,
  	1,7,3,7,365,8,7,1,8,1,8,1,8,1,8,5,8,371,8,8,10,8,12,8,374,9,8,1,8,1,8,
  	1,9,1,9,1,9,1,9,3,9,382,8,9,1,9,1,9,1,9,3,9,387,8,9,1,10,1,10,1,10,1,
  	10,5,10,393,8,10,10,10,12,10,396,9,10,1,10,1,10,1,11,1,11,1,11,1,11,1,
  	11,1,12,1,12,1,12,1,12,5,12,409,8,12,10,12,12,12,412,9,12,1,12,1,12,1,
  	13,1,13,1,13,1,13,1,13,1,13,1,13,1,13,1,13,1,13,1,13,1,13,1,13,1,13,1,
  	13,1,13,1,13,1,13,1,13,1,13,1,13,1,13,1,13,1,13,1,13,1,13,1,13,1,13,3,
  	13,444,8,13,3,13,446,8,13,1,14,1,14,1,14,1,14,5,14,452,8,14,10,14,12,
  	14,455,9,14,1,14,1,14,1,15,1,15,1,15,1,15,1,15,3,15,464,8,15,1,16,1,16,
  	1,16,1,16,5,16,470,8,16,10,16,12,16,473,9,16,1,16,1,16,1,17,1,17,1,17,
  	1,17,5,17,481,8,17,10,17,12,17,484,9,17,1,17,1,17,1,18,1,18,1,18,1,18,
  	1,18,1,18,1,18,1,18,3,18,496,8,18,3,18,498,8,18,1,19,5,19,501,8,19,10,
  	19,12,19,504,9,19,1,19,1,19,1,20,1,20,1,20,1,20,1,20,1,20,1,20,1,20,1,
  	20,1,20,1,20,1,20,1,20,1,20,1,20,1,20,1,20,1,20,3,20,526,8,20,1,21,1,
  	21,5,21,530,8,21,10,21,12,21,533,9,21,1,21,1,21,1,22,1,22,1,22,1,23,1,
  	23,1,23,1,23,5,23,544,8,23,10,23,12,23,547,9,23,1,24,1,24,1,25,1,25,1,
  	25,3,25,554,8,25,1,26,1,26,1,27,1,27,1,27,1,28,1,28,1,28,1,28,1,28,1,
  	28,1,28,3,28,568,8,28,1,29,1,29,1,29,1,29,1,29,1,29,1,29,1,29,1,29,1,
  	29,1,29,1,29,1,29,1,29,1,29,1,29,1,29,1,29,3,29,588,8,29,1,29,1,29,3,
  	29,592,8,29,1,29,1,29,3,29,596,8,29,1,29,1,29,1,29,1,29,1,29,1,29,3,29,
  	604,8,29,1,29,1,29,1,29,1,29,1,29,1,29,1,29,1,29,1,29,3,29,615,8,29,1,
  	29,1,29,1,29,1,29,1,29,1,29,1,29,1,29,1,29,1,29,3,29,627,8,29,1,29,1,
  	29,1,29,1,29,1,29,3,29,634,8,29,1,30,1,30,3,30,638,8,30,1,30,1,30,1,31,
  	1,31,3,31,644,8,31,1,31,1,31,1,32,1,32,3,32,650,8,32,1,32,1,32,1,33,1,
  	33,1,33,1,33,1,33,1,33,1,34,1,34,1,34,1,34,1,35,1,35,1,35,1,35,1,35,1,
  	35,1,36,1,36,3,36,672,8,36,1,36,1,36,3,36,676,8,36,3,36,678,8,36,1,36,
  	1,36,1,37,4,37,683,8,37,11,37,12,37,684,1,38,1,38,1,38,1,38,5,38,691,
  	8,38,10,38,12,38,694,9,38,1,39,1,39,1,39,5,39,699,8,39,10,39,12,39,702,
  	9,39,1,40,1,40,1,40,1,40,1,41,1,41,1,41,1,41,3,41,712,8,41,1,41,3,41,
  	715,8,41,1,42,1,42,1,42,1,42,1,42,3,42,722,8,42,1,42,1,42,1,43,1,43,1,
  	43,1,44,3,44,730,8,44,1,44,1,44,3,44,734,8,44,1,44,1,44,1,44,3,44,739,
  	8,44,1,44,1,44,1,44,1,45,1,45,1,45,1,45,3,45,748,8,45,1,45,1,45,1,46,
  	1,46,5,46,754,8,46,10,46,12,46,757,9,46,1,46,1,46,1,47,3,47,762,8,47,
  	1,47,1,47,1,47,1,47,1,47,1,47,1,47,3,47,771,8,47,1,48,1,48,1,48,3,48,
  	776,8,48,1,48,1,48,1,48,1,48,1,48,1,48,1,48,3,48,785,8,48,1,49,1,49,1,
  	49,1,49,1,49,1,49,1,50,1,50,1,50,1,50,1,50,1,50,1,50,1,51,1,51,1,51,1,
  	51,3,51,804,8,51,1,51,1,51,1,51,1,52,1,52,1,52,1,52,3,52,813,8,52,1,52,
  	1,52,1,52,1,53,1,53,1,53,3,53,821,8,53,1,53,1,53,1,54,1,54,1,54,1,54,
  	3,54,829,8,54,1,54,1,54,1,54,1,55,1,55,1,55,1,55,5,55,838,8,55,10,55,
  	12,55,841,9,55,3,55,843,8,55,1,55,1,55,1,56,1,56,3,56,849,8,56,1,56,1,
  	56,3,56,853,8,56,1,57,1,57,1,58,1,58,1,58,3,58,860,8,58,1,58,1,58,1,58,
  	1,58,1,58,1,58,1,58,3,58,869,8,58,1,59,1,59,3,59,873,8,59,1,59,1,59,1,
  	59,1,60,1,60,1,60,1,60,5,60,882,8,60,10,60,12,60,885,9,60,3,60,887,8,
  	60,1,60,1,60,1,61,1,61,3,61,893,8,61,1,61,1,61,3,61,897,8,61,1,62,1,62,
  	1,62,3,62,902,8,62,1,63,1,63,1,63,5,63,907,8,63,10,63,12,63,910,9,63,
  	1,63,1,63,3,63,914,8,63,1,63,3,63,917,8,63,1,64,1,64,1,64,3,64,922,8,
  	64,1,65,1,65,1,65,1,66,1,66,1,66,3,66,930,8,66,1,67,1,67,1,67,1,67,1,
  	67,1,67,1,67,3,67,939,8,67,1,68,1,68,1,68,5,68,944,8,68,10,68,12,68,947,
  	9,68,1,69,1,69,1,70,1,70,1,71,1,71,3,71,955,8,71,1,71,1,71,1,72,1,72,
  	1,72,5,72,962,8,72,10,72,12,72,965,9,72,1,73,3,73,968,8,73,1,73,1,73,
  	3,73,972,8,73,1,74,1,74,1,74,1,74,5,74,978,8,74,10,74,12,74,981,9,74,
  	1,74,3,74,984,8,74,1,74,1,74,1,75,1,75,1,75,1,75,1,75,1,75,1,75,1,75,
  	1,75,1,75,1,75,1,75,1,75,1,75,3,75,1002,8,75,1,76,1,76,3,76,1006,8,76,
  	1,76,1,76,1,77,1,77,1,77,5,77,1013,8,77,10,77,12,77,1016,9,77,1,78,3,
  	78,1019,8,78,1,78,1,78,1,79,3,79,1024,8,79,1,79,1,79,3,79,1028,8,79,1,
  	79,1,79,3,79,1032,8,79,1,79,1,79,1,79,1,80,3,80,1038,8,80,1,80,1,80,1,
  	80,1,80,1,81,1,81,1,81,3,81,1047,8,81,1,81,3,81,1050,8,81,1,82,1,82,3,
  	82,1054,8,82,1,83,1,83,1,83,1,84,1,84,3,84,1061,8,84,1,85,1,85,1,85,3,
  	85,1066,8,85,1,86,1,86,1,86,0,1,0,87,0,2,4,6,8,10,12,14,16,18,20,22,24,
  	26,28,30,32,34,36,38,40,42,44,46,48,50,52,54,56,58,60,62,64,66,68,70,
  	72,74,76,78,80,82,84,86,88,90,92,94,96,98,100,102,104,106,108,110,112,
  	114,116,118,120,122,124,126,128,130,132,134,136,138,140,142,144,146,148,
  	150,152,154,156,158,160,162,164,166,168,170,172,0,10,1,0,106,108,1,0,
  	102,103,1,0,111,113,1,0,114,117,1,0,118,121,2,0,23,23,129,129,3,0,34,
  	34,57,57,63,63,1,0,86,98,4,0,21,22,70,72,127,127,129,129,1,0,27,67,1173,
  	0,215,1,0,0,0,2,313,1,0,0,0,4,321,1,0,0,0,6,331,1,0,0,0,8,334,1,0,0,0,
  	10,347,1,0,0,0,12,349,1,0,0,0,14,360,1,0,0,0,16,366,1,0,0,0,18,386,1,
  	0,0,0,20,388,1,0,0,0,22,399,1,0,0,0,24,404,1,0,0,0,26,445,1,0,0,0,28,
  	447,1,0,0,0,30,458,1,0,0,0,32,465,1,0,0,0,34,476,1,0,0,0,36,497,1,0,0,
  	0,38,502,1,0,0,0,40,525,1,0,0,0,42,527,1,0,0,0,44,536,1,0,0,0,46,539,
  	1,0,0,0,48,548,1,0,0,0,50,550,1,0,0,0,52,555,1,0,0,0,54,557,1,0,0,0,56,
  	560,1,0,0,0,58,633,1,0,0,0,60,635,1,0,0,0,62,641,1,0,0,0,64,647,1,0,0,
  	0,66,653,1,0,0,0,68,659,1,0,0,0,70,663,1,0,0,0,72,669,1,0,0,0,74,682,
  	1,0,0,0,76,686,1,0,0,0,78,695,1,0,0,0,80,703,1,0,0,0,82,707,1,0,0,0,84,
  	716,1,0,0,0,86,725,1,0,0,0,88,729,1,0,0,0,90,743,1,0,0,0,92,751,1,0,0,
  	0,94,770,1,0,0,0,96,784,1,0,0,0,98,786,1,0,0,0,100,792,1,0,0,0,102,799,
  	1,0,0,0,104,808,1,0,0,0,106,817,1,0,0,0,108,828,1,0,0,0,110,833,1,0,0,
  	0,112,848,1,0,0,0,114,854,1,0,0,0,116,868,1,0,0,0,118,872,1,0,0,0,120,
  	877,1,0,0,0,122,892,1,0,0,0,124,901,1,0,0,0,126,916,1,0,0,0,128,918,1,
  	0,0,0,130,923,1,0,0,0,132,929,1,0,0,0,134,938,1,0,0,0,136,940,1,0,0,0,
  	138,948,1,0,0,0,140,950,1,0,0,0,142,952,1,0,0,0,144,958,1,0,0,0,146,971,
  	1,0,0,0,148,973,1,0,0,0,150,1001,1,0,0,0,152,1003,1,0,0,0,154,1009,1,
  	0,0,0,156,1018,1,0,0,0,158,1023,1,0,0,0,160,1037,1,0,0,0,162,1049,1,0,
  	0,0,164,1053,1,0,0,0,166,1055,1,0,0,0,168,1060,1,0,0,0,170,1065,1,0,0,
  	0,172,1067,1,0,0,0,174,175,6,0,-1,0,175,216,3,4,2,0,176,216,3,22,11,0,
  	177,216,3,158,79,0,178,216,3,160,80,0,179,180,5,33,0,0,180,182,3,0,0,
  	0,181,183,3,152,76,0,182,181,1,0,0,0,182,183,1,0,0,0,183,216,1,0,0,0,
  	184,185,5,50,0,0,185,216,3,0,0,35,186,187,5,38,0,0,187,216,3,0,0,34,188,
  	189,5,30,0,0,189,216,3,0,0,33,190,191,5,100,0,0,191,216,3,0,0,32,192,
  	193,5,101,0,0,193,216,3,0,0,31,194,195,5,102,0,0,195,216,3,0,0,30,196,
  	197,5,103,0,0,197,216,3,0,0,29,198,199,5,104,0,0,199,216,3,0,0,28,200,
  	201,5,105,0,0,201,216,3,0,0,27,202,203,5,61,0,0,203,216,3,0,0,26,204,
  	216,5,45,0,0,205,216,5,23,0,0,206,216,5,56,0,0,207,216,3,140,70,0,208,
  	216,3,142,71,0,209,216,3,148,74,0,210,211,5,73,0,0,211,212,3,136,68,0,
  	212,213,5,74,0,0,213,216,1,0,0,0,214,216,3,166,83,0,215,174,1,0,0,0,215,
  	176,1,0,0,0,215,177,1,0,0,0,215,178,1,0,0,0,215,179,1,0,0,0,215,184,1,
  	0,0,0,215,186,1,0,0,0,215,188,1,0,0,0,215,190,1,0,0,0,215,192,1,0,0,0,
  	215,194,1,0,0,0,215,196,1,0,0,0,215,198,1,0,0,0,215,200,1,0,0,0,215,202,
  	1,0,0,0,215,204,1,0,0,0,215,205,1,0,0,0,215,206,1,0,0,0,215,207,1,0,0,
  	0,215,208,1,0,0,0,215,209,1,0,0,0,215,210,1,0,0,0,215,214,1,0,0,0,216,
  	310,1,0,0,0,217,218,10,25,0,0,218,219,5,109,0,0,219,309,3,0,0,26,220,
  	221,10,24,0,0,221,222,7,0,0,0,222,309,3,0,0,25,223,224,10,23,0,0,224,
  	225,7,1,0,0,225,309,3,0,0,24,226,227,10,22,0,0,227,228,7,2,0,0,228,309,
  	3,0,0,23,229,230,10,21,0,0,230,231,7,3,0,0,231,309,3,0,0,22,232,233,10,
  	20,0,0,233,234,5,29,0,0,234,309,3,0,0,21,235,236,10,19,0,0,236,237,5,
  	51,0,0,237,309,3,0,0,20,238,239,10,18,0,0,239,240,7,4,0,0,240,309,3,0,
  	0,19,241,242,10,17,0,0,242,243,5,122,0,0,243,309,3,0,0,18,244,245,10,
  	16,0,0,245,246,5,123,0,0,246,309,3,0,0,17,247,248,10,15,0,0,248,249,5,
  	124,0,0,249,309,3,0,0,16,250,251,10,14,0,0,251,252,5,125,0,0,252,309,
  	3,0,0,15,253,254,10,13,0,0,254,255,5,126,0,0,255,309,3,0,0,14,256,257,
  	10,12,0,0,257,258,5,110,0,0,258,309,3,0,0,13,259,260,10,11,0,0,260,261,
  	5,82,0,0,261,262,3,0,0,0,262,263,5,83,0,0,263,264,3,0,0,12,264,309,1,
  	0,0,0,265,266,10,10,0,0,266,267,5,85,0,0,267,309,3,0,0,11,268,269,10,
  	9,0,0,269,270,3,138,69,0,270,271,3,0,0,10,271,309,1,0,0,0,272,273,10,
  	48,0,0,273,274,5,1,0,0,274,309,3,168,84,0,275,276,10,47,0,0,276,277,5,
  	1,0,0,277,278,3,168,84,0,278,279,3,152,76,0,279,309,1,0,0,0,280,281,10,
  	46,0,0,281,282,5,1,0,0,282,283,5,7,0,0,283,284,5,73,0,0,284,285,3,12,
  	6,0,285,286,5,74,0,0,286,309,1,0,0,0,287,288,10,45,0,0,288,289,5,1,0,
  	0,289,290,5,8,0,0,290,291,5,73,0,0,291,292,3,16,8,0,292,293,5,74,0,0,
  	293,309,1,0,0,0,294,295,10,41,0,0,295,296,5,77,0,0,296,297,3,136,68,0,
  	297,298,5,78,0,0,298,309,1,0,0,0,299,300,10,40,0,0,300,301,5,81,0,0,301,
  	309,3,168,84,0,302,303,10,39,0,0,303,309,3,152,76,0,304,305,10,37,0,0,
  	305,309,5,100,0,0,306,307,10,36,0,0,307,309,5,101,0,0,308,217,1,0,0,0,
  	308,220,1,0,0,0,308,223,1,0,0,0,308,226,1,0,0,0,308,229,1,0,0,0,308,232,
  	1,0,0,0,308,235,1,0,0,0,308,238,1,0,0,0,308,241,1,0,0,0,308,244,1,0,0,
  	0,308,247,1,0,0,0,308,250,1,0,0,0,308,253,1,0,0,0,308,256,1,0,0,0,308,
  	259,1,0,0,0,308,265,1,0,0,0,308,268,1,0,0,0,308,272,1,0,0,0,308,275,1,
  	0,0,0,308,280,1,0,0,0,308,287,1,0,0,0,308,294,1,0,0,0,308,299,1,0,0,0,
  	308,302,1,0,0,0,308,304,1,0,0,0,308,306,1,0,0,0,309,312,1,0,0,0,310,308,
  	1,0,0,0,310,311,1,0,0,0,311,1,1,0,0,0,312,310,1,0,0,0,313,318,3,4,2,0,
  	314,315,5,80,0,0,315,317,3,4,2,0,316,314,1,0,0,0,317,320,1,0,0,0,318,
  	316,1,0,0,0,318,319,1,0,0,0,319,3,1,0,0,0,320,318,1,0,0,0,321,322,5,2,
  	0,0,322,323,3,6,3,0,323,324,5,3,0,0,324,5,1,0,0,0,325,332,5,23,0,0,326,
  	327,5,81,0,0,327,332,5,23,0,0,328,329,5,4,0,0,329,332,5,23,0,0,330,332,
  	3,0,0,0,331,325,1,0,0,0,331,326,1,0,0,0,331,328,1,0,0,0,331,330,1,0,0,
  	0,332,7,1,0,0,0,333,335,3,10,5,0,334,333,1,0,0,0,335,336,1,0,0,0,336,
  	334,1,0,0,0,336,337,1,0,0,0,337,9,1,0,0,0,338,348,5,23,0,0,339,340,5,
  	81,0,0,340,348,5,23,0,0,341,342,5,4,0,0,342,348,5,23,0,0,343,344,5,77,
  	0,0,344,345,5,127,0,0,345,348,5,78,0,0,346,348,5,6,0,0,347,338,1,0,0,
  	0,347,339,1,0,0,0,347,341,1,0,0,0,347,343,1,0,0,0,347,346,1,0,0,0,348,
  	11,1,0,0,0,349,350,5,75,0,0,350,355,3,14,7,0,351,352,5,80,0,0,352,354,
  	3,14,7,0,353,351,1,0,0,0,354,357,1,0,0,0,355,353,1,0,0,0,355,356,1,0,
  	0,0,356,358,1,0,0,0,357,355,1,0,0,0,358,359,5,76,0,0,359,13,1,0,0,0,360,
  	361,5,23,0,0,361,364,5,83,0,0,362,365,3,0,0,0,363,365,5,23,0,0,364,362,
  	1,0,0,0,364,363,1,0,0,0,365,15,1,0,0,0,366,367,5,75,0,0,367,372,3,18,
  	9,0,368,369,5,80,0,0,369,371,3,18,9,0,370,368,1,0,0,0,371,374,1,0,0,0,
  	372,370,1,0,0,0,372,373,1,0,0,0,373,375,1,0,0,0,374,372,1,0,0,0,375,376,
  	5,76,0,0,376,17,1,0,0,0,377,378,5,9,0,0,378,381,5,83,0,0,379,382,3,4,
  	2,0,380,382,3,20,10,0,381,379,1,0,0,0,381,380,1,0,0,0,382,387,1,0,0,0,
  	383,384,5,23,0,0,384,385,5,83,0,0,385,387,3,0,0,0,386,377,1,0,0,0,386,
  	383,1,0,0,0,387,19,1,0,0,0,388,389,5,77,0,0,389,394,3,4,2,0,390,391,5,
  	80,0,0,391,393,3,4,2,0,392,390,1,0,0,0,393,396,1,0,0,0,394,392,1,0,0,
  	0,394,395,1,0,0,0,395,397,1,0,0,0,396,394,1,0,0,0,397,398,5,78,0,0,398,
  	21,1,0,0,0,399,400,5,10,0,0,400,401,5,73,0,0,401,402,3,24,12,0,402,403,
  	5,74,0,0,403,23,1,0,0,0,404,405,5,75,0,0,405,410,3,26,13,0,406,407,5,
  	80,0,0,407,409,3,26,13,0,408,406,1,0,0,0,409,412,1,0,0,0,410,408,1,0,
  	0,0,410,411,1,0,0,0,411,413,1,0,0,0,412,410,1,0,0,0,413,414,5,76,0,0,
  	414,25,1,0,0,0,415,416,5,11,0,0,416,417,5,83,0,0,417,446,5,127,0,0,418,
  	419,5,12,0,0,419,420,5,83,0,0,420,446,7,5,0,0,421,422,5,13,0,0,422,423,
  	5,83,0,0,423,446,3,28,14,0,424,425,5,14,0,0,425,426,5,83,0,0,426,446,
  	3,28,14,0,427,428,5,15,0,0,428,429,5,83,0,0,429,446,3,32,16,0,430,431,
  	5,16,0,0,431,432,5,83,0,0,432,446,5,127,0,0,433,434,5,17,0,0,434,435,
  	5,83,0,0,435,446,7,5,0,0,436,437,5,18,0,0,437,438,5,83,0,0,438,446,5,
  	127,0,0,439,440,5,19,0,0,440,443,5,83,0,0,441,444,3,0,0,0,442,444,5,23,
  	0,0,443,441,1,0,0,0,443,442,1,0,0,0,444,446,1,0,0,0,445,415,1,0,0,0,445,
  	418,1,0,0,0,445,421,1,0,0,0,445,424,1,0,0,0,445,427,1,0,0,0,445,430,1,
  	0,0,0,445,433,1,0,0,0,445,436,1,0,0,0,445,439,1,0,0,0,446,27,1,0,0,0,
  	447,448,5,75,0,0,448,453,3,30,15,0,449,450,5,80,0,0,450,452,3,30,15,0,
  	451,449,1,0,0,0,452,455,1,0,0,0,453,451,1,0,0,0,453,454,1,0,0,0,454,456,
  	1,0,0,0,455,453,1,0,0,0,456,457,5,76,0,0,457,29,1,0,0,0,458,459,5,23,
  	0,0,459,463,5,83,0,0,460,464,5,129,0,0,461,464,5,127,0,0,462,464,3,0,
  	0,0,463,460,1,0,0,0,463,461,1,0,0,0,463,462,1,0,0,0,464,31,1,0,0,0,465,
  	466,5,77,0,0,466,471,3,34,17,0,467,468,5,80,0,0,468,470,3,34,17,0,469,
  	467,1,0,0,0,470,473,1,0,0,0,471,469,1,0,0,0,471,472,1,0,0,0,472,474,1,
  	0,0,0,473,471,1,0,0,0,474,475,5,78,0,0,475,33,1,0,0,0,476,477,5,75,0,
  	0,477,482,3,36,18,0,478,479,5,80,0,0,479,481,3,36,18,0,480,478,1,0,0,
  	0,481,484,1,0,0,0,482,480,1,0,0,0,482,483,1,0,0,0,483,485,1,0,0,0,484,
  	482,1,0,0,0,485,486,5,76,0,0,486,35,1,0,0,0,487,488,5,5,0,0,488,489,5,
  	83,0,0,489,498,5,127,0,0,490,491,5,23,0,0,491,495,5,83,0,0,492,496,5,
  	129,0,0,493,496,5,127,0,0,494,496,3,0,0,0,495,492,1,0,0,0,495,493,1,0,
  	0,0,495,494,1,0,0,0,496,498,1,0,0,0,497,487,1,0,0,0,497,490,1,0,0,0,498,
  	37,1,0,0,0,499,501,3,40,20,0,500,499,1,0,0,0,501,504,1,0,0,0,502,500,
  	1,0,0,0,502,503,1,0,0,0,503,505,1,0,0,0,504,502,1,0,0,0,505,506,5,0,0,
  	1,506,39,1,0,0,0,507,526,3,42,21,0,508,526,3,44,22,0,509,526,3,52,26,
  	0,510,526,3,54,27,0,511,526,3,56,28,0,512,526,3,58,29,0,513,526,3,60,
  	30,0,514,526,3,62,31,0,515,526,3,64,32,0,516,526,3,66,33,0,517,526,3,
  	68,34,0,518,526,3,70,35,0,519,526,3,80,40,0,520,526,3,82,41,0,521,526,
  	3,88,44,0,522,526,3,90,45,0,523,526,3,106,53,0,524,526,3,116,58,0,525,
  	507,1,0,0,0,525,508,1,0,0,0,525,509,1,0,0,0,525,510,1,0,0,0,525,511,1,
  	0,0,0,525,512,1,0,0,0,525,513,1,0,0,0,525,514,1,0,0,0,525,515,1,0,0,0,
  	525,516,1,0,0,0,525,517,1,0,0,0,525,518,1,0,0,0,525,519,1,0,0,0,525,520,
  	1,0,0,0,525,521,1,0,0,0,525,522,1,0,0,0,525,523,1,0,0,0,525,524,1,0,0,
  	0,526,41,1,0,0,0,527,531,5,75,0,0,528,530,3,40,20,0,529,528,1,0,0,0,530,
  	533,1,0,0,0,531,529,1,0,0,0,531,532,1,0,0,0,532,534,1,0,0,0,533,531,1,
  	0,0,0,534,535,5,76,0,0,535,43,1,0,0,0,536,537,3,46,23,0,537,538,5,79,
  	0,0,538,45,1,0,0,0,539,540,3,48,24,0,540,545,3,50,25,0,541,542,5,80,0,
  	0,542,544,3,50,25,0,543,541,1,0,0,0,544,547,1,0,0,0,545,543,1,0,0,0,545,
  	546,1,0,0,0,546,47,1,0,0,0,547,545,1,0,0,0,548,549,7,6,0,0,549,49,1,0,
  	0,0,550,553,3,132,66,0,551,552,5,85,0,0,552,554,3,0,0,0,553,551,1,0,0,
  	0,553,554,1,0,0,0,554,51,1,0,0,0,555,556,5,79,0,0,556,53,1,0,0,0,557,
  	558,3,136,68,0,558,559,5,79,0,0,559,55,1,0,0,0,560,561,5,48,0,0,561,562,
  	5,73,0,0,562,563,3,136,68,0,563,564,5,74,0,0,564,567,3,40,20,0,565,566,
  	5,32,0,0,566,568,3,40,20,0,567,565,1,0,0,0,567,568,1,0,0,0,568,57,1,0,
  	0,0,569,570,5,28,0,0,570,571,3,40,20,0,571,572,5,42,0,0,572,573,5,73,
  	0,0,573,574,3,136,68,0,574,575,5,74,0,0,575,576,5,79,0,0,576,634,1,0,
  	0,0,577,578,5,42,0,0,578,579,5,73,0,0,579,580,3,136,68,0,580,581,5,74,
  	0,0,581,582,3,40,20,0,582,634,1,0,0,0,583,584,5,40,0,0,584,587,5,73,0,
  	0,585,588,3,136,68,0,586,588,3,46,23,0,587,585,1,0,0,0,587,586,1,0,0,
  	0,587,588,1,0,0,0,588,589,1,0,0,0,589,591,5,79,0,0,590,592,3,136,68,0,
  	591,590,1,0,0,0,591,592,1,0,0,0,592,593,1,0,0,0,593,595,5,79,0,0,594,
  	596,3,136,68,0,595,594,1,0,0,0,595,596,1,0,0,0,596,597,1,0,0,0,597,598,
  	5,74,0,0,598,634,3,40,20,0,599,600,5,40,0,0,600,603,5,73,0,0,601,604,
  	3,0,0,0,602,604,3,46,23,0,603,601,1,0,0,0,603,602,1,0,0,0,604,605,1,0,
  	0,0,605,606,5,51,0,0,606,607,3,136,68,0,607,608,5,74,0,0,608,609,3,40,
  	20,0,609,634,1,0,0,0,610,611,5,40,0,0,611,614,5,73,0,0,612,615,3,0,0,
  	0,613,615,3,46,23,0,614,612,1,0,0,0,614,613,1,0,0,0,615,616,1,0,0,0,616,
  	617,5,67,0,0,617,618,3,136,68,0,618,619,5,74,0,0,619,620,3,40,20,0,620,
  	634,1,0,0,0,621,622,5,40,0,0,622,623,5,61,0,0,623,626,5,73,0,0,624,627,
  	3,0,0,0,625,627,3,46,23,0,626,624,1,0,0,0,626,625,1,0,0,0,627,628,1,0,
  	0,0,628,629,5,67,0,0,629,630,3,136,68,0,630,631,5,74,0,0,631,632,3,40,
  	20,0,632,634,1,0,0,0,633,569,1,0,0,0,633,577,1,0,0,0,633,583,1,0,0,0,
  	633,599,1,0,0,0,633,610,1,0,0,0,633,621,1,0,0,0,634,59,1,0,0,0,635,637,
  	5,39,0,0,636,638,5,23,0,0,637,636,1,0,0,0,637,638,1,0,0,0,638,639,1,0,
  	0,0,639,640,5,79,0,0,640,61,1,0,0,0,641,643,5,27,0,0,642,644,5,23,0,0,
  	643,642,1,0,0,0,643,644,1,0,0,0,644,645,1,0,0,0,645,646,5,79,0,0,646,
  	63,1,0,0,0,647,649,5,37,0,0,648,650,3,136,68,0,649,648,1,0,0,0,649,650,
  	1,0,0,0,650,651,1,0,0,0,651,652,5,79,0,0,652,65,1,0,0,0,653,654,5,46,
  	0,0,654,655,5,73,0,0,655,656,3,136,68,0,656,657,5,74,0,0,657,658,3,40,
  	20,0,658,67,1,0,0,0,659,660,5,23,0,0,660,661,5,83,0,0,661,662,3,40,20,
  	0,662,69,1,0,0,0,663,664,5,41,0,0,664,665,5,73,0,0,665,666,3,136,68,0,
  	666,667,5,74,0,0,667,668,3,72,36,0,668,71,1,0,0,0,669,671,5,75,0,0,670,
  	672,3,74,37,0,671,670,1,0,0,0,671,672,1,0,0,0,672,677,1,0,0,0,673,675,
  	3,78,39,0,674,676,3,74,37,0,675,674,1,0,0,0,675,676,1,0,0,0,676,678,1,
  	0,0,0,677,673,1,0,0,0,677,678,1,0,0,0,678,679,1,0,0,0,679,680,5,76,0,
  	0,680,73,1,0,0,0,681,683,3,76,38,0,682,681,1,0,0,0,683,684,1,0,0,0,684,
  	682,1,0,0,0,684,685,1,0,0,0,685,75,1,0,0,0,686,687,5,31,0,0,687,688,3,
  	136,68,0,688,692,5,83,0,0,689,691,3,40,20,0,690,689,1,0,0,0,691,694,1,
  	0,0,0,692,690,1,0,0,0,692,693,1,0,0,0,693,77,1,0,0,0,694,692,1,0,0,0,
  	695,696,5,47,0,0,696,700,5,83,0,0,697,699,3,40,20,0,698,697,1,0,0,0,699,
  	702,1,0,0,0,700,698,1,0,0,0,700,701,1,0,0,0,701,79,1,0,0,0,702,700,1,
  	0,0,0,703,704,5,49,0,0,704,705,3,136,68,0,705,706,5,79,0,0,706,81,1,0,
  	0,0,707,708,5,52,0,0,708,714,3,42,21,0,709,711,3,84,42,0,710,712,3,86,
  	43,0,711,710,1,0,0,0,711,712,1,0,0,0,712,715,1,0,0,0,713,715,3,86,43,
  	0,714,709,1,0,0,0,714,713,1,0,0,0,715,83,1,0,0,0,716,721,5,35,0,0,717,
  	718,5,73,0,0,718,719,3,132,66,0,719,720,5,74,0,0,720,722,1,0,0,0,721,
  	717,1,0,0,0,721,722,1,0,0,0,722,723,1,0,0,0,723,724,3,42,21,0,724,85,
  	1,0,0,0,725,726,5,36,0,0,726,727,3,42,21,0,727,87,1,0,0,0,728,730,5,60,
  	0,0,729,728,1,0,0,0,729,730,1,0,0,0,730,731,1,0,0,0,731,733,5,44,0,0,
  	732,734,5,106,0,0,733,732,1,0,0,0,733,734,1,0,0,0,734,735,1,0,0,0,735,
  	736,5,23,0,0,736,738,5,73,0,0,737,739,3,126,63,0,738,737,1,0,0,0,738,
  	739,1,0,0,0,739,740,1,0,0,0,740,741,5,74,0,0,741,742,3,42,21,0,742,89,
  	1,0,0,0,743,744,5,53,0,0,744,747,5,23,0,0,745,746,5,55,0,0,746,748,3,
  	0,0,0,747,745,1,0,0,0,747,748,1,0,0,0,748,749,1,0,0,0,749,750,3,92,46,
  	0,750,91,1,0,0,0,751,755,5,75,0,0,752,754,3,94,47,0,753,752,1,0,0,0,754,
  	757,1,0,0,0,755,753,1,0,0,0,755,756,1,0,0,0,756,758,1,0,0,0,757,755,1,
  	0,0,0,758,759,5,76,0,0,759,93,1,0,0,0,760,762,5,64,0,0,761,760,1,0,0,
  	0,761,762,1,0,0,0,762,763,1,0,0,0,763,771,3,96,48,0,764,771,3,52,26,0,
  	765,766,3,134,67,0,766,767,5,85,0,0,767,768,3,0,0,0,768,769,5,79,0,0,
  	769,771,1,0,0,0,770,761,1,0,0,0,770,764,1,0,0,0,770,765,1,0,0,0,771,95,
  	1,0,0,0,772,773,3,134,67,0,773,775,5,73,0,0,774,776,3,126,63,0,775,774,
  	1,0,0,0,775,776,1,0,0,0,776,777,1,0,0,0,777,778,5,74,0,0,778,779,3,42,
  	21,0,779,785,1,0,0,0,780,785,3,98,49,0,781,785,3,100,50,0,782,785,3,102,
  	51,0,783,785,3,104,52,0,784,772,1,0,0,0,784,780,1,0,0,0,784,781,1,0,0,
  	0,784,782,1,0,0,0,784,783,1,0,0,0,785,97,1,0,0,0,786,787,5,68,0,0,787,
  	788,3,134,67,0,788,789,5,73,0,0,789,790,5,74,0,0,790,791,3,42,21,0,791,
  	99,1,0,0,0,792,793,5,69,0,0,793,794,3,134,67,0,794,795,5,73,0,0,795,796,
  	3,126,63,0,796,797,5,74,0,0,797,798,3,42,21,0,798,101,1,0,0,0,799,800,
  	5,106,0,0,800,801,3,134,67,0,801,803,5,73,0,0,802,804,3,126,63,0,803,
  	802,1,0,0,0,803,804,1,0,0,0,804,805,1,0,0,0,805,806,5,74,0,0,806,807,
  	3,42,21,0,807,103,1,0,0,0,808,809,5,60,0,0,809,810,3,134,67,0,810,812,
  	5,73,0,0,811,813,3,126,63,0,812,811,1,0,0,0,812,813,1,0,0,0,813,814,1,
  	0,0,0,814,815,5,74,0,0,815,816,3,42,21,0,816,105,1,0,0,0,817,820,5,59,
  	0,0,818,821,3,108,54,0,819,821,5,129,0,0,820,818,1,0,0,0,820,819,1,0,
  	0,0,821,822,1,0,0,0,822,823,5,79,0,0,823,107,1,0,0,0,824,825,5,106,0,
  	0,825,826,5,66,0,0,826,829,5,23,0,0,827,829,3,110,55,0,828,824,1,0,0,
  	0,828,827,1,0,0,0,829,830,1,0,0,0,830,831,5,65,0,0,831,832,5,129,0,0,
  	832,109,1,0,0,0,833,842,5,75,0,0,834,839,3,112,56,0,835,836,5,80,0,0,
  	836,838,3,112,56,0,837,835,1,0,0,0,838,841,1,0,0,0,839,837,1,0,0,0,839,
  	840,1,0,0,0,840,843,1,0,0,0,841,839,1,0,0,0,842,834,1,0,0,0,842,843,1,
  	0,0,0,843,844,1,0,0,0,844,845,5,76,0,0,845,111,1,0,0,0,846,849,5,23,0,
  	0,847,849,3,114,57,0,848,846,1,0,0,0,848,847,1,0,0,0,849,852,1,0,0,0,
  	850,851,5,66,0,0,851,853,5,23,0,0,852,850,1,0,0,0,852,853,1,0,0,0,853,
  	113,1,0,0,0,854,855,7,5,0,0,855,115,1,0,0,0,856,859,5,58,0,0,857,860,
  	3,118,59,0,858,860,3,124,62,0,859,857,1,0,0,0,859,858,1,0,0,0,860,861,
  	1,0,0,0,861,862,5,79,0,0,862,869,1,0,0,0,863,864,5,58,0,0,864,865,5,47,
  	0,0,865,866,3,0,0,0,866,867,5,79,0,0,867,869,1,0,0,0,868,856,1,0,0,0,
  	868,863,1,0,0,0,869,117,1,0,0,0,870,873,5,106,0,0,871,873,3,120,60,0,
  	872,870,1,0,0,0,872,871,1,0,0,0,873,874,1,0,0,0,874,875,5,65,0,0,875,
  	876,5,129,0,0,876,119,1,0,0,0,877,886,5,75,0,0,878,883,3,122,61,0,879,
  	880,5,80,0,0,880,882,3,122,61,0,881,879,1,0,0,0,882,885,1,0,0,0,883,881,
  	1,0,0,0,883,884,1,0,0,0,884,887,1,0,0,0,885,883,1,0,0,0,886,878,1,0,0,
  	0,886,887,1,0,0,0,887,888,1,0,0,0,888,889,5,76,0,0,889,121,1,0,0,0,890,
  	893,5,23,0,0,891,893,3,114,57,0,892,890,1,0,0,0,892,891,1,0,0,0,893,896,
  	1,0,0,0,894,895,5,66,0,0,895,897,3,114,57,0,896,894,1,0,0,0,896,897,1,
  	0,0,0,897,123,1,0,0,0,898,902,3,44,22,0,899,902,3,90,45,0,900,902,3,88,
  	44,0,901,898,1,0,0,0,901,899,1,0,0,0,901,900,1,0,0,0,902,125,1,0,0,0,
  	903,908,3,128,64,0,904,905,5,80,0,0,905,907,3,128,64,0,906,904,1,0,0,
  	0,907,910,1,0,0,0,908,906,1,0,0,0,908,909,1,0,0,0,909,913,1,0,0,0,910,
  	908,1,0,0,0,911,912,5,80,0,0,912,914,3,130,65,0,913,911,1,0,0,0,913,914,
  	1,0,0,0,914,917,1,0,0,0,915,917,3,130,65,0,916,903,1,0,0,0,916,915,1,
  	0,0,0,917,127,1,0,0,0,918,921,3,132,66,0,919,920,5,85,0,0,920,922,3,0,
  	0,0,921,919,1,0,0,0,921,922,1,0,0,0,922,129,1,0,0,0,923,924,5,84,0,0,
  	924,925,3,132,66,0,925,131,1,0,0,0,926,930,5,23,0,0,927,930,3,142,71,
  	0,928,930,3,148,74,0,929,926,1,0,0,0,929,927,1,0,0,0,929,928,1,0,0,0,
  	930,133,1,0,0,0,931,939,3,168,84,0,932,939,5,129,0,0,933,939,5,127,0,
  	0,934,935,5,77,0,0,935,936,3,0,0,0,936,937,5,78,0,0,937,939,1,0,0,0,938,
  	931,1,0,0,0,938,932,1,0,0,0,938,933,1,0,0,0,938,934,1,0,0,0,939,135,1,
  	0,0,0,940,945,3,0,0,0,941,942,5,80,0,0,942,944,3,0,0,0,943,941,1,0,0,
  	0,944,947,1,0,0,0,945,943,1,0,0,0,945,946,1,0,0,0,946,137,1,0,0,0,947,
  	945,1,0,0,0,948,949,7,7,0,0,949,139,1,0,0,0,950,951,7,8,0,0,951,141,1,
  	0,0,0,952,954,5,77,0,0,953,955,3,144,72,0,954,953,1,0,0,0,954,955,1,0,
  	0,0,955,956,1,0,0,0,956,957,5,78,0,0,957,143,1,0,0,0,958,963,3,146,73,
  	0,959,960,5,80,0,0,960,962,3,146,73,0,961,959,1,0,0,0,962,965,1,0,0,0,
  	963,961,1,0,0,0,963,964,1,0,0,0,964,145,1,0,0,0,965,963,1,0,0,0,966,968,
  	5,84,0,0,967,966,1,0,0,0,967,968,1,0,0,0,968,969,1,0,0,0,969,972,3,0,
  	0,0,970,972,5,80,0,0,971,967,1,0,0,0,971,970,1,0,0,0,972,147,1,0,0,0,
  	973,974,5,75,0,0,974,979,3,150,75,0,975,976,5,80,0,0,976,978,3,150,75,
  	0,977,975,1,0,0,0,978,981,1,0,0,0,979,977,1,0,0,0,979,980,1,0,0,0,980,
  	983,1,0,0,0,981,979,1,0,0,0,982,984,5,80,0,0,983,982,1,0,0,0,983,984,
  	1,0,0,0,984,985,1,0,0,0,985,986,5,76,0,0,986,149,1,0,0,0,987,988,3,134,
  	67,0,988,989,5,83,0,0,989,990,3,0,0,0,990,1002,1,0,0,0,991,992,5,77,0,
  	0,992,993,3,0,0,0,993,994,5,78,0,0,994,995,5,83,0,0,995,996,3,0,0,0,996,
  	1002,1,0,0,0,997,1002,3,96,48,0,998,1002,5,23,0,0,999,1000,5,84,0,0,1000,
  	1002,3,0,0,0,1001,987,1,0,0,0,1001,991,1,0,0,0,1001,997,1,0,0,0,1001,
  	998,1,0,0,0,1001,999,1,0,0,0,1002,151,1,0,0,0,1003,1005,5,73,0,0,1004,
  	1006,3,154,77,0,1005,1004,1,0,0,0,1005,1006,1,0,0,0,1006,1007,1,0,0,0,
  	1007,1008,5,74,0,0,1008,153,1,0,0,0,1009,1014,3,156,78,0,1010,1011,5,
  	80,0,0,1011,1013,3,156,78,0,1012,1010,1,0,0,0,1013,1016,1,0,0,0,1014,
  	1012,1,0,0,0,1014,1015,1,0,0,0,1015,155,1,0,0,0,1016,1014,1,0,0,0,1017,
  	1019,5,84,0,0,1018,1017,1,0,0,0,1018,1019,1,0,0,0,1019,1020,1,0,0,0,1020,
  	1021,3,0,0,0,1021,157,1,0,0,0,1022,1024,5,60,0,0,1023,1022,1,0,0,0,1023,
  	1024,1,0,0,0,1024,1025,1,0,0,0,1025,1027,5,44,0,0,1026,1028,5,106,0,0,
  	1027,1026,1,0,0,0,1027,1028,1,0,0,0,1028,1029,1,0,0,0,1029,1031,5,73,
  	0,0,1030,1032,3,126,63,0,1031,1030,1,0,0,0,1031,1032,1,0,0,0,1032,1033,
  	1,0,0,0,1033,1034,5,74,0,0,1034,1035,3,42,21,0,1035,159,1,0,0,0,1036,
  	1038,5,60,0,0,1037,1036,1,0,0,0,1037,1038,1,0,0,0,1038,1039,1,0,0,0,1039,
  	1040,3,162,81,0,1040,1041,5,99,0,0,1041,1042,3,164,82,0,1042,161,1,0,
  	0,0,1043,1050,5,23,0,0,1044,1046,5,73,0,0,1045,1047,3,126,63,0,1046,1045,
  	1,0,0,0,1046,1047,1,0,0,0,1047,1048,1,0,0,0,1048,1050,5,74,0,0,1049,1043,
  	1,0,0,0,1049,1044,1,0,0,0,1050,163,1,0,0,0,1051,1054,3,0,0,0,1052,1054,
  	3,42,21,0,1053,1051,1,0,0,0,1053,1052,1,0,0,0,1054,165,1,0,0,0,1055,1056,
  	5,30,0,0,1056,1057,3,0,0,0,1057,167,1,0,0,0,1058,1061,5,23,0,0,1059,1061,
  	3,170,85,0,1060,1058,1,0,0,0,1060,1059,1,0,0,0,1061,169,1,0,0,0,1062,
  	1066,3,172,86,0,1063,1066,5,70,0,0,1064,1066,5,71,0,0,1065,1062,1,0,0,
  	0,1065,1063,1,0,0,0,1065,1064,1,0,0,0,1066,171,1,0,0,0,1067,1068,7,9,
  	0,0,1068,173,1,0,0,0,99,182,215,308,310,318,331,336,347,355,364,372,381,
  	386,394,410,443,445,453,463,471,482,495,497,502,525,531,545,553,567,587,
  	591,595,603,614,626,633,637,643,649,671,675,677,684,692,700,711,714,721,
  	729,733,738,747,755,761,770,775,784,803,812,820,828,839,842,848,852,859,
  	868,872,883,886,892,896,901,908,913,916,921,929,938,945,954,963,967,971,
  	979,983,1001,1005,1014,1018,1023,1027,1031,1037,1046,1049,1053,1060,1065
  };
  staticData->serializedATN = antlr4::atn::SerializedATNView(serializedATNSegment, sizeof(serializedATNSegment) / sizeof(serializedATNSegment[0]));

  antlr4::atn::ATNDeserializer deserializer;
  staticData->atn = deserializer.deserialize(staticData->serializedATN);

  const size_t count = staticData->atn->getNumberOfDecisions();
  staticData->decisionToDFA.reserve(count);
  for (size_t i = 0; i < count; i++) { 
    staticData->decisionToDFA.emplace_back(staticData->atn->getDecisionState(i), i);
  }
  chtljavascriptParserStaticData = staticData.release();
}

}

CHTLJavaScriptParser::CHTLJavaScriptParser(TokenStream *input) : CHTLJavaScriptParser(input, antlr4::atn::ParserATNSimulatorOptions()) {}

CHTLJavaScriptParser::CHTLJavaScriptParser(TokenStream *input, const antlr4::atn::ParserATNSimulatorOptions &options) : Parser(input) {
  CHTLJavaScriptParser::initialize();
  _interpreter = new atn::ParserATNSimulator(this, *chtljavascriptParserStaticData->atn, chtljavascriptParserStaticData->decisionToDFA, chtljavascriptParserStaticData->sharedContextCache, options);
}

CHTLJavaScriptParser::~CHTLJavaScriptParser() {
  delete _interpreter;
}

const atn::ATN& CHTLJavaScriptParser::getATN() const {
  return *chtljavascriptParserStaticData->atn;
}

std::string CHTLJavaScriptParser::getGrammarFileName() const {
  return "CHTLJavaScript.g4";
}

const std::vector<std::string>& CHTLJavaScriptParser::getRuleNames() const {
  return chtljavascriptParserStaticData->ruleNames;
}

const dfa::Vocabulary& CHTLJavaScriptParser::getVocabulary() const {
  return chtljavascriptParserStaticData->vocabulary;
}

antlr4::atn::SerializedATNView CHTLJavaScriptParser::getSerializedATN() const {
  return chtljavascriptParserStaticData->serializedATN;
}


//----------------- SingleExpressionContext ------------------------------------------------------------------

CHTLJavaScriptParser::SingleExpressionContext::SingleExpressionContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

CHTLJavaScriptParser::ChtlSelectorContext* CHTLJavaScriptParser::SingleExpressionContext::chtlSelector() {
  return getRuleContext<CHTLJavaScriptParser::ChtlSelectorContext>(0);
}

CHTLJavaScriptParser::AnimateCallContext* CHTLJavaScriptParser::SingleExpressionContext::animateCall() {
  return getRuleContext<CHTLJavaScriptParser::AnimateCallContext>(0);
}

CHTLJavaScriptParser::AnonymousFunctionContext* CHTLJavaScriptParser::SingleExpressionContext::anonymousFunction() {
  return getRuleContext<CHTLJavaScriptParser::AnonymousFunctionContext>(0);
}

CHTLJavaScriptParser::ArrowFunctionContext* CHTLJavaScriptParser::SingleExpressionContext::arrowFunction() {
  return getRuleContext<CHTLJavaScriptParser::ArrowFunctionContext>(0);
}

tree::TerminalNode* CHTLJavaScriptParser::SingleExpressionContext::NEW() {
  return getToken(CHTLJavaScriptParser::NEW, 0);
}

std::vector<CHTLJavaScriptParser::SingleExpressionContext *> CHTLJavaScriptParser::SingleExpressionContext::singleExpression() {
  return getRuleContexts<CHTLJavaScriptParser::SingleExpressionContext>();
}

CHTLJavaScriptParser::SingleExpressionContext* CHTLJavaScriptParser::SingleExpressionContext::singleExpression(size_t i) {
  return getRuleContext<CHTLJavaScriptParser::SingleExpressionContext>(i);
}

CHTLJavaScriptParser::ArgumentsContext* CHTLJavaScriptParser::SingleExpressionContext::arguments() {
  return getRuleContext<CHTLJavaScriptParser::ArgumentsContext>(0);
}

tree::TerminalNode* CHTLJavaScriptParser::SingleExpressionContext::DELETE() {
  return getToken(CHTLJavaScriptParser::DELETE, 0);
}

tree::TerminalNode* CHTLJavaScriptParser::SingleExpressionContext::VOID() {
  return getToken(CHTLJavaScriptParser::VOID, 0);
}

tree::TerminalNode* CHTLJavaScriptParser::SingleExpressionContext::TYPEOF() {
  return getToken(CHTLJavaScriptParser::TYPEOF, 0);
}

tree::TerminalNode* CHTLJavaScriptParser::SingleExpressionContext::PLUSPLUS() {
  return getToken(CHTLJavaScriptParser::PLUSPLUS, 0);
}

tree::TerminalNode* CHTLJavaScriptParser::SingleExpressionContext::MINUSMINUS() {
  return getToken(CHTLJavaScriptParser::MINUSMINUS, 0);
}

tree::TerminalNode* CHTLJavaScriptParser::SingleExpressionContext::PLUS() {
  return getToken(CHTLJavaScriptParser::PLUS, 0);
}

tree::TerminalNode* CHTLJavaScriptParser::SingleExpressionContext::MINUS() {
  return getToken(CHTLJavaScriptParser::MINUS, 0);
}

tree::TerminalNode* CHTLJavaScriptParser::SingleExpressionContext::TILDE() {
  return getToken(CHTLJavaScriptParser::TILDE, 0);
}

tree::TerminalNode* CHTLJavaScriptParser::SingleExpressionContext::EXCLAMATION() {
  return getToken(CHTLJavaScriptParser::EXCLAMATION, 0);
}

tree::TerminalNode* CHTLJavaScriptParser::SingleExpressionContext::AWAIT() {
  return getToken(CHTLJavaScriptParser::AWAIT, 0);
}

tree::TerminalNode* CHTLJavaScriptParser::SingleExpressionContext::THIS() {
  return getToken(CHTLJavaScriptParser::THIS, 0);
}

tree::TerminalNode* CHTLJavaScriptParser::SingleExpressionContext::IDENTIFIER() {
  return getToken(CHTLJavaScriptParser::IDENTIFIER, 0);
}

tree::TerminalNode* CHTLJavaScriptParser::SingleExpressionContext::SUPER() {
  return getToken(CHTLJavaScriptParser::SUPER, 0);
}

CHTLJavaScriptParser::LiteralContext* CHTLJavaScriptParser::SingleExpressionContext::literal() {
  return getRuleContext<CHTLJavaScriptParser::LiteralContext>(0);
}

CHTLJavaScriptParser::ArrayLiteralContext* CHTLJavaScriptParser::SingleExpressionContext::arrayLiteral() {
  return getRuleContext<CHTLJavaScriptParser::ArrayLiteralContext>(0);
}

CHTLJavaScriptParser::ObjectLiteralContext* CHTLJavaScriptParser::SingleExpressionContext::objectLiteral() {
  return getRuleContext<CHTLJavaScriptParser::ObjectLiteralContext>(0);
}

tree::TerminalNode* CHTLJavaScriptParser::SingleExpressionContext::LPAREN() {
  return getToken(CHTLJavaScriptParser::LPAREN, 0);
}

CHTLJavaScriptParser::ExpressionSequenceContext* CHTLJavaScriptParser::SingleExpressionContext::expressionSequence() {
  return getRuleContext<CHTLJavaScriptParser::ExpressionSequenceContext>(0);
}

tree::TerminalNode* CHTLJavaScriptParser::SingleExpressionContext::RPAREN() {
  return getToken(CHTLJavaScriptParser::RPAREN, 0);
}

CHTLJavaScriptParser::TypeofExpressionContext* CHTLJavaScriptParser::SingleExpressionContext::typeofExpression() {
  return getRuleContext<CHTLJavaScriptParser::TypeofExpressionContext>(0);
}

tree::TerminalNode* CHTLJavaScriptParser::SingleExpressionContext::POWER() {
  return getToken(CHTLJavaScriptParser::POWER, 0);
}

tree::TerminalNode* CHTLJavaScriptParser::SingleExpressionContext::STAR() {
  return getToken(CHTLJavaScriptParser::STAR, 0);
}

tree::TerminalNode* CHTLJavaScriptParser::SingleExpressionContext::SLASH() {
  return getToken(CHTLJavaScriptParser::SLASH, 0);
}

tree::TerminalNode* CHTLJavaScriptParser::SingleExpressionContext::PERCENT() {
  return getToken(CHTLJavaScriptParser::PERCENT, 0);
}

tree::TerminalNode* CHTLJavaScriptParser::SingleExpressionContext::LSHIFT() {
  return getToken(CHTLJavaScriptParser::LSHIFT, 0);
}

tree::TerminalNode* CHTLJavaScriptParser::SingleExpressionContext::RSHIFT() {
  return getToken(CHTLJavaScriptParser::RSHIFT, 0);
}

tree::TerminalNode* CHTLJavaScriptParser::SingleExpressionContext::URSHIFT() {
  return getToken(CHTLJavaScriptParser::URSHIFT, 0);
}

tree::TerminalNode* CHTLJavaScriptParser::SingleExpressionContext::LT() {
  return getToken(CHTLJavaScriptParser::LT, 0);
}

tree::TerminalNode* CHTLJavaScriptParser::SingleExpressionContext::GT() {
  return getToken(CHTLJavaScriptParser::GT, 0);
}

tree::TerminalNode* CHTLJavaScriptParser::SingleExpressionContext::LE() {
  return getToken(CHTLJavaScriptParser::LE, 0);
}

tree::TerminalNode* CHTLJavaScriptParser::SingleExpressionContext::GE() {
  return getToken(CHTLJavaScriptParser::GE, 0);
}

tree::TerminalNode* CHTLJavaScriptParser::SingleExpressionContext::INSTANCEOF() {
  return getToken(CHTLJavaScriptParser::INSTANCEOF, 0);
}

tree::TerminalNode* CHTLJavaScriptParser::SingleExpressionContext::IN() {
  return getToken(CHTLJavaScriptParser::IN, 0);
}

tree::TerminalNode* CHTLJavaScriptParser::SingleExpressionContext::EQUALS_OP() {
  return getToken(CHTLJavaScriptParser::EQUALS_OP, 0);
}

tree::TerminalNode* CHTLJavaScriptParser::SingleExpressionContext::NOT_EQUALS() {
  return getToken(CHTLJavaScriptParser::NOT_EQUALS, 0);
}

tree::TerminalNode* CHTLJavaScriptParser::SingleExpressionContext::STRICT_EQUALS() {
  return getToken(CHTLJavaScriptParser::STRICT_EQUALS, 0);
}

tree::TerminalNode* CHTLJavaScriptParser::SingleExpressionContext::STRICT_NOT_EQUALS() {
  return getToken(CHTLJavaScriptParser::STRICT_NOT_EQUALS, 0);
}

tree::TerminalNode* CHTLJavaScriptParser::SingleExpressionContext::AMPERSAND() {
  return getToken(CHTLJavaScriptParser::AMPERSAND, 0);
}

tree::TerminalNode* CHTLJavaScriptParser::SingleExpressionContext::CARET() {
  return getToken(CHTLJavaScriptParser::CARET, 0);
}

tree::TerminalNode* CHTLJavaScriptParser::SingleExpressionContext::PIPE() {
  return getToken(CHTLJavaScriptParser::PIPE, 0);
}

tree::TerminalNode* CHTLJavaScriptParser::SingleExpressionContext::AND_OP() {
  return getToken(CHTLJavaScriptParser::AND_OP, 0);
}

tree::TerminalNode* CHTLJavaScriptParser::SingleExpressionContext::OR_OP() {
  return getToken(CHTLJavaScriptParser::OR_OP, 0);
}

tree::TerminalNode* CHTLJavaScriptParser::SingleExpressionContext::NULLISH_COALESCING() {
  return getToken(CHTLJavaScriptParser::NULLISH_COALESCING, 0);
}

tree::TerminalNode* CHTLJavaScriptParser::SingleExpressionContext::QUESTION() {
  return getToken(CHTLJavaScriptParser::QUESTION, 0);
}

tree::TerminalNode* CHTLJavaScriptParser::SingleExpressionContext::COLON() {
  return getToken(CHTLJavaScriptParser::COLON, 0);
}

tree::TerminalNode* CHTLJavaScriptParser::SingleExpressionContext::EQUALS() {
  return getToken(CHTLJavaScriptParser::EQUALS, 0);
}

CHTLJavaScriptParser::AssignmentOperatorContext* CHTLJavaScriptParser::SingleExpressionContext::assignmentOperator() {
  return getRuleContext<CHTLJavaScriptParser::AssignmentOperatorContext>(0);
}

tree::TerminalNode* CHTLJavaScriptParser::SingleExpressionContext::CHTL_ARROW() {
  return getToken(CHTLJavaScriptParser::CHTL_ARROW, 0);
}

CHTLJavaScriptParser::IdentifierNameContext* CHTLJavaScriptParser::SingleExpressionContext::identifierName() {
  return getRuleContext<CHTLJavaScriptParser::IdentifierNameContext>(0);
}

tree::TerminalNode* CHTLJavaScriptParser::SingleExpressionContext::LISTEN() {
  return getToken(CHTLJavaScriptParser::LISTEN, 0);
}

CHTLJavaScriptParser::ListenObjectContext* CHTLJavaScriptParser::SingleExpressionContext::listenObject() {
  return getRuleContext<CHTLJavaScriptParser::ListenObjectContext>(0);
}

tree::TerminalNode* CHTLJavaScriptParser::SingleExpressionContext::DELEGATE() {
  return getToken(CHTLJavaScriptParser::DELEGATE, 0);
}

CHTLJavaScriptParser::DelegateObjectContext* CHTLJavaScriptParser::SingleExpressionContext::delegateObject() {
  return getRuleContext<CHTLJavaScriptParser::DelegateObjectContext>(0);
}

tree::TerminalNode* CHTLJavaScriptParser::SingleExpressionContext::LBRACKET() {
  return getToken(CHTLJavaScriptParser::LBRACKET, 0);
}

tree::TerminalNode* CHTLJavaScriptParser::SingleExpressionContext::RBRACKET() {
  return getToken(CHTLJavaScriptParser::RBRACKET, 0);
}

tree::TerminalNode* CHTLJavaScriptParser::SingleExpressionContext::DOT() {
  return getToken(CHTLJavaScriptParser::DOT, 0);
}


size_t CHTLJavaScriptParser::SingleExpressionContext::getRuleIndex() const {
  return CHTLJavaScriptParser::RuleSingleExpression;
}


std::any CHTLJavaScriptParser::SingleExpressionContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<CHTLJavaScriptVisitor*>(visitor))
    return parserVisitor->visitSingleExpression(this);
  else
    return visitor->visitChildren(this);
}


CHTLJavaScriptParser::SingleExpressionContext* CHTLJavaScriptParser::singleExpression() {
   return singleExpression(0);
}

CHTLJavaScriptParser::SingleExpressionContext* CHTLJavaScriptParser::singleExpression(int precedence) {
  ParserRuleContext *parentContext = _ctx;
  size_t parentState = getState();
  CHTLJavaScriptParser::SingleExpressionContext *_localctx = _tracker.createInstance<SingleExpressionContext>(_ctx, parentState);
  CHTLJavaScriptParser::SingleExpressionContext *previousContext = _localctx;
  (void)previousContext; // Silence compiler, in case the context is not used by generated code.
  size_t startState = 0;
  enterRecursionRule(_localctx, 0, CHTLJavaScriptParser::RuleSingleExpression, precedence);

    size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    unrollRecursionContexts(parentContext);
  });
  try {
    size_t alt;
    enterOuterAlt(_localctx, 1);
    setState(215);
    _errHandler->sync(this);
    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 1, _ctx)) {
    case 1: {
      setState(175);
      chtlSelector();
      break;
    }

    case 2: {
      setState(176);
      animateCall();
      break;
    }

    case 3: {
      setState(177);
      anonymousFunction();
      break;
    }

    case 4: {
      setState(178);
      arrowFunction();
      break;
    }

    case 5: {
      setState(179);
      match(CHTLJavaScriptParser::NEW);
      setState(180);
      singleExpression(0);
      setState(182);
      _errHandler->sync(this);

      switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 0, _ctx)) {
      case 1: {
        setState(181);
        arguments();
        break;
      }

      default:
        break;
      }
      break;
    }

    case 6: {
      setState(184);
      match(CHTLJavaScriptParser::DELETE);
      setState(185);
      singleExpression(35);
      break;
    }

    case 7: {
      setState(186);
      match(CHTLJavaScriptParser::VOID);
      setState(187);
      singleExpression(34);
      break;
    }

    case 8: {
      setState(188);
      match(CHTLJavaScriptParser::TYPEOF);
      setState(189);
      singleExpression(33);
      break;
    }

    case 9: {
      setState(190);
      match(CHTLJavaScriptParser::PLUSPLUS);
      setState(191);
      singleExpression(32);
      break;
    }

    case 10: {
      setState(192);
      match(CHTLJavaScriptParser::MINUSMINUS);
      setState(193);
      singleExpression(31);
      break;
    }

    case 11: {
      setState(194);
      match(CHTLJavaScriptParser::PLUS);
      setState(195);
      singleExpression(30);
      break;
    }

    case 12: {
      setState(196);
      match(CHTLJavaScriptParser::MINUS);
      setState(197);
      singleExpression(29);
      break;
    }

    case 13: {
      setState(198);
      match(CHTLJavaScriptParser::TILDE);
      setState(199);
      singleExpression(28);
      break;
    }

    case 14: {
      setState(200);
      match(CHTLJavaScriptParser::EXCLAMATION);
      setState(201);
      singleExpression(27);
      break;
    }

    case 15: {
      setState(202);
      match(CHTLJavaScriptParser::AWAIT);
      setState(203);
      singleExpression(26);
      break;
    }

    case 16: {
      setState(204);
      match(CHTLJavaScriptParser::THIS);
      break;
    }

    case 17: {
      setState(205);
      match(CHTLJavaScriptParser::IDENTIFIER);
      break;
    }

    case 18: {
      setState(206);
      match(CHTLJavaScriptParser::SUPER);
      break;
    }

    case 19: {
      setState(207);
      literal();
      break;
    }

    case 20: {
      setState(208);
      arrayLiteral();
      break;
    }

    case 21: {
      setState(209);
      objectLiteral();
      break;
    }

    case 22: {
      setState(210);
      match(CHTLJavaScriptParser::LPAREN);
      setState(211);
      expressionSequence();
      setState(212);
      match(CHTLJavaScriptParser::RPAREN);
      break;
    }

    case 23: {
      setState(214);
      typeofExpression();
      break;
    }

    default:
      break;
    }
    _ctx->stop = _input->LT(-1);
    setState(310);
    _errHandler->sync(this);
    alt = getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 3, _ctx);
    while (alt != 2 && alt != atn::ATN::INVALID_ALT_NUMBER) {
      if (alt == 1) {
        if (!_parseListeners.empty())
          triggerExitRuleEvent();
        previousContext = _localctx;
        setState(308);
        _errHandler->sync(this);
        switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 2, _ctx)) {
        case 1: {
          _localctx = _tracker.createInstance<SingleExpressionContext>(parentContext, parentState);
          pushNewRecursionContext(_localctx, startState, RuleSingleExpression);
          setState(217);

          if (!(precpred(_ctx, 25))) throw FailedPredicateException(this, "precpred(_ctx, 25)");
          setState(218);
          match(CHTLJavaScriptParser::POWER);
          setState(219);
          singleExpression(26);
          break;
        }

        case 2: {
          _localctx = _tracker.createInstance<SingleExpressionContext>(parentContext, parentState);
          pushNewRecursionContext(_localctx, startState, RuleSingleExpression);
          setState(220);

          if (!(precpred(_ctx, 24))) throw FailedPredicateException(this, "precpred(_ctx, 24)");
          setState(221);
          _la = _input->LA(1);
          if (!(((((_la - 106) & ~ 0x3fULL) == 0) &&
            ((1ULL << (_la - 106)) & 7) != 0))) {
          _errHandler->recoverInline(this);
          }
          else {
            _errHandler->reportMatch(this);
            consume();
          }
          setState(222);
          singleExpression(25);
          break;
        }

        case 3: {
          _localctx = _tracker.createInstance<SingleExpressionContext>(parentContext, parentState);
          pushNewRecursionContext(_localctx, startState, RuleSingleExpression);
          setState(223);

          if (!(precpred(_ctx, 23))) throw FailedPredicateException(this, "precpred(_ctx, 23)");
          setState(224);
          _la = _input->LA(1);
          if (!(_la == CHTLJavaScriptParser::PLUS

          || _la == CHTLJavaScriptParser::MINUS)) {
          _errHandler->recoverInline(this);
          }
          else {
            _errHandler->reportMatch(this);
            consume();
          }
          setState(225);
          singleExpression(24);
          break;
        }

        case 4: {
          _localctx = _tracker.createInstance<SingleExpressionContext>(parentContext, parentState);
          pushNewRecursionContext(_localctx, startState, RuleSingleExpression);
          setState(226);

          if (!(precpred(_ctx, 22))) throw FailedPredicateException(this, "precpred(_ctx, 22)");
          setState(227);
          _la = _input->LA(1);
          if (!(((((_la - 111) & ~ 0x3fULL) == 0) &&
            ((1ULL << (_la - 111)) & 7) != 0))) {
          _errHandler->recoverInline(this);
          }
          else {
            _errHandler->reportMatch(this);
            consume();
          }
          setState(228);
          singleExpression(23);
          break;
        }

        case 5: {
          _localctx = _tracker.createInstance<SingleExpressionContext>(parentContext, parentState);
          pushNewRecursionContext(_localctx, startState, RuleSingleExpression);
          setState(229);

          if (!(precpred(_ctx, 21))) throw FailedPredicateException(this, "precpred(_ctx, 21)");
          setState(230);
          _la = _input->LA(1);
          if (!(((((_la - 114) & ~ 0x3fULL) == 0) &&
            ((1ULL << (_la - 114)) & 15) != 0))) {
          _errHandler->recoverInline(this);
          }
          else {
            _errHandler->reportMatch(this);
            consume();
          }
          setState(231);
          singleExpression(22);
          break;
        }

        case 6: {
          _localctx = _tracker.createInstance<SingleExpressionContext>(parentContext, parentState);
          pushNewRecursionContext(_localctx, startState, RuleSingleExpression);
          setState(232);

          if (!(precpred(_ctx, 20))) throw FailedPredicateException(this, "precpred(_ctx, 20)");
          setState(233);
          match(CHTLJavaScriptParser::INSTANCEOF);
          setState(234);
          singleExpression(21);
          break;
        }

        case 7: {
          _localctx = _tracker.createInstance<SingleExpressionContext>(parentContext, parentState);
          pushNewRecursionContext(_localctx, startState, RuleSingleExpression);
          setState(235);

          if (!(precpred(_ctx, 19))) throw FailedPredicateException(this, "precpred(_ctx, 19)");
          setState(236);
          match(CHTLJavaScriptParser::IN);
          setState(237);
          singleExpression(20);
          break;
        }

        case 8: {
          _localctx = _tracker.createInstance<SingleExpressionContext>(parentContext, parentState);
          pushNewRecursionContext(_localctx, startState, RuleSingleExpression);
          setState(238);

          if (!(precpred(_ctx, 18))) throw FailedPredicateException(this, "precpred(_ctx, 18)");
          setState(239);
          _la = _input->LA(1);
          if (!(((((_la - 118) & ~ 0x3fULL) == 0) &&
            ((1ULL << (_la - 118)) & 15) != 0))) {
          _errHandler->recoverInline(this);
          }
          else {
            _errHandler->reportMatch(this);
            consume();
          }
          setState(240);
          singleExpression(19);
          break;
        }

        case 9: {
          _localctx = _tracker.createInstance<SingleExpressionContext>(parentContext, parentState);
          pushNewRecursionContext(_localctx, startState, RuleSingleExpression);
          setState(241);

          if (!(precpred(_ctx, 17))) throw FailedPredicateException(this, "precpred(_ctx, 17)");
          setState(242);
          match(CHTLJavaScriptParser::AMPERSAND);
          setState(243);
          singleExpression(18);
          break;
        }

        case 10: {
          _localctx = _tracker.createInstance<SingleExpressionContext>(parentContext, parentState);
          pushNewRecursionContext(_localctx, startState, RuleSingleExpression);
          setState(244);

          if (!(precpred(_ctx, 16))) throw FailedPredicateException(this, "precpred(_ctx, 16)");
          setState(245);
          match(CHTLJavaScriptParser::CARET);
          setState(246);
          singleExpression(17);
          break;
        }

        case 11: {
          _localctx = _tracker.createInstance<SingleExpressionContext>(parentContext, parentState);
          pushNewRecursionContext(_localctx, startState, RuleSingleExpression);
          setState(247);

          if (!(precpred(_ctx, 15))) throw FailedPredicateException(this, "precpred(_ctx, 15)");
          setState(248);
          match(CHTLJavaScriptParser::PIPE);
          setState(249);
          singleExpression(16);
          break;
        }

        case 12: {
          _localctx = _tracker.createInstance<SingleExpressionContext>(parentContext, parentState);
          pushNewRecursionContext(_localctx, startState, RuleSingleExpression);
          setState(250);

          if (!(precpred(_ctx, 14))) throw FailedPredicateException(this, "precpred(_ctx, 14)");
          setState(251);
          match(CHTLJavaScriptParser::AND_OP);
          setState(252);
          singleExpression(15);
          break;
        }

        case 13: {
          _localctx = _tracker.createInstance<SingleExpressionContext>(parentContext, parentState);
          pushNewRecursionContext(_localctx, startState, RuleSingleExpression);
          setState(253);

          if (!(precpred(_ctx, 13))) throw FailedPredicateException(this, "precpred(_ctx, 13)");
          setState(254);
          match(CHTLJavaScriptParser::OR_OP);
          setState(255);
          singleExpression(14);
          break;
        }

        case 14: {
          _localctx = _tracker.createInstance<SingleExpressionContext>(parentContext, parentState);
          pushNewRecursionContext(_localctx, startState, RuleSingleExpression);
          setState(256);

          if (!(precpred(_ctx, 12))) throw FailedPredicateException(this, "precpred(_ctx, 12)");
          setState(257);
          match(CHTLJavaScriptParser::NULLISH_COALESCING);
          setState(258);
          singleExpression(13);
          break;
        }

        case 15: {
          _localctx = _tracker.createInstance<SingleExpressionContext>(parentContext, parentState);
          pushNewRecursionContext(_localctx, startState, RuleSingleExpression);
          setState(259);

          if (!(precpred(_ctx, 11))) throw FailedPredicateException(this, "precpred(_ctx, 11)");
          setState(260);
          match(CHTLJavaScriptParser::QUESTION);
          setState(261);
          singleExpression(0);
          setState(262);
          match(CHTLJavaScriptParser::COLON);
          setState(263);
          singleExpression(12);
          break;
        }

        case 16: {
          _localctx = _tracker.createInstance<SingleExpressionContext>(parentContext, parentState);
          pushNewRecursionContext(_localctx, startState, RuleSingleExpression);
          setState(265);

          if (!(precpred(_ctx, 10))) throw FailedPredicateException(this, "precpred(_ctx, 10)");
          setState(266);
          match(CHTLJavaScriptParser::EQUALS);
          setState(267);
          singleExpression(11);
          break;
        }

        case 17: {
          _localctx = _tracker.createInstance<SingleExpressionContext>(parentContext, parentState);
          pushNewRecursionContext(_localctx, startState, RuleSingleExpression);
          setState(268);

          if (!(precpred(_ctx, 9))) throw FailedPredicateException(this, "precpred(_ctx, 9)");
          setState(269);
          assignmentOperator();
          setState(270);
          singleExpression(10);
          break;
        }

        case 18: {
          _localctx = _tracker.createInstance<SingleExpressionContext>(parentContext, parentState);
          pushNewRecursionContext(_localctx, startState, RuleSingleExpression);
          setState(272);

          if (!(precpred(_ctx, 48))) throw FailedPredicateException(this, "precpred(_ctx, 48)");
          setState(273);
          match(CHTLJavaScriptParser::CHTL_ARROW);
          setState(274);
          identifierName();
          break;
        }

        case 19: {
          _localctx = _tracker.createInstance<SingleExpressionContext>(parentContext, parentState);
          pushNewRecursionContext(_localctx, startState, RuleSingleExpression);
          setState(275);

          if (!(precpred(_ctx, 47))) throw FailedPredicateException(this, "precpred(_ctx, 47)");
          setState(276);
          match(CHTLJavaScriptParser::CHTL_ARROW);
          setState(277);
          identifierName();
          setState(278);
          arguments();
          break;
        }

        case 20: {
          _localctx = _tracker.createInstance<SingleExpressionContext>(parentContext, parentState);
          pushNewRecursionContext(_localctx, startState, RuleSingleExpression);
          setState(280);

          if (!(precpred(_ctx, 46))) throw FailedPredicateException(this, "precpred(_ctx, 46)");
          setState(281);
          match(CHTLJavaScriptParser::CHTL_ARROW);
          setState(282);
          match(CHTLJavaScriptParser::LISTEN);
          setState(283);
          match(CHTLJavaScriptParser::LPAREN);
          setState(284);
          listenObject();
          setState(285);
          match(CHTLJavaScriptParser::RPAREN);
          break;
        }

        case 21: {
          _localctx = _tracker.createInstance<SingleExpressionContext>(parentContext, parentState);
          pushNewRecursionContext(_localctx, startState, RuleSingleExpression);
          setState(287);

          if (!(precpred(_ctx, 45))) throw FailedPredicateException(this, "precpred(_ctx, 45)");
          setState(288);
          match(CHTLJavaScriptParser::CHTL_ARROW);
          setState(289);
          match(CHTLJavaScriptParser::DELEGATE);
          setState(290);
          match(CHTLJavaScriptParser::LPAREN);
          setState(291);
          delegateObject();
          setState(292);
          match(CHTLJavaScriptParser::RPAREN);
          break;
        }

        case 22: {
          _localctx = _tracker.createInstance<SingleExpressionContext>(parentContext, parentState);
          pushNewRecursionContext(_localctx, startState, RuleSingleExpression);
          setState(294);

          if (!(precpred(_ctx, 41))) throw FailedPredicateException(this, "precpred(_ctx, 41)");
          setState(295);
          match(CHTLJavaScriptParser::LBRACKET);
          setState(296);
          expressionSequence();
          setState(297);
          match(CHTLJavaScriptParser::RBRACKET);
          break;
        }

        case 23: {
          _localctx = _tracker.createInstance<SingleExpressionContext>(parentContext, parentState);
          pushNewRecursionContext(_localctx, startState, RuleSingleExpression);
          setState(299);

          if (!(precpred(_ctx, 40))) throw FailedPredicateException(this, "precpred(_ctx, 40)");
          setState(300);
          match(CHTLJavaScriptParser::DOT);
          setState(301);
          identifierName();
          break;
        }

        case 24: {
          _localctx = _tracker.createInstance<SingleExpressionContext>(parentContext, parentState);
          pushNewRecursionContext(_localctx, startState, RuleSingleExpression);
          setState(302);

          if (!(precpred(_ctx, 39))) throw FailedPredicateException(this, "precpred(_ctx, 39)");
          setState(303);
          arguments();
          break;
        }

        case 25: {
          _localctx = _tracker.createInstance<SingleExpressionContext>(parentContext, parentState);
          pushNewRecursionContext(_localctx, startState, RuleSingleExpression);
          setState(304);

          if (!(precpred(_ctx, 37))) throw FailedPredicateException(this, "precpred(_ctx, 37)");
          setState(305);
          match(CHTLJavaScriptParser::PLUSPLUS);
          break;
        }

        case 26: {
          _localctx = _tracker.createInstance<SingleExpressionContext>(parentContext, parentState);
          pushNewRecursionContext(_localctx, startState, RuleSingleExpression);
          setState(306);

          if (!(precpred(_ctx, 36))) throw FailedPredicateException(this, "precpred(_ctx, 36)");
          setState(307);
          match(CHTLJavaScriptParser::MINUSMINUS);
          break;
        }

        default:
          break;
        } 
      }
      setState(312);
      _errHandler->sync(this);
      alt = getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 3, _ctx);
    }
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }
  return _localctx;
}

//----------------- ChtlSelectorListContext ------------------------------------------------------------------

CHTLJavaScriptParser::ChtlSelectorListContext::ChtlSelectorListContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

std::vector<CHTLJavaScriptParser::ChtlSelectorContext *> CHTLJavaScriptParser::ChtlSelectorListContext::chtlSelector() {
  return getRuleContexts<CHTLJavaScriptParser::ChtlSelectorContext>();
}

CHTLJavaScriptParser::ChtlSelectorContext* CHTLJavaScriptParser::ChtlSelectorListContext::chtlSelector(size_t i) {
  return getRuleContext<CHTLJavaScriptParser::ChtlSelectorContext>(i);
}

std::vector<tree::TerminalNode *> CHTLJavaScriptParser::ChtlSelectorListContext::COMMA() {
  return getTokens(CHTLJavaScriptParser::COMMA);
}

tree::TerminalNode* CHTLJavaScriptParser::ChtlSelectorListContext::COMMA(size_t i) {
  return getToken(CHTLJavaScriptParser::COMMA, i);
}


size_t CHTLJavaScriptParser::ChtlSelectorListContext::getRuleIndex() const {
  return CHTLJavaScriptParser::RuleChtlSelectorList;
}


std::any CHTLJavaScriptParser::ChtlSelectorListContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<CHTLJavaScriptVisitor*>(visitor))
    return parserVisitor->visitChtlSelectorList(this);
  else
    return visitor->visitChildren(this);
}

CHTLJavaScriptParser::ChtlSelectorListContext* CHTLJavaScriptParser::chtlSelectorList() {
  ChtlSelectorListContext *_localctx = _tracker.createInstance<ChtlSelectorListContext>(_ctx, getState());
  enterRule(_localctx, 2, CHTLJavaScriptParser::RuleChtlSelectorList);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(313);
    chtlSelector();
    setState(318);
    _errHandler->sync(this);
    _la = _input->LA(1);
    while (_la == CHTLJavaScriptParser::COMMA) {
      setState(314);
      match(CHTLJavaScriptParser::COMMA);
      setState(315);
      chtlSelector();
      setState(320);
      _errHandler->sync(this);
      _la = _input->LA(1);
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- ChtlSelectorContext ------------------------------------------------------------------

CHTLJavaScriptParser::ChtlSelectorContext::ChtlSelectorContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* CHTLJavaScriptParser::ChtlSelectorContext::CHTL_SELECTOR_START() {
  return getToken(CHTLJavaScriptParser::CHTL_SELECTOR_START, 0);
}

CHTLJavaScriptParser::ChtlSelectorContentContext* CHTLJavaScriptParser::ChtlSelectorContext::chtlSelectorContent() {
  return getRuleContext<CHTLJavaScriptParser::ChtlSelectorContentContext>(0);
}

tree::TerminalNode* CHTLJavaScriptParser::ChtlSelectorContext::CHTL_SELECTOR_END() {
  return getToken(CHTLJavaScriptParser::CHTL_SELECTOR_END, 0);
}


size_t CHTLJavaScriptParser::ChtlSelectorContext::getRuleIndex() const {
  return CHTLJavaScriptParser::RuleChtlSelector;
}


std::any CHTLJavaScriptParser::ChtlSelectorContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<CHTLJavaScriptVisitor*>(visitor))
    return parserVisitor->visitChtlSelector(this);
  else
    return visitor->visitChildren(this);
}

CHTLJavaScriptParser::ChtlSelectorContext* CHTLJavaScriptParser::chtlSelector() {
  ChtlSelectorContext *_localctx = _tracker.createInstance<ChtlSelectorContext>(_ctx, getState());
  enterRule(_localctx, 4, CHTLJavaScriptParser::RuleChtlSelector);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(321);
    match(CHTLJavaScriptParser::CHTL_SELECTOR_START);
    setState(322);
    chtlSelectorContent();
    setState(323);
    match(CHTLJavaScriptParser::CHTL_SELECTOR_END);
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- ChtlSelectorContentContext ------------------------------------------------------------------

CHTLJavaScriptParser::ChtlSelectorContentContext::ChtlSelectorContentContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* CHTLJavaScriptParser::ChtlSelectorContentContext::IDENTIFIER() {
  return getToken(CHTLJavaScriptParser::IDENTIFIER, 0);
}

tree::TerminalNode* CHTLJavaScriptParser::ChtlSelectorContentContext::DOT() {
  return getToken(CHTLJavaScriptParser::DOT, 0);
}

tree::TerminalNode* CHTLJavaScriptParser::ChtlSelectorContentContext::HASH() {
  return getToken(CHTLJavaScriptParser::HASH, 0);
}

CHTLJavaScriptParser::SingleExpressionContext* CHTLJavaScriptParser::ChtlSelectorContentContext::singleExpression() {
  return getRuleContext<CHTLJavaScriptParser::SingleExpressionContext>(0);
}


size_t CHTLJavaScriptParser::ChtlSelectorContentContext::getRuleIndex() const {
  return CHTLJavaScriptParser::RuleChtlSelectorContent;
}


std::any CHTLJavaScriptParser::ChtlSelectorContentContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<CHTLJavaScriptVisitor*>(visitor))
    return parserVisitor->visitChtlSelectorContent(this);
  else
    return visitor->visitChildren(this);
}

CHTLJavaScriptParser::ChtlSelectorContentContext* CHTLJavaScriptParser::chtlSelectorContent() {
  ChtlSelectorContentContext *_localctx = _tracker.createInstance<ChtlSelectorContentContext>(_ctx, getState());
  enterRule(_localctx, 6, CHTLJavaScriptParser::RuleChtlSelectorContent);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    setState(331);
    _errHandler->sync(this);
    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 5, _ctx)) {
    case 1: {
      enterOuterAlt(_localctx, 1);
      setState(325);
      match(CHTLJavaScriptParser::IDENTIFIER);
      break;
    }

    case 2: {
      enterOuterAlt(_localctx, 2);
      setState(326);
      match(CHTLJavaScriptParser::DOT);
      setState(327);
      match(CHTLJavaScriptParser::IDENTIFIER);
      break;
    }

    case 3: {
      enterOuterAlt(_localctx, 3);
      setState(328);
      match(CHTLJavaScriptParser::HASH);
      setState(329);
      match(CHTLJavaScriptParser::IDENTIFIER);
      break;
    }

    case 4: {
      enterOuterAlt(_localctx, 4);
      setState(330);
      singleExpression(0);
      break;
    }

    default:
      break;
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- CssSelectorContext ------------------------------------------------------------------

CHTLJavaScriptParser::CssSelectorContext::CssSelectorContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

std::vector<CHTLJavaScriptParser::CssSelectorPartContext *> CHTLJavaScriptParser::CssSelectorContext::cssSelectorPart() {
  return getRuleContexts<CHTLJavaScriptParser::CssSelectorPartContext>();
}

CHTLJavaScriptParser::CssSelectorPartContext* CHTLJavaScriptParser::CssSelectorContext::cssSelectorPart(size_t i) {
  return getRuleContext<CHTLJavaScriptParser::CssSelectorPartContext>(i);
}


size_t CHTLJavaScriptParser::CssSelectorContext::getRuleIndex() const {
  return CHTLJavaScriptParser::RuleCssSelector;
}


std::any CHTLJavaScriptParser::CssSelectorContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<CHTLJavaScriptVisitor*>(visitor))
    return parserVisitor->visitCssSelector(this);
  else
    return visitor->visitChildren(this);
}

CHTLJavaScriptParser::CssSelectorContext* CHTLJavaScriptParser::cssSelector() {
  CssSelectorContext *_localctx = _tracker.createInstance<CssSelectorContext>(_ctx, getState());
  enterRule(_localctx, 8, CHTLJavaScriptParser::RuleCssSelector);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(334); 
    _errHandler->sync(this);
    _la = _input->LA(1);
    do {
      setState(333);
      cssSelectorPart();
      setState(336); 
      _errHandler->sync(this);
      _la = _input->LA(1);
    } while ((((_la & ~ 0x3fULL) == 0) &&
      ((1ULL << _la) & 8388688) != 0) || _la == CHTLJavaScriptParser::LBRACKET

    || _la == CHTLJavaScriptParser::DOT);
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- CssSelectorPartContext ------------------------------------------------------------------

CHTLJavaScriptParser::CssSelectorPartContext::CssSelectorPartContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* CHTLJavaScriptParser::CssSelectorPartContext::IDENTIFIER() {
  return getToken(CHTLJavaScriptParser::IDENTIFIER, 0);
}

tree::TerminalNode* CHTLJavaScriptParser::CssSelectorPartContext::DOT() {
  return getToken(CHTLJavaScriptParser::DOT, 0);
}

tree::TerminalNode* CHTLJavaScriptParser::CssSelectorPartContext::HASH() {
  return getToken(CHTLJavaScriptParser::HASH, 0);
}

tree::TerminalNode* CHTLJavaScriptParser::CssSelectorPartContext::LBRACKET() {
  return getToken(CHTLJavaScriptParser::LBRACKET, 0);
}

tree::TerminalNode* CHTLJavaScriptParser::CssSelectorPartContext::NUMBER() {
  return getToken(CHTLJavaScriptParser::NUMBER, 0);
}

tree::TerminalNode* CHTLJavaScriptParser::CssSelectorPartContext::RBRACKET() {
  return getToken(CHTLJavaScriptParser::RBRACKET, 0);
}

tree::TerminalNode* CHTLJavaScriptParser::CssSelectorPartContext::SPACE() {
  return getToken(CHTLJavaScriptParser::SPACE, 0);
}


size_t CHTLJavaScriptParser::CssSelectorPartContext::getRuleIndex() const {
  return CHTLJavaScriptParser::RuleCssSelectorPart;
}


std::any CHTLJavaScriptParser::CssSelectorPartContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<CHTLJavaScriptVisitor*>(visitor))
    return parserVisitor->visitCssSelectorPart(this);
  else
    return visitor->visitChildren(this);
}

CHTLJavaScriptParser::CssSelectorPartContext* CHTLJavaScriptParser::cssSelectorPart() {
  CssSelectorPartContext *_localctx = _tracker.createInstance<CssSelectorPartContext>(_ctx, getState());
  enterRule(_localctx, 10, CHTLJavaScriptParser::RuleCssSelectorPart);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    setState(347);
    _errHandler->sync(this);
    switch (_input->LA(1)) {
      case CHTLJavaScriptParser::IDENTIFIER: {
        enterOuterAlt(_localctx, 1);
        setState(338);
        match(CHTLJavaScriptParser::IDENTIFIER);
        break;
      }

      case CHTLJavaScriptParser::DOT: {
        enterOuterAlt(_localctx, 2);
        setState(339);
        match(CHTLJavaScriptParser::DOT);
        setState(340);
        match(CHTLJavaScriptParser::IDENTIFIER);
        break;
      }

      case CHTLJavaScriptParser::HASH: {
        enterOuterAlt(_localctx, 3);
        setState(341);
        match(CHTLJavaScriptParser::HASH);
        setState(342);
        match(CHTLJavaScriptParser::IDENTIFIER);
        break;
      }

      case CHTLJavaScriptParser::LBRACKET: {
        enterOuterAlt(_localctx, 4);
        setState(343);
        match(CHTLJavaScriptParser::LBRACKET);
        setState(344);
        match(CHTLJavaScriptParser::NUMBER);
        setState(345);
        match(CHTLJavaScriptParser::RBRACKET);
        break;
      }

      case CHTLJavaScriptParser::SPACE: {
        enterOuterAlt(_localctx, 5);
        setState(346);
        match(CHTLJavaScriptParser::SPACE);
        break;
      }

    default:
      throw NoViableAltException(this);
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- ListenObjectContext ------------------------------------------------------------------

CHTLJavaScriptParser::ListenObjectContext::ListenObjectContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* CHTLJavaScriptParser::ListenObjectContext::LBRACE() {
  return getToken(CHTLJavaScriptParser::LBRACE, 0);
}

std::vector<CHTLJavaScriptParser::EventBindingContext *> CHTLJavaScriptParser::ListenObjectContext::eventBinding() {
  return getRuleContexts<CHTLJavaScriptParser::EventBindingContext>();
}

CHTLJavaScriptParser::EventBindingContext* CHTLJavaScriptParser::ListenObjectContext::eventBinding(size_t i) {
  return getRuleContext<CHTLJavaScriptParser::EventBindingContext>(i);
}

tree::TerminalNode* CHTLJavaScriptParser::ListenObjectContext::RBRACE() {
  return getToken(CHTLJavaScriptParser::RBRACE, 0);
}

std::vector<tree::TerminalNode *> CHTLJavaScriptParser::ListenObjectContext::COMMA() {
  return getTokens(CHTLJavaScriptParser::COMMA);
}

tree::TerminalNode* CHTLJavaScriptParser::ListenObjectContext::COMMA(size_t i) {
  return getToken(CHTLJavaScriptParser::COMMA, i);
}


size_t CHTLJavaScriptParser::ListenObjectContext::getRuleIndex() const {
  return CHTLJavaScriptParser::RuleListenObject;
}


std::any CHTLJavaScriptParser::ListenObjectContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<CHTLJavaScriptVisitor*>(visitor))
    return parserVisitor->visitListenObject(this);
  else
    return visitor->visitChildren(this);
}

CHTLJavaScriptParser::ListenObjectContext* CHTLJavaScriptParser::listenObject() {
  ListenObjectContext *_localctx = _tracker.createInstance<ListenObjectContext>(_ctx, getState());
  enterRule(_localctx, 12, CHTLJavaScriptParser::RuleListenObject);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(349);
    match(CHTLJavaScriptParser::LBRACE);
    setState(350);
    eventBinding();
    setState(355);
    _errHandler->sync(this);
    _la = _input->LA(1);
    while (_la == CHTLJavaScriptParser::COMMA) {
      setState(351);
      match(CHTLJavaScriptParser::COMMA);
      setState(352);
      eventBinding();
      setState(357);
      _errHandler->sync(this);
      _la = _input->LA(1);
    }
    setState(358);
    match(CHTLJavaScriptParser::RBRACE);
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- EventBindingContext ------------------------------------------------------------------

CHTLJavaScriptParser::EventBindingContext::EventBindingContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

std::vector<tree::TerminalNode *> CHTLJavaScriptParser::EventBindingContext::IDENTIFIER() {
  return getTokens(CHTLJavaScriptParser::IDENTIFIER);
}

tree::TerminalNode* CHTLJavaScriptParser::EventBindingContext::IDENTIFIER(size_t i) {
  return getToken(CHTLJavaScriptParser::IDENTIFIER, i);
}

tree::TerminalNode* CHTLJavaScriptParser::EventBindingContext::COLON() {
  return getToken(CHTLJavaScriptParser::COLON, 0);
}

CHTLJavaScriptParser::SingleExpressionContext* CHTLJavaScriptParser::EventBindingContext::singleExpression() {
  return getRuleContext<CHTLJavaScriptParser::SingleExpressionContext>(0);
}


size_t CHTLJavaScriptParser::EventBindingContext::getRuleIndex() const {
  return CHTLJavaScriptParser::RuleEventBinding;
}


std::any CHTLJavaScriptParser::EventBindingContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<CHTLJavaScriptVisitor*>(visitor))
    return parserVisitor->visitEventBinding(this);
  else
    return visitor->visitChildren(this);
}

CHTLJavaScriptParser::EventBindingContext* CHTLJavaScriptParser::eventBinding() {
  EventBindingContext *_localctx = _tracker.createInstance<EventBindingContext>(_ctx, getState());
  enterRule(_localctx, 14, CHTLJavaScriptParser::RuleEventBinding);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(360);
    match(CHTLJavaScriptParser::IDENTIFIER);
    setState(361);
    match(CHTLJavaScriptParser::COLON);
    setState(364);
    _errHandler->sync(this);
    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 9, _ctx)) {
    case 1: {
      setState(362);
      singleExpression(0);
      break;
    }

    case 2: {
      setState(363);
      match(CHTLJavaScriptParser::IDENTIFIER);
      break;
    }

    default:
      break;
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- DelegateObjectContext ------------------------------------------------------------------

CHTLJavaScriptParser::DelegateObjectContext::DelegateObjectContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* CHTLJavaScriptParser::DelegateObjectContext::LBRACE() {
  return getToken(CHTLJavaScriptParser::LBRACE, 0);
}

std::vector<CHTLJavaScriptParser::DelegatePropertyContext *> CHTLJavaScriptParser::DelegateObjectContext::delegateProperty() {
  return getRuleContexts<CHTLJavaScriptParser::DelegatePropertyContext>();
}

CHTLJavaScriptParser::DelegatePropertyContext* CHTLJavaScriptParser::DelegateObjectContext::delegateProperty(size_t i) {
  return getRuleContext<CHTLJavaScriptParser::DelegatePropertyContext>(i);
}

tree::TerminalNode* CHTLJavaScriptParser::DelegateObjectContext::RBRACE() {
  return getToken(CHTLJavaScriptParser::RBRACE, 0);
}

std::vector<tree::TerminalNode *> CHTLJavaScriptParser::DelegateObjectContext::COMMA() {
  return getTokens(CHTLJavaScriptParser::COMMA);
}

tree::TerminalNode* CHTLJavaScriptParser::DelegateObjectContext::COMMA(size_t i) {
  return getToken(CHTLJavaScriptParser::COMMA, i);
}


size_t CHTLJavaScriptParser::DelegateObjectContext::getRuleIndex() const {
  return CHTLJavaScriptParser::RuleDelegateObject;
}


std::any CHTLJavaScriptParser::DelegateObjectContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<CHTLJavaScriptVisitor*>(visitor))
    return parserVisitor->visitDelegateObject(this);
  else
    return visitor->visitChildren(this);
}

CHTLJavaScriptParser::DelegateObjectContext* CHTLJavaScriptParser::delegateObject() {
  DelegateObjectContext *_localctx = _tracker.createInstance<DelegateObjectContext>(_ctx, getState());
  enterRule(_localctx, 16, CHTLJavaScriptParser::RuleDelegateObject);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(366);
    match(CHTLJavaScriptParser::LBRACE);
    setState(367);
    delegateProperty();
    setState(372);
    _errHandler->sync(this);
    _la = _input->LA(1);
    while (_la == CHTLJavaScriptParser::COMMA) {
      setState(368);
      match(CHTLJavaScriptParser::COMMA);
      setState(369);
      delegateProperty();
      setState(374);
      _errHandler->sync(this);
      _la = _input->LA(1);
    }
    setState(375);
    match(CHTLJavaScriptParser::RBRACE);
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- DelegatePropertyContext ------------------------------------------------------------------

CHTLJavaScriptParser::DelegatePropertyContext::DelegatePropertyContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* CHTLJavaScriptParser::DelegatePropertyContext::TARGET() {
  return getToken(CHTLJavaScriptParser::TARGET, 0);
}

tree::TerminalNode* CHTLJavaScriptParser::DelegatePropertyContext::COLON() {
  return getToken(CHTLJavaScriptParser::COLON, 0);
}

CHTLJavaScriptParser::ChtlSelectorContext* CHTLJavaScriptParser::DelegatePropertyContext::chtlSelector() {
  return getRuleContext<CHTLJavaScriptParser::ChtlSelectorContext>(0);
}

CHTLJavaScriptParser::SelectorArrayContext* CHTLJavaScriptParser::DelegatePropertyContext::selectorArray() {
  return getRuleContext<CHTLJavaScriptParser::SelectorArrayContext>(0);
}

tree::TerminalNode* CHTLJavaScriptParser::DelegatePropertyContext::IDENTIFIER() {
  return getToken(CHTLJavaScriptParser::IDENTIFIER, 0);
}

CHTLJavaScriptParser::SingleExpressionContext* CHTLJavaScriptParser::DelegatePropertyContext::singleExpression() {
  return getRuleContext<CHTLJavaScriptParser::SingleExpressionContext>(0);
}


size_t CHTLJavaScriptParser::DelegatePropertyContext::getRuleIndex() const {
  return CHTLJavaScriptParser::RuleDelegateProperty;
}


std::any CHTLJavaScriptParser::DelegatePropertyContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<CHTLJavaScriptVisitor*>(visitor))
    return parserVisitor->visitDelegateProperty(this);
  else
    return visitor->visitChildren(this);
}

CHTLJavaScriptParser::DelegatePropertyContext* CHTLJavaScriptParser::delegateProperty() {
  DelegatePropertyContext *_localctx = _tracker.createInstance<DelegatePropertyContext>(_ctx, getState());
  enterRule(_localctx, 18, CHTLJavaScriptParser::RuleDelegateProperty);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    setState(386);
    _errHandler->sync(this);
    switch (_input->LA(1)) {
      case CHTLJavaScriptParser::TARGET: {
        enterOuterAlt(_localctx, 1);
        setState(377);
        match(CHTLJavaScriptParser::TARGET);
        setState(378);
        match(CHTLJavaScriptParser::COLON);
        setState(381);
        _errHandler->sync(this);
        switch (_input->LA(1)) {
          case CHTLJavaScriptParser::CHTL_SELECTOR_START: {
            setState(379);
            chtlSelector();
            break;
          }

          case CHTLJavaScriptParser::LBRACKET: {
            setState(380);
            selectorArray();
            break;
          }

        default:
          throw NoViableAltException(this);
        }
        break;
      }

      case CHTLJavaScriptParser::IDENTIFIER: {
        enterOuterAlt(_localctx, 2);
        setState(383);
        match(CHTLJavaScriptParser::IDENTIFIER);
        setState(384);
        match(CHTLJavaScriptParser::COLON);
        setState(385);
        singleExpression(0);
        break;
      }

    default:
      throw NoViableAltException(this);
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- SelectorArrayContext ------------------------------------------------------------------

CHTLJavaScriptParser::SelectorArrayContext::SelectorArrayContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* CHTLJavaScriptParser::SelectorArrayContext::LBRACKET() {
  return getToken(CHTLJavaScriptParser::LBRACKET, 0);
}

std::vector<CHTLJavaScriptParser::ChtlSelectorContext *> CHTLJavaScriptParser::SelectorArrayContext::chtlSelector() {
  return getRuleContexts<CHTLJavaScriptParser::ChtlSelectorContext>();
}

CHTLJavaScriptParser::ChtlSelectorContext* CHTLJavaScriptParser::SelectorArrayContext::chtlSelector(size_t i) {
  return getRuleContext<CHTLJavaScriptParser::ChtlSelectorContext>(i);
}

tree::TerminalNode* CHTLJavaScriptParser::SelectorArrayContext::RBRACKET() {
  return getToken(CHTLJavaScriptParser::RBRACKET, 0);
}

std::vector<tree::TerminalNode *> CHTLJavaScriptParser::SelectorArrayContext::COMMA() {
  return getTokens(CHTLJavaScriptParser::COMMA);
}

tree::TerminalNode* CHTLJavaScriptParser::SelectorArrayContext::COMMA(size_t i) {
  return getToken(CHTLJavaScriptParser::COMMA, i);
}


size_t CHTLJavaScriptParser::SelectorArrayContext::getRuleIndex() const {
  return CHTLJavaScriptParser::RuleSelectorArray;
}


std::any CHTLJavaScriptParser::SelectorArrayContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<CHTLJavaScriptVisitor*>(visitor))
    return parserVisitor->visitSelectorArray(this);
  else
    return visitor->visitChildren(this);
}

CHTLJavaScriptParser::SelectorArrayContext* CHTLJavaScriptParser::selectorArray() {
  SelectorArrayContext *_localctx = _tracker.createInstance<SelectorArrayContext>(_ctx, getState());
  enterRule(_localctx, 20, CHTLJavaScriptParser::RuleSelectorArray);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(388);
    match(CHTLJavaScriptParser::LBRACKET);
    setState(389);
    chtlSelector();
    setState(394);
    _errHandler->sync(this);
    _la = _input->LA(1);
    while (_la == CHTLJavaScriptParser::COMMA) {
      setState(390);
      match(CHTLJavaScriptParser::COMMA);
      setState(391);
      chtlSelector();
      setState(396);
      _errHandler->sync(this);
      _la = _input->LA(1);
    }
    setState(397);
    match(CHTLJavaScriptParser::RBRACKET);
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- AnimateCallContext ------------------------------------------------------------------

CHTLJavaScriptParser::AnimateCallContext::AnimateCallContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* CHTLJavaScriptParser::AnimateCallContext::ANIMATE() {
  return getToken(CHTLJavaScriptParser::ANIMATE, 0);
}

tree::TerminalNode* CHTLJavaScriptParser::AnimateCallContext::LPAREN() {
  return getToken(CHTLJavaScriptParser::LPAREN, 0);
}

CHTLJavaScriptParser::AnimateObjectContext* CHTLJavaScriptParser::AnimateCallContext::animateObject() {
  return getRuleContext<CHTLJavaScriptParser::AnimateObjectContext>(0);
}

tree::TerminalNode* CHTLJavaScriptParser::AnimateCallContext::RPAREN() {
  return getToken(CHTLJavaScriptParser::RPAREN, 0);
}


size_t CHTLJavaScriptParser::AnimateCallContext::getRuleIndex() const {
  return CHTLJavaScriptParser::RuleAnimateCall;
}


std::any CHTLJavaScriptParser::AnimateCallContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<CHTLJavaScriptVisitor*>(visitor))
    return parserVisitor->visitAnimateCall(this);
  else
    return visitor->visitChildren(this);
}

CHTLJavaScriptParser::AnimateCallContext* CHTLJavaScriptParser::animateCall() {
  AnimateCallContext *_localctx = _tracker.createInstance<AnimateCallContext>(_ctx, getState());
  enterRule(_localctx, 22, CHTLJavaScriptParser::RuleAnimateCall);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(399);
    match(CHTLJavaScriptParser::ANIMATE);
    setState(400);
    match(CHTLJavaScriptParser::LPAREN);
    setState(401);
    animateObject();
    setState(402);
    match(CHTLJavaScriptParser::RPAREN);
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- AnimateObjectContext ------------------------------------------------------------------

CHTLJavaScriptParser::AnimateObjectContext::AnimateObjectContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* CHTLJavaScriptParser::AnimateObjectContext::LBRACE() {
  return getToken(CHTLJavaScriptParser::LBRACE, 0);
}

std::vector<CHTLJavaScriptParser::AnimatePropertyContext *> CHTLJavaScriptParser::AnimateObjectContext::animateProperty() {
  return getRuleContexts<CHTLJavaScriptParser::AnimatePropertyContext>();
}

CHTLJavaScriptParser::AnimatePropertyContext* CHTLJavaScriptParser::AnimateObjectContext::animateProperty(size_t i) {
  return getRuleContext<CHTLJavaScriptParser::AnimatePropertyContext>(i);
}

tree::TerminalNode* CHTLJavaScriptParser::AnimateObjectContext::RBRACE() {
  return getToken(CHTLJavaScriptParser::RBRACE, 0);
}

std::vector<tree::TerminalNode *> CHTLJavaScriptParser::AnimateObjectContext::COMMA() {
  return getTokens(CHTLJavaScriptParser::COMMA);
}

tree::TerminalNode* CHTLJavaScriptParser::AnimateObjectContext::COMMA(size_t i) {
  return getToken(CHTLJavaScriptParser::COMMA, i);
}


size_t CHTLJavaScriptParser::AnimateObjectContext::getRuleIndex() const {
  return CHTLJavaScriptParser::RuleAnimateObject;
}


std::any CHTLJavaScriptParser::AnimateObjectContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<CHTLJavaScriptVisitor*>(visitor))
    return parserVisitor->visitAnimateObject(this);
  else
    return visitor->visitChildren(this);
}

CHTLJavaScriptParser::AnimateObjectContext* CHTLJavaScriptParser::animateObject() {
  AnimateObjectContext *_localctx = _tracker.createInstance<AnimateObjectContext>(_ctx, getState());
  enterRule(_localctx, 24, CHTLJavaScriptParser::RuleAnimateObject);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(404);
    match(CHTLJavaScriptParser::LBRACE);
    setState(405);
    animateProperty();
    setState(410);
    _errHandler->sync(this);
    _la = _input->LA(1);
    while (_la == CHTLJavaScriptParser::COMMA) {
      setState(406);
      match(CHTLJavaScriptParser::COMMA);
      setState(407);
      animateProperty();
      setState(412);
      _errHandler->sync(this);
      _la = _input->LA(1);
    }
    setState(413);
    match(CHTLJavaScriptParser::RBRACE);
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- AnimatePropertyContext ------------------------------------------------------------------

CHTLJavaScriptParser::AnimatePropertyContext::AnimatePropertyContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* CHTLJavaScriptParser::AnimatePropertyContext::DURATION() {
  return getToken(CHTLJavaScriptParser::DURATION, 0);
}

tree::TerminalNode* CHTLJavaScriptParser::AnimatePropertyContext::COLON() {
  return getToken(CHTLJavaScriptParser::COLON, 0);
}

tree::TerminalNode* CHTLJavaScriptParser::AnimatePropertyContext::NUMBER() {
  return getToken(CHTLJavaScriptParser::NUMBER, 0);
}

tree::TerminalNode* CHTLJavaScriptParser::AnimatePropertyContext::EASING() {
  return getToken(CHTLJavaScriptParser::EASING, 0);
}

tree::TerminalNode* CHTLJavaScriptParser::AnimatePropertyContext::IDENTIFIER() {
  return getToken(CHTLJavaScriptParser::IDENTIFIER, 0);
}

tree::TerminalNode* CHTLJavaScriptParser::AnimatePropertyContext::STRING() {
  return getToken(CHTLJavaScriptParser::STRING, 0);
}

tree::TerminalNode* CHTLJavaScriptParser::AnimatePropertyContext::BEGIN_PROP() {
  return getToken(CHTLJavaScriptParser::BEGIN_PROP, 0);
}

CHTLJavaScriptParser::CssObjectContext* CHTLJavaScriptParser::AnimatePropertyContext::cssObject() {
  return getRuleContext<CHTLJavaScriptParser::CssObjectContext>(0);
}

tree::TerminalNode* CHTLJavaScriptParser::AnimatePropertyContext::END_PROP() {
  return getToken(CHTLJavaScriptParser::END_PROP, 0);
}

tree::TerminalNode* CHTLJavaScriptParser::AnimatePropertyContext::WHEN() {
  return getToken(CHTLJavaScriptParser::WHEN, 0);
}

CHTLJavaScriptParser::WhenArrayContext* CHTLJavaScriptParser::AnimatePropertyContext::whenArray() {
  return getRuleContext<CHTLJavaScriptParser::WhenArrayContext>(0);
}

tree::TerminalNode* CHTLJavaScriptParser::AnimatePropertyContext::LOOP() {
  return getToken(CHTLJavaScriptParser::LOOP, 0);
}

tree::TerminalNode* CHTLJavaScriptParser::AnimatePropertyContext::DIRECTION() {
  return getToken(CHTLJavaScriptParser::DIRECTION, 0);
}

tree::TerminalNode* CHTLJavaScriptParser::AnimatePropertyContext::DELAY() {
  return getToken(CHTLJavaScriptParser::DELAY, 0);
}

tree::TerminalNode* CHTLJavaScriptParser::AnimatePropertyContext::CALLBACK() {
  return getToken(CHTLJavaScriptParser::CALLBACK, 0);
}

CHTLJavaScriptParser::SingleExpressionContext* CHTLJavaScriptParser::AnimatePropertyContext::singleExpression() {
  return getRuleContext<CHTLJavaScriptParser::SingleExpressionContext>(0);
}


size_t CHTLJavaScriptParser::AnimatePropertyContext::getRuleIndex() const {
  return CHTLJavaScriptParser::RuleAnimateProperty;
}


std::any CHTLJavaScriptParser::AnimatePropertyContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<CHTLJavaScriptVisitor*>(visitor))
    return parserVisitor->visitAnimateProperty(this);
  else
    return visitor->visitChildren(this);
}

CHTLJavaScriptParser::AnimatePropertyContext* CHTLJavaScriptParser::animateProperty() {
  AnimatePropertyContext *_localctx = _tracker.createInstance<AnimatePropertyContext>(_ctx, getState());
  enterRule(_localctx, 26, CHTLJavaScriptParser::RuleAnimateProperty);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    setState(445);
    _errHandler->sync(this);
    switch (_input->LA(1)) {
      case CHTLJavaScriptParser::DURATION: {
        enterOuterAlt(_localctx, 1);
        setState(415);
        match(CHTLJavaScriptParser::DURATION);
        setState(416);
        match(CHTLJavaScriptParser::COLON);
        setState(417);
        match(CHTLJavaScriptParser::NUMBER);
        break;
      }

      case CHTLJavaScriptParser::EASING: {
        enterOuterAlt(_localctx, 2);
        setState(418);
        match(CHTLJavaScriptParser::EASING);
        setState(419);
        match(CHTLJavaScriptParser::COLON);
        setState(420);
        _la = _input->LA(1);
        if (!(_la == CHTLJavaScriptParser::IDENTIFIER || _la == CHTLJavaScriptParser::STRING)) {
        _errHandler->recoverInline(this);
        }
        else {
          _errHandler->reportMatch(this);
          consume();
        }
        break;
      }

      case CHTLJavaScriptParser::BEGIN_PROP: {
        enterOuterAlt(_localctx, 3);
        setState(421);
        match(CHTLJavaScriptParser::BEGIN_PROP);
        setState(422);
        match(CHTLJavaScriptParser::COLON);
        setState(423);
        cssObject();
        break;
      }

      case CHTLJavaScriptParser::END_PROP: {
        enterOuterAlt(_localctx, 4);
        setState(424);
        match(CHTLJavaScriptParser::END_PROP);
        setState(425);
        match(CHTLJavaScriptParser::COLON);
        setState(426);
        cssObject();
        break;
      }

      case CHTLJavaScriptParser::WHEN: {
        enterOuterAlt(_localctx, 5);
        setState(427);
        match(CHTLJavaScriptParser::WHEN);
        setState(428);
        match(CHTLJavaScriptParser::COLON);
        setState(429);
        whenArray();
        break;
      }

      case CHTLJavaScriptParser::LOOP: {
        enterOuterAlt(_localctx, 6);
        setState(430);
        match(CHTLJavaScriptParser::LOOP);
        setState(431);
        match(CHTLJavaScriptParser::COLON);
        setState(432);
        match(CHTLJavaScriptParser::NUMBER);
        break;
      }

      case CHTLJavaScriptParser::DIRECTION: {
        enterOuterAlt(_localctx, 7);
        setState(433);
        match(CHTLJavaScriptParser::DIRECTION);
        setState(434);
        match(CHTLJavaScriptParser::COLON);
        setState(435);
        _la = _input->LA(1);
        if (!(_la == CHTLJavaScriptParser::IDENTIFIER || _la == CHTLJavaScriptParser::STRING)) {
        _errHandler->recoverInline(this);
        }
        else {
          _errHandler->reportMatch(this);
          consume();
        }
        break;
      }

      case CHTLJavaScriptParser::DELAY: {
        enterOuterAlt(_localctx, 8);
        setState(436);
        match(CHTLJavaScriptParser::DELAY);
        setState(437);
        match(CHTLJavaScriptParser::COLON);
        setState(438);
        match(CHTLJavaScriptParser::NUMBER);
        break;
      }

      case CHTLJavaScriptParser::CALLBACK: {
        enterOuterAlt(_localctx, 9);
        setState(439);
        match(CHTLJavaScriptParser::CALLBACK);
        setState(440);
        match(CHTLJavaScriptParser::COLON);
        setState(443);
        _errHandler->sync(this);
        switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 15, _ctx)) {
        case 1: {
          setState(441);
          singleExpression(0);
          break;
        }

        case 2: {
          setState(442);
          match(CHTLJavaScriptParser::IDENTIFIER);
          break;
        }

        default:
          break;
        }
        break;
      }

    default:
      throw NoViableAltException(this);
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- CssObjectContext ------------------------------------------------------------------

CHTLJavaScriptParser::CssObjectContext::CssObjectContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* CHTLJavaScriptParser::CssObjectContext::LBRACE() {
  return getToken(CHTLJavaScriptParser::LBRACE, 0);
}

std::vector<CHTLJavaScriptParser::CssPropertyContext *> CHTLJavaScriptParser::CssObjectContext::cssProperty() {
  return getRuleContexts<CHTLJavaScriptParser::CssPropertyContext>();
}

CHTLJavaScriptParser::CssPropertyContext* CHTLJavaScriptParser::CssObjectContext::cssProperty(size_t i) {
  return getRuleContext<CHTLJavaScriptParser::CssPropertyContext>(i);
}

tree::TerminalNode* CHTLJavaScriptParser::CssObjectContext::RBRACE() {
  return getToken(CHTLJavaScriptParser::RBRACE, 0);
}

std::vector<tree::TerminalNode *> CHTLJavaScriptParser::CssObjectContext::COMMA() {
  return getTokens(CHTLJavaScriptParser::COMMA);
}

tree::TerminalNode* CHTLJavaScriptParser::CssObjectContext::COMMA(size_t i) {
  return getToken(CHTLJavaScriptParser::COMMA, i);
}


size_t CHTLJavaScriptParser::CssObjectContext::getRuleIndex() const {
  return CHTLJavaScriptParser::RuleCssObject;
}


std::any CHTLJavaScriptParser::CssObjectContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<CHTLJavaScriptVisitor*>(visitor))
    return parserVisitor->visitCssObject(this);
  else
    return visitor->visitChildren(this);
}

CHTLJavaScriptParser::CssObjectContext* CHTLJavaScriptParser::cssObject() {
  CssObjectContext *_localctx = _tracker.createInstance<CssObjectContext>(_ctx, getState());
  enterRule(_localctx, 28, CHTLJavaScriptParser::RuleCssObject);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(447);
    match(CHTLJavaScriptParser::LBRACE);
    setState(448);
    cssProperty();
    setState(453);
    _errHandler->sync(this);
    _la = _input->LA(1);
    while (_la == CHTLJavaScriptParser::COMMA) {
      setState(449);
      match(CHTLJavaScriptParser::COMMA);
      setState(450);
      cssProperty();
      setState(455);
      _errHandler->sync(this);
      _la = _input->LA(1);
    }
    setState(456);
    match(CHTLJavaScriptParser::RBRACE);
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- CssPropertyContext ------------------------------------------------------------------

CHTLJavaScriptParser::CssPropertyContext::CssPropertyContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* CHTLJavaScriptParser::CssPropertyContext::IDENTIFIER() {
  return getToken(CHTLJavaScriptParser::IDENTIFIER, 0);
}

tree::TerminalNode* CHTLJavaScriptParser::CssPropertyContext::COLON() {
  return getToken(CHTLJavaScriptParser::COLON, 0);
}

tree::TerminalNode* CHTLJavaScriptParser::CssPropertyContext::STRING() {
  return getToken(CHTLJavaScriptParser::STRING, 0);
}

tree::TerminalNode* CHTLJavaScriptParser::CssPropertyContext::NUMBER() {
  return getToken(CHTLJavaScriptParser::NUMBER, 0);
}

CHTLJavaScriptParser::SingleExpressionContext* CHTLJavaScriptParser::CssPropertyContext::singleExpression() {
  return getRuleContext<CHTLJavaScriptParser::SingleExpressionContext>(0);
}


size_t CHTLJavaScriptParser::CssPropertyContext::getRuleIndex() const {
  return CHTLJavaScriptParser::RuleCssProperty;
}


std::any CHTLJavaScriptParser::CssPropertyContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<CHTLJavaScriptVisitor*>(visitor))
    return parserVisitor->visitCssProperty(this);
  else
    return visitor->visitChildren(this);
}

CHTLJavaScriptParser::CssPropertyContext* CHTLJavaScriptParser::cssProperty() {
  CssPropertyContext *_localctx = _tracker.createInstance<CssPropertyContext>(_ctx, getState());
  enterRule(_localctx, 30, CHTLJavaScriptParser::RuleCssProperty);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(458);
    match(CHTLJavaScriptParser::IDENTIFIER);
    setState(459);
    match(CHTLJavaScriptParser::COLON);
    setState(463);
    _errHandler->sync(this);
    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 18, _ctx)) {
    case 1: {
      setState(460);
      match(CHTLJavaScriptParser::STRING);
      break;
    }

    case 2: {
      setState(461);
      match(CHTLJavaScriptParser::NUMBER);
      break;
    }

    case 3: {
      setState(462);
      singleExpression(0);
      break;
    }

    default:
      break;
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- WhenArrayContext ------------------------------------------------------------------

CHTLJavaScriptParser::WhenArrayContext::WhenArrayContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* CHTLJavaScriptParser::WhenArrayContext::LBRACKET() {
  return getToken(CHTLJavaScriptParser::LBRACKET, 0);
}

std::vector<CHTLJavaScriptParser::WhenObjectContext *> CHTLJavaScriptParser::WhenArrayContext::whenObject() {
  return getRuleContexts<CHTLJavaScriptParser::WhenObjectContext>();
}

CHTLJavaScriptParser::WhenObjectContext* CHTLJavaScriptParser::WhenArrayContext::whenObject(size_t i) {
  return getRuleContext<CHTLJavaScriptParser::WhenObjectContext>(i);
}

tree::TerminalNode* CHTLJavaScriptParser::WhenArrayContext::RBRACKET() {
  return getToken(CHTLJavaScriptParser::RBRACKET, 0);
}

std::vector<tree::TerminalNode *> CHTLJavaScriptParser::WhenArrayContext::COMMA() {
  return getTokens(CHTLJavaScriptParser::COMMA);
}

tree::TerminalNode* CHTLJavaScriptParser::WhenArrayContext::COMMA(size_t i) {
  return getToken(CHTLJavaScriptParser::COMMA, i);
}


size_t CHTLJavaScriptParser::WhenArrayContext::getRuleIndex() const {
  return CHTLJavaScriptParser::RuleWhenArray;
}


std::any CHTLJavaScriptParser::WhenArrayContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<CHTLJavaScriptVisitor*>(visitor))
    return parserVisitor->visitWhenArray(this);
  else
    return visitor->visitChildren(this);
}

CHTLJavaScriptParser::WhenArrayContext* CHTLJavaScriptParser::whenArray() {
  WhenArrayContext *_localctx = _tracker.createInstance<WhenArrayContext>(_ctx, getState());
  enterRule(_localctx, 32, CHTLJavaScriptParser::RuleWhenArray);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(465);
    match(CHTLJavaScriptParser::LBRACKET);
    setState(466);
    whenObject();
    setState(471);
    _errHandler->sync(this);
    _la = _input->LA(1);
    while (_la == CHTLJavaScriptParser::COMMA) {
      setState(467);
      match(CHTLJavaScriptParser::COMMA);
      setState(468);
      whenObject();
      setState(473);
      _errHandler->sync(this);
      _la = _input->LA(1);
    }
    setState(474);
    match(CHTLJavaScriptParser::RBRACKET);
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- WhenObjectContext ------------------------------------------------------------------

CHTLJavaScriptParser::WhenObjectContext::WhenObjectContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* CHTLJavaScriptParser::WhenObjectContext::LBRACE() {
  return getToken(CHTLJavaScriptParser::LBRACE, 0);
}

std::vector<CHTLJavaScriptParser::WhenPropertyContext *> CHTLJavaScriptParser::WhenObjectContext::whenProperty() {
  return getRuleContexts<CHTLJavaScriptParser::WhenPropertyContext>();
}

CHTLJavaScriptParser::WhenPropertyContext* CHTLJavaScriptParser::WhenObjectContext::whenProperty(size_t i) {
  return getRuleContext<CHTLJavaScriptParser::WhenPropertyContext>(i);
}

tree::TerminalNode* CHTLJavaScriptParser::WhenObjectContext::RBRACE() {
  return getToken(CHTLJavaScriptParser::RBRACE, 0);
}

std::vector<tree::TerminalNode *> CHTLJavaScriptParser::WhenObjectContext::COMMA() {
  return getTokens(CHTLJavaScriptParser::COMMA);
}

tree::TerminalNode* CHTLJavaScriptParser::WhenObjectContext::COMMA(size_t i) {
  return getToken(CHTLJavaScriptParser::COMMA, i);
}


size_t CHTLJavaScriptParser::WhenObjectContext::getRuleIndex() const {
  return CHTLJavaScriptParser::RuleWhenObject;
}


std::any CHTLJavaScriptParser::WhenObjectContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<CHTLJavaScriptVisitor*>(visitor))
    return parserVisitor->visitWhenObject(this);
  else
    return visitor->visitChildren(this);
}

CHTLJavaScriptParser::WhenObjectContext* CHTLJavaScriptParser::whenObject() {
  WhenObjectContext *_localctx = _tracker.createInstance<WhenObjectContext>(_ctx, getState());
  enterRule(_localctx, 34, CHTLJavaScriptParser::RuleWhenObject);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(476);
    match(CHTLJavaScriptParser::LBRACE);
    setState(477);
    whenProperty();
    setState(482);
    _errHandler->sync(this);
    _la = _input->LA(1);
    while (_la == CHTLJavaScriptParser::COMMA) {
      setState(478);
      match(CHTLJavaScriptParser::COMMA);
      setState(479);
      whenProperty();
      setState(484);
      _errHandler->sync(this);
      _la = _input->LA(1);
    }
    setState(485);
    match(CHTLJavaScriptParser::RBRACE);
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- WhenPropertyContext ------------------------------------------------------------------

CHTLJavaScriptParser::WhenPropertyContext::WhenPropertyContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* CHTLJavaScriptParser::WhenPropertyContext::AT() {
  return getToken(CHTLJavaScriptParser::AT, 0);
}

tree::TerminalNode* CHTLJavaScriptParser::WhenPropertyContext::COLON() {
  return getToken(CHTLJavaScriptParser::COLON, 0);
}

tree::TerminalNode* CHTLJavaScriptParser::WhenPropertyContext::NUMBER() {
  return getToken(CHTLJavaScriptParser::NUMBER, 0);
}

tree::TerminalNode* CHTLJavaScriptParser::WhenPropertyContext::IDENTIFIER() {
  return getToken(CHTLJavaScriptParser::IDENTIFIER, 0);
}

tree::TerminalNode* CHTLJavaScriptParser::WhenPropertyContext::STRING() {
  return getToken(CHTLJavaScriptParser::STRING, 0);
}

CHTLJavaScriptParser::SingleExpressionContext* CHTLJavaScriptParser::WhenPropertyContext::singleExpression() {
  return getRuleContext<CHTLJavaScriptParser::SingleExpressionContext>(0);
}


size_t CHTLJavaScriptParser::WhenPropertyContext::getRuleIndex() const {
  return CHTLJavaScriptParser::RuleWhenProperty;
}


std::any CHTLJavaScriptParser::WhenPropertyContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<CHTLJavaScriptVisitor*>(visitor))
    return parserVisitor->visitWhenProperty(this);
  else
    return visitor->visitChildren(this);
}

CHTLJavaScriptParser::WhenPropertyContext* CHTLJavaScriptParser::whenProperty() {
  WhenPropertyContext *_localctx = _tracker.createInstance<WhenPropertyContext>(_ctx, getState());
  enterRule(_localctx, 36, CHTLJavaScriptParser::RuleWhenProperty);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    setState(497);
    _errHandler->sync(this);
    switch (_input->LA(1)) {
      case CHTLJavaScriptParser::AT: {
        enterOuterAlt(_localctx, 1);
        setState(487);
        match(CHTLJavaScriptParser::AT);
        setState(488);
        match(CHTLJavaScriptParser::COLON);
        setState(489);
        match(CHTLJavaScriptParser::NUMBER);
        break;
      }

      case CHTLJavaScriptParser::IDENTIFIER: {
        enterOuterAlt(_localctx, 2);
        setState(490);
        match(CHTLJavaScriptParser::IDENTIFIER);
        setState(491);
        match(CHTLJavaScriptParser::COLON);
        setState(495);
        _errHandler->sync(this);
        switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 21, _ctx)) {
        case 1: {
          setState(492);
          match(CHTLJavaScriptParser::STRING);
          break;
        }

        case 2: {
          setState(493);
          match(CHTLJavaScriptParser::NUMBER);
          break;
        }

        case 3: {
          setState(494);
          singleExpression(0);
          break;
        }

        default:
          break;
        }
        break;
      }

    default:
      throw NoViableAltException(this);
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- ProgramContext ------------------------------------------------------------------

CHTLJavaScriptParser::ProgramContext::ProgramContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* CHTLJavaScriptParser::ProgramContext::EOF() {
  return getToken(CHTLJavaScriptParser::EOF, 0);
}

std::vector<CHTLJavaScriptParser::StatementContext *> CHTLJavaScriptParser::ProgramContext::statement() {
  return getRuleContexts<CHTLJavaScriptParser::StatementContext>();
}

CHTLJavaScriptParser::StatementContext* CHTLJavaScriptParser::ProgramContext::statement(size_t i) {
  return getRuleContext<CHTLJavaScriptParser::StatementContext>(i);
}


size_t CHTLJavaScriptParser::ProgramContext::getRuleIndex() const {
  return CHTLJavaScriptParser::RuleProgram;
}


std::any CHTLJavaScriptParser::ProgramContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<CHTLJavaScriptVisitor*>(visitor))
    return parserVisitor->visitProgram(this);
  else
    return visitor->visitChildren(this);
}

CHTLJavaScriptParser::ProgramContext* CHTLJavaScriptParser::program() {
  ProgramContext *_localctx = _tracker.createInstance<ProgramContext>(_ctx, getState());
  enterRule(_localctx, 38, CHTLJavaScriptParser::RuleProgram);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(502);
    _errHandler->sync(this);
    _la = _input->LA(1);
    while ((((_la & ~ 0x3fULL) == 0) &&
      ((1ULL << _la) & -4668130657528970236) != 0) || ((((_la - 70) & ~ 0x3fULL) == 0) &&
      ((1ULL << (_la - 70)) & 720576008025014959) != 0)) {
      setState(499);
      statement();
      setState(504);
      _errHandler->sync(this);
      _la = _input->LA(1);
    }
    setState(505);
    match(CHTLJavaScriptParser::EOF);
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- StatementContext ------------------------------------------------------------------

CHTLJavaScriptParser::StatementContext::StatementContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

CHTLJavaScriptParser::BlockContext* CHTLJavaScriptParser::StatementContext::block() {
  return getRuleContext<CHTLJavaScriptParser::BlockContext>(0);
}

CHTLJavaScriptParser::VariableStatementContext* CHTLJavaScriptParser::StatementContext::variableStatement() {
  return getRuleContext<CHTLJavaScriptParser::VariableStatementContext>(0);
}

CHTLJavaScriptParser::EmptyStatementContext* CHTLJavaScriptParser::StatementContext::emptyStatement() {
  return getRuleContext<CHTLJavaScriptParser::EmptyStatementContext>(0);
}

CHTLJavaScriptParser::ExpressionStatementContext* CHTLJavaScriptParser::StatementContext::expressionStatement() {
  return getRuleContext<CHTLJavaScriptParser::ExpressionStatementContext>(0);
}

CHTLJavaScriptParser::IfStatementContext* CHTLJavaScriptParser::StatementContext::ifStatement() {
  return getRuleContext<CHTLJavaScriptParser::IfStatementContext>(0);
}

CHTLJavaScriptParser::IterationStatementContext* CHTLJavaScriptParser::StatementContext::iterationStatement() {
  return getRuleContext<CHTLJavaScriptParser::IterationStatementContext>(0);
}

CHTLJavaScriptParser::ContinueStatementContext* CHTLJavaScriptParser::StatementContext::continueStatement() {
  return getRuleContext<CHTLJavaScriptParser::ContinueStatementContext>(0);
}

CHTLJavaScriptParser::BreakStatementContext* CHTLJavaScriptParser::StatementContext::breakStatement() {
  return getRuleContext<CHTLJavaScriptParser::BreakStatementContext>(0);
}

CHTLJavaScriptParser::ReturnStatementContext* CHTLJavaScriptParser::StatementContext::returnStatement() {
  return getRuleContext<CHTLJavaScriptParser::ReturnStatementContext>(0);
}

CHTLJavaScriptParser::WithStatementContext* CHTLJavaScriptParser::StatementContext::withStatement() {
  return getRuleContext<CHTLJavaScriptParser::WithStatementContext>(0);
}

CHTLJavaScriptParser::LabelledStatementContext* CHTLJavaScriptParser::StatementContext::labelledStatement() {
  return getRuleContext<CHTLJavaScriptParser::LabelledStatementContext>(0);
}

CHTLJavaScriptParser::SwitchStatementContext* CHTLJavaScriptParser::StatementContext::switchStatement() {
  return getRuleContext<CHTLJavaScriptParser::SwitchStatementContext>(0);
}

CHTLJavaScriptParser::ThrowStatementContext* CHTLJavaScriptParser::StatementContext::throwStatement() {
  return getRuleContext<CHTLJavaScriptParser::ThrowStatementContext>(0);
}

CHTLJavaScriptParser::TryStatementContext* CHTLJavaScriptParser::StatementContext::tryStatement() {
  return getRuleContext<CHTLJavaScriptParser::TryStatementContext>(0);
}

CHTLJavaScriptParser::FunctionDeclarationContext* CHTLJavaScriptParser::StatementContext::functionDeclaration() {
  return getRuleContext<CHTLJavaScriptParser::FunctionDeclarationContext>(0);
}

CHTLJavaScriptParser::ClassDeclarationContext* CHTLJavaScriptParser::StatementContext::classDeclaration() {
  return getRuleContext<CHTLJavaScriptParser::ClassDeclarationContext>(0);
}

CHTLJavaScriptParser::ImportStatementContext* CHTLJavaScriptParser::StatementContext::importStatement() {
  return getRuleContext<CHTLJavaScriptParser::ImportStatementContext>(0);
}

CHTLJavaScriptParser::ExportStatementContext* CHTLJavaScriptParser::StatementContext::exportStatement() {
  return getRuleContext<CHTLJavaScriptParser::ExportStatementContext>(0);
}


size_t CHTLJavaScriptParser::StatementContext::getRuleIndex() const {
  return CHTLJavaScriptParser::RuleStatement;
}


std::any CHTLJavaScriptParser::StatementContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<CHTLJavaScriptVisitor*>(visitor))
    return parserVisitor->visitStatement(this);
  else
    return visitor->visitChildren(this);
}

CHTLJavaScriptParser::StatementContext* CHTLJavaScriptParser::statement() {
  StatementContext *_localctx = _tracker.createInstance<StatementContext>(_ctx, getState());
  enterRule(_localctx, 40, CHTLJavaScriptParser::RuleStatement);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    setState(525);
    _errHandler->sync(this);
    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 24, _ctx)) {
    case 1: {
      enterOuterAlt(_localctx, 1);
      setState(507);
      block();
      break;
    }

    case 2: {
      enterOuterAlt(_localctx, 2);
      setState(508);
      variableStatement();
      break;
    }

    case 3: {
      enterOuterAlt(_localctx, 3);
      setState(509);
      emptyStatement();
      break;
    }

    case 4: {
      enterOuterAlt(_localctx, 4);
      setState(510);
      expressionStatement();
      break;
    }

    case 5: {
      enterOuterAlt(_localctx, 5);
      setState(511);
      ifStatement();
      break;
    }

    case 6: {
      enterOuterAlt(_localctx, 6);
      setState(512);
      iterationStatement();
      break;
    }

    case 7: {
      enterOuterAlt(_localctx, 7);
      setState(513);
      continueStatement();
      break;
    }

    case 8: {
      enterOuterAlt(_localctx, 8);
      setState(514);
      breakStatement();
      break;
    }

    case 9: {
      enterOuterAlt(_localctx, 9);
      setState(515);
      returnStatement();
      break;
    }

    case 10: {
      enterOuterAlt(_localctx, 10);
      setState(516);
      withStatement();
      break;
    }

    case 11: {
      enterOuterAlt(_localctx, 11);
      setState(517);
      labelledStatement();
      break;
    }

    case 12: {
      enterOuterAlt(_localctx, 12);
      setState(518);
      switchStatement();
      break;
    }

    case 13: {
      enterOuterAlt(_localctx, 13);
      setState(519);
      throwStatement();
      break;
    }

    case 14: {
      enterOuterAlt(_localctx, 14);
      setState(520);
      tryStatement();
      break;
    }

    case 15: {
      enterOuterAlt(_localctx, 15);
      setState(521);
      functionDeclaration();
      break;
    }

    case 16: {
      enterOuterAlt(_localctx, 16);
      setState(522);
      classDeclaration();
      break;
    }

    case 17: {
      enterOuterAlt(_localctx, 17);
      setState(523);
      importStatement();
      break;
    }

    case 18: {
      enterOuterAlt(_localctx, 18);
      setState(524);
      exportStatement();
      break;
    }

    default:
      break;
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- BlockContext ------------------------------------------------------------------

CHTLJavaScriptParser::BlockContext::BlockContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* CHTLJavaScriptParser::BlockContext::LBRACE() {
  return getToken(CHTLJavaScriptParser::LBRACE, 0);
}

tree::TerminalNode* CHTLJavaScriptParser::BlockContext::RBRACE() {
  return getToken(CHTLJavaScriptParser::RBRACE, 0);
}

std::vector<CHTLJavaScriptParser::StatementContext *> CHTLJavaScriptParser::BlockContext::statement() {
  return getRuleContexts<CHTLJavaScriptParser::StatementContext>();
}

CHTLJavaScriptParser::StatementContext* CHTLJavaScriptParser::BlockContext::statement(size_t i) {
  return getRuleContext<CHTLJavaScriptParser::StatementContext>(i);
}


size_t CHTLJavaScriptParser::BlockContext::getRuleIndex() const {
  return CHTLJavaScriptParser::RuleBlock;
}


std::any CHTLJavaScriptParser::BlockContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<CHTLJavaScriptVisitor*>(visitor))
    return parserVisitor->visitBlock(this);
  else
    return visitor->visitChildren(this);
}

CHTLJavaScriptParser::BlockContext* CHTLJavaScriptParser::block() {
  BlockContext *_localctx = _tracker.createInstance<BlockContext>(_ctx, getState());
  enterRule(_localctx, 42, CHTLJavaScriptParser::RuleBlock);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(527);
    match(CHTLJavaScriptParser::LBRACE);
    setState(531);
    _errHandler->sync(this);
    _la = _input->LA(1);
    while ((((_la & ~ 0x3fULL) == 0) &&
      ((1ULL << _la) & -4668130657528970236) != 0) || ((((_la - 70) & ~ 0x3fULL) == 0) &&
      ((1ULL << (_la - 70)) & 720576008025014959) != 0)) {
      setState(528);
      statement();
      setState(533);
      _errHandler->sync(this);
      _la = _input->LA(1);
    }
    setState(534);
    match(CHTLJavaScriptParser::RBRACE);
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- VariableStatementContext ------------------------------------------------------------------

CHTLJavaScriptParser::VariableStatementContext::VariableStatementContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

CHTLJavaScriptParser::VariableDeclarationListContext* CHTLJavaScriptParser::VariableStatementContext::variableDeclarationList() {
  return getRuleContext<CHTLJavaScriptParser::VariableDeclarationListContext>(0);
}

tree::TerminalNode* CHTLJavaScriptParser::VariableStatementContext::SEMICOLON() {
  return getToken(CHTLJavaScriptParser::SEMICOLON, 0);
}


size_t CHTLJavaScriptParser::VariableStatementContext::getRuleIndex() const {
  return CHTLJavaScriptParser::RuleVariableStatement;
}


std::any CHTLJavaScriptParser::VariableStatementContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<CHTLJavaScriptVisitor*>(visitor))
    return parserVisitor->visitVariableStatement(this);
  else
    return visitor->visitChildren(this);
}

CHTLJavaScriptParser::VariableStatementContext* CHTLJavaScriptParser::variableStatement() {
  VariableStatementContext *_localctx = _tracker.createInstance<VariableStatementContext>(_ctx, getState());
  enterRule(_localctx, 44, CHTLJavaScriptParser::RuleVariableStatement);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(536);
    variableDeclarationList();
    setState(537);
    match(CHTLJavaScriptParser::SEMICOLON);
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- VariableDeclarationListContext ------------------------------------------------------------------

CHTLJavaScriptParser::VariableDeclarationListContext::VariableDeclarationListContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

CHTLJavaScriptParser::VarModifierContext* CHTLJavaScriptParser::VariableDeclarationListContext::varModifier() {
  return getRuleContext<CHTLJavaScriptParser::VarModifierContext>(0);
}

std::vector<CHTLJavaScriptParser::VariableDeclarationContext *> CHTLJavaScriptParser::VariableDeclarationListContext::variableDeclaration() {
  return getRuleContexts<CHTLJavaScriptParser::VariableDeclarationContext>();
}

CHTLJavaScriptParser::VariableDeclarationContext* CHTLJavaScriptParser::VariableDeclarationListContext::variableDeclaration(size_t i) {
  return getRuleContext<CHTLJavaScriptParser::VariableDeclarationContext>(i);
}

std::vector<tree::TerminalNode *> CHTLJavaScriptParser::VariableDeclarationListContext::COMMA() {
  return getTokens(CHTLJavaScriptParser::COMMA);
}

tree::TerminalNode* CHTLJavaScriptParser::VariableDeclarationListContext::COMMA(size_t i) {
  return getToken(CHTLJavaScriptParser::COMMA, i);
}


size_t CHTLJavaScriptParser::VariableDeclarationListContext::getRuleIndex() const {
  return CHTLJavaScriptParser::RuleVariableDeclarationList;
}


std::any CHTLJavaScriptParser::VariableDeclarationListContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<CHTLJavaScriptVisitor*>(visitor))
    return parserVisitor->visitVariableDeclarationList(this);
  else
    return visitor->visitChildren(this);
}

CHTLJavaScriptParser::VariableDeclarationListContext* CHTLJavaScriptParser::variableDeclarationList() {
  VariableDeclarationListContext *_localctx = _tracker.createInstance<VariableDeclarationListContext>(_ctx, getState());
  enterRule(_localctx, 46, CHTLJavaScriptParser::RuleVariableDeclarationList);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(539);
    varModifier();
    setState(540);
    variableDeclaration();
    setState(545);
    _errHandler->sync(this);
    _la = _input->LA(1);
    while (_la == CHTLJavaScriptParser::COMMA) {
      setState(541);
      match(CHTLJavaScriptParser::COMMA);
      setState(542);
      variableDeclaration();
      setState(547);
      _errHandler->sync(this);
      _la = _input->LA(1);
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- VarModifierContext ------------------------------------------------------------------

CHTLJavaScriptParser::VarModifierContext::VarModifierContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* CHTLJavaScriptParser::VarModifierContext::VAR() {
  return getToken(CHTLJavaScriptParser::VAR, 0);
}

tree::TerminalNode* CHTLJavaScriptParser::VarModifierContext::LET() {
  return getToken(CHTLJavaScriptParser::LET, 0);
}

tree::TerminalNode* CHTLJavaScriptParser::VarModifierContext::CONST() {
  return getToken(CHTLJavaScriptParser::CONST, 0);
}


size_t CHTLJavaScriptParser::VarModifierContext::getRuleIndex() const {
  return CHTLJavaScriptParser::RuleVarModifier;
}


std::any CHTLJavaScriptParser::VarModifierContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<CHTLJavaScriptVisitor*>(visitor))
    return parserVisitor->visitVarModifier(this);
  else
    return visitor->visitChildren(this);
}

CHTLJavaScriptParser::VarModifierContext* CHTLJavaScriptParser::varModifier() {
  VarModifierContext *_localctx = _tracker.createInstance<VarModifierContext>(_ctx, getState());
  enterRule(_localctx, 48, CHTLJavaScriptParser::RuleVarModifier);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(548);
    _la = _input->LA(1);
    if (!((((_la & ~ 0x3fULL) == 0) &&
      ((1ULL << _la) & -9079256831599050752) != 0))) {
    _errHandler->recoverInline(this);
    }
    else {
      _errHandler->reportMatch(this);
      consume();
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- VariableDeclarationContext ------------------------------------------------------------------

CHTLJavaScriptParser::VariableDeclarationContext::VariableDeclarationContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

CHTLJavaScriptParser::AssignableContext* CHTLJavaScriptParser::VariableDeclarationContext::assignable() {
  return getRuleContext<CHTLJavaScriptParser::AssignableContext>(0);
}

tree::TerminalNode* CHTLJavaScriptParser::VariableDeclarationContext::EQUALS() {
  return getToken(CHTLJavaScriptParser::EQUALS, 0);
}

CHTLJavaScriptParser::SingleExpressionContext* CHTLJavaScriptParser::VariableDeclarationContext::singleExpression() {
  return getRuleContext<CHTLJavaScriptParser::SingleExpressionContext>(0);
}


size_t CHTLJavaScriptParser::VariableDeclarationContext::getRuleIndex() const {
  return CHTLJavaScriptParser::RuleVariableDeclaration;
}


std::any CHTLJavaScriptParser::VariableDeclarationContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<CHTLJavaScriptVisitor*>(visitor))
    return parserVisitor->visitVariableDeclaration(this);
  else
    return visitor->visitChildren(this);
}

CHTLJavaScriptParser::VariableDeclarationContext* CHTLJavaScriptParser::variableDeclaration() {
  VariableDeclarationContext *_localctx = _tracker.createInstance<VariableDeclarationContext>(_ctx, getState());
  enterRule(_localctx, 50, CHTLJavaScriptParser::RuleVariableDeclaration);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(550);
    assignable();
    setState(553);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (_la == CHTLJavaScriptParser::EQUALS) {
      setState(551);
      match(CHTLJavaScriptParser::EQUALS);
      setState(552);
      singleExpression(0);
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- EmptyStatementContext ------------------------------------------------------------------

CHTLJavaScriptParser::EmptyStatementContext::EmptyStatementContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* CHTLJavaScriptParser::EmptyStatementContext::SEMICOLON() {
  return getToken(CHTLJavaScriptParser::SEMICOLON, 0);
}


size_t CHTLJavaScriptParser::EmptyStatementContext::getRuleIndex() const {
  return CHTLJavaScriptParser::RuleEmptyStatement;
}


std::any CHTLJavaScriptParser::EmptyStatementContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<CHTLJavaScriptVisitor*>(visitor))
    return parserVisitor->visitEmptyStatement(this);
  else
    return visitor->visitChildren(this);
}

CHTLJavaScriptParser::EmptyStatementContext* CHTLJavaScriptParser::emptyStatement() {
  EmptyStatementContext *_localctx = _tracker.createInstance<EmptyStatementContext>(_ctx, getState());
  enterRule(_localctx, 52, CHTLJavaScriptParser::RuleEmptyStatement);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(555);
    match(CHTLJavaScriptParser::SEMICOLON);
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- ExpressionStatementContext ------------------------------------------------------------------

CHTLJavaScriptParser::ExpressionStatementContext::ExpressionStatementContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

CHTLJavaScriptParser::ExpressionSequenceContext* CHTLJavaScriptParser::ExpressionStatementContext::expressionSequence() {
  return getRuleContext<CHTLJavaScriptParser::ExpressionSequenceContext>(0);
}

tree::TerminalNode* CHTLJavaScriptParser::ExpressionStatementContext::SEMICOLON() {
  return getToken(CHTLJavaScriptParser::SEMICOLON, 0);
}


size_t CHTLJavaScriptParser::ExpressionStatementContext::getRuleIndex() const {
  return CHTLJavaScriptParser::RuleExpressionStatement;
}


std::any CHTLJavaScriptParser::ExpressionStatementContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<CHTLJavaScriptVisitor*>(visitor))
    return parserVisitor->visitExpressionStatement(this);
  else
    return visitor->visitChildren(this);
}

CHTLJavaScriptParser::ExpressionStatementContext* CHTLJavaScriptParser::expressionStatement() {
  ExpressionStatementContext *_localctx = _tracker.createInstance<ExpressionStatementContext>(_ctx, getState());
  enterRule(_localctx, 54, CHTLJavaScriptParser::RuleExpressionStatement);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(557);
    expressionSequence();
    setState(558);
    match(CHTLJavaScriptParser::SEMICOLON);
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- IfStatementContext ------------------------------------------------------------------

CHTLJavaScriptParser::IfStatementContext::IfStatementContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* CHTLJavaScriptParser::IfStatementContext::IF() {
  return getToken(CHTLJavaScriptParser::IF, 0);
}

tree::TerminalNode* CHTLJavaScriptParser::IfStatementContext::LPAREN() {
  return getToken(CHTLJavaScriptParser::LPAREN, 0);
}

CHTLJavaScriptParser::ExpressionSequenceContext* CHTLJavaScriptParser::IfStatementContext::expressionSequence() {
  return getRuleContext<CHTLJavaScriptParser::ExpressionSequenceContext>(0);
}

tree::TerminalNode* CHTLJavaScriptParser::IfStatementContext::RPAREN() {
  return getToken(CHTLJavaScriptParser::RPAREN, 0);
}

std::vector<CHTLJavaScriptParser::StatementContext *> CHTLJavaScriptParser::IfStatementContext::statement() {
  return getRuleContexts<CHTLJavaScriptParser::StatementContext>();
}

CHTLJavaScriptParser::StatementContext* CHTLJavaScriptParser::IfStatementContext::statement(size_t i) {
  return getRuleContext<CHTLJavaScriptParser::StatementContext>(i);
}

tree::TerminalNode* CHTLJavaScriptParser::IfStatementContext::ELSE() {
  return getToken(CHTLJavaScriptParser::ELSE, 0);
}


size_t CHTLJavaScriptParser::IfStatementContext::getRuleIndex() const {
  return CHTLJavaScriptParser::RuleIfStatement;
}


std::any CHTLJavaScriptParser::IfStatementContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<CHTLJavaScriptVisitor*>(visitor))
    return parserVisitor->visitIfStatement(this);
  else
    return visitor->visitChildren(this);
}

CHTLJavaScriptParser::IfStatementContext* CHTLJavaScriptParser::ifStatement() {
  IfStatementContext *_localctx = _tracker.createInstance<IfStatementContext>(_ctx, getState());
  enterRule(_localctx, 56, CHTLJavaScriptParser::RuleIfStatement);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(560);
    match(CHTLJavaScriptParser::IF);
    setState(561);
    match(CHTLJavaScriptParser::LPAREN);
    setState(562);
    expressionSequence();
    setState(563);
    match(CHTLJavaScriptParser::RPAREN);
    setState(564);
    statement();
    setState(567);
    _errHandler->sync(this);

    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 28, _ctx)) {
    case 1: {
      setState(565);
      match(CHTLJavaScriptParser::ELSE);
      setState(566);
      statement();
      break;
    }

    default:
      break;
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- IterationStatementContext ------------------------------------------------------------------

CHTLJavaScriptParser::IterationStatementContext::IterationStatementContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* CHTLJavaScriptParser::IterationStatementContext::DO() {
  return getToken(CHTLJavaScriptParser::DO, 0);
}

CHTLJavaScriptParser::StatementContext* CHTLJavaScriptParser::IterationStatementContext::statement() {
  return getRuleContext<CHTLJavaScriptParser::StatementContext>(0);
}

tree::TerminalNode* CHTLJavaScriptParser::IterationStatementContext::WHILE() {
  return getToken(CHTLJavaScriptParser::WHILE, 0);
}

tree::TerminalNode* CHTLJavaScriptParser::IterationStatementContext::LPAREN() {
  return getToken(CHTLJavaScriptParser::LPAREN, 0);
}

std::vector<CHTLJavaScriptParser::ExpressionSequenceContext *> CHTLJavaScriptParser::IterationStatementContext::expressionSequence() {
  return getRuleContexts<CHTLJavaScriptParser::ExpressionSequenceContext>();
}

CHTLJavaScriptParser::ExpressionSequenceContext* CHTLJavaScriptParser::IterationStatementContext::expressionSequence(size_t i) {
  return getRuleContext<CHTLJavaScriptParser::ExpressionSequenceContext>(i);
}

tree::TerminalNode* CHTLJavaScriptParser::IterationStatementContext::RPAREN() {
  return getToken(CHTLJavaScriptParser::RPAREN, 0);
}

std::vector<tree::TerminalNode *> CHTLJavaScriptParser::IterationStatementContext::SEMICOLON() {
  return getTokens(CHTLJavaScriptParser::SEMICOLON);
}

tree::TerminalNode* CHTLJavaScriptParser::IterationStatementContext::SEMICOLON(size_t i) {
  return getToken(CHTLJavaScriptParser::SEMICOLON, i);
}

tree::TerminalNode* CHTLJavaScriptParser::IterationStatementContext::FOR() {
  return getToken(CHTLJavaScriptParser::FOR, 0);
}

CHTLJavaScriptParser::VariableDeclarationListContext* CHTLJavaScriptParser::IterationStatementContext::variableDeclarationList() {
  return getRuleContext<CHTLJavaScriptParser::VariableDeclarationListContext>(0);
}

tree::TerminalNode* CHTLJavaScriptParser::IterationStatementContext::IN() {
  return getToken(CHTLJavaScriptParser::IN, 0);
}

CHTLJavaScriptParser::SingleExpressionContext* CHTLJavaScriptParser::IterationStatementContext::singleExpression() {
  return getRuleContext<CHTLJavaScriptParser::SingleExpressionContext>(0);
}

tree::TerminalNode* CHTLJavaScriptParser::IterationStatementContext::OF() {
  return getToken(CHTLJavaScriptParser::OF, 0);
}

tree::TerminalNode* CHTLJavaScriptParser::IterationStatementContext::AWAIT() {
  return getToken(CHTLJavaScriptParser::AWAIT, 0);
}


size_t CHTLJavaScriptParser::IterationStatementContext::getRuleIndex() const {
  return CHTLJavaScriptParser::RuleIterationStatement;
}


std::any CHTLJavaScriptParser::IterationStatementContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<CHTLJavaScriptVisitor*>(visitor))
    return parserVisitor->visitIterationStatement(this);
  else
    return visitor->visitChildren(this);
}

CHTLJavaScriptParser::IterationStatementContext* CHTLJavaScriptParser::iterationStatement() {
  IterationStatementContext *_localctx = _tracker.createInstance<IterationStatementContext>(_ctx, getState());
  enterRule(_localctx, 58, CHTLJavaScriptParser::RuleIterationStatement);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    setState(633);
    _errHandler->sync(this);
    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 35, _ctx)) {
    case 1: {
      enterOuterAlt(_localctx, 1);
      setState(569);
      match(CHTLJavaScriptParser::DO);
      setState(570);
      statement();
      setState(571);
      match(CHTLJavaScriptParser::WHILE);
      setState(572);
      match(CHTLJavaScriptParser::LPAREN);
      setState(573);
      expressionSequence();
      setState(574);
      match(CHTLJavaScriptParser::RPAREN);
      setState(575);
      match(CHTLJavaScriptParser::SEMICOLON);
      break;
    }

    case 2: {
      enterOuterAlt(_localctx, 2);
      setState(577);
      match(CHTLJavaScriptParser::WHILE);
      setState(578);
      match(CHTLJavaScriptParser::LPAREN);
      setState(579);
      expressionSequence();
      setState(580);
      match(CHTLJavaScriptParser::RPAREN);
      setState(581);
      statement();
      break;
    }

    case 3: {
      enterOuterAlt(_localctx, 3);
      setState(583);
      match(CHTLJavaScriptParser::FOR);
      setState(584);
      match(CHTLJavaScriptParser::LPAREN);
      setState(587);
      _errHandler->sync(this);
      switch (_input->LA(1)) {
        case CHTLJavaScriptParser::CHTL_SELECTOR_START:
        case CHTLJavaScriptParser::ANIMATE:
        case CHTLJavaScriptParser::TEMPLATE_STRING:
        case CHTLJavaScriptParser::REGEX:
        case CHTLJavaScriptParser::IDENTIFIER:
        case CHTLJavaScriptParser::TYPEOF:
        case CHTLJavaScriptParser::NEW:
        case CHTLJavaScriptParser::VOID:
        case CHTLJavaScriptParser::FUNCTION:
        case CHTLJavaScriptParser::THIS:
        case CHTLJavaScriptParser::DELETE:
        case CHTLJavaScriptParser::SUPER:
        case CHTLJavaScriptParser::ASYNC:
        case CHTLJavaScriptParser::AWAIT:
        case CHTLJavaScriptParser::NULL_:
        case CHTLJavaScriptParser::BOOLEAN:
        case CHTLJavaScriptParser::UNDEFINED:
        case CHTLJavaScriptParser::LPAREN:
        case CHTLJavaScriptParser::LBRACE:
        case CHTLJavaScriptParser::LBRACKET:
        case CHTLJavaScriptParser::PLUSPLUS:
        case CHTLJavaScriptParser::MINUSMINUS:
        case CHTLJavaScriptParser::PLUS:
        case CHTLJavaScriptParser::MINUS:
        case CHTLJavaScriptParser::TILDE:
        case CHTLJavaScriptParser::EXCLAMATION:
        case CHTLJavaScriptParser::NUMBER:
        case CHTLJavaScriptParser::STRING: {
          setState(585);
          expressionSequence();
          break;
        }

        case CHTLJavaScriptParser::VAR:
        case CHTLJavaScriptParser::CONST:
        case CHTLJavaScriptParser::LET: {
          setState(586);
          variableDeclarationList();
          break;
        }

        case CHTLJavaScriptParser::SEMICOLON: {
          break;
        }

      default:
        break;
      }
      setState(589);
      match(CHTLJavaScriptParser::SEMICOLON);
      setState(591);
      _errHandler->sync(this);

      _la = _input->LA(1);
      if ((((_la & ~ 0x3fULL) == 0) &&
        ((1ULL << _la) & 3532001068879709188) != 0) || ((((_la - 70) & ~ 0x3fULL) == 0) &&
        ((1ULL << (_la - 70)) & 720576008025014447) != 0)) {
        setState(590);
        expressionSequence();
      }
      setState(593);
      match(CHTLJavaScriptParser::SEMICOLON);
      setState(595);
      _errHandler->sync(this);

      _la = _input->LA(1);
      if ((((_la & ~ 0x3fULL) == 0) &&
        ((1ULL << _la) & 3532001068879709188) != 0) || ((((_la - 70) & ~ 0x3fULL) == 0) &&
        ((1ULL << (_la - 70)) & 720576008025014447) != 0)) {
        setState(594);
        expressionSequence();
      }
      setState(597);
      match(CHTLJavaScriptParser::RPAREN);
      setState(598);
      statement();
      break;
    }

    case 4: {
      enterOuterAlt(_localctx, 4);
      setState(599);
      match(CHTLJavaScriptParser::FOR);
      setState(600);
      match(CHTLJavaScriptParser::LPAREN);
      setState(603);
      _errHandler->sync(this);
      switch (_input->LA(1)) {
        case CHTLJavaScriptParser::CHTL_SELECTOR_START:
        case CHTLJavaScriptParser::ANIMATE:
        case CHTLJavaScriptParser::TEMPLATE_STRING:
        case CHTLJavaScriptParser::REGEX:
        case CHTLJavaScriptParser::IDENTIFIER:
        case CHTLJavaScriptParser::TYPEOF:
        case CHTLJavaScriptParser::NEW:
        case CHTLJavaScriptParser::VOID:
        case CHTLJavaScriptParser::FUNCTION:
        case CHTLJavaScriptParser::THIS:
        case CHTLJavaScriptParser::DELETE:
        case CHTLJavaScriptParser::SUPER:
        case CHTLJavaScriptParser::ASYNC:
        case CHTLJavaScriptParser::AWAIT:
        case CHTLJavaScriptParser::NULL_:
        case CHTLJavaScriptParser::BOOLEAN:
        case CHTLJavaScriptParser::UNDEFINED:
        case CHTLJavaScriptParser::LPAREN:
        case CHTLJavaScriptParser::LBRACE:
        case CHTLJavaScriptParser::LBRACKET:
        case CHTLJavaScriptParser::PLUSPLUS:
        case CHTLJavaScriptParser::MINUSMINUS:
        case CHTLJavaScriptParser::PLUS:
        case CHTLJavaScriptParser::MINUS:
        case CHTLJavaScriptParser::TILDE:
        case CHTLJavaScriptParser::EXCLAMATION:
        case CHTLJavaScriptParser::NUMBER:
        case CHTLJavaScriptParser::STRING: {
          setState(601);
          singleExpression(0);
          break;
        }

        case CHTLJavaScriptParser::VAR:
        case CHTLJavaScriptParser::CONST:
        case CHTLJavaScriptParser::LET: {
          setState(602);
          variableDeclarationList();
          break;
        }

      default:
        throw NoViableAltException(this);
      }
      setState(605);
      match(CHTLJavaScriptParser::IN);
      setState(606);
      expressionSequence();
      setState(607);
      match(CHTLJavaScriptParser::RPAREN);
      setState(608);
      statement();
      break;
    }

    case 5: {
      enterOuterAlt(_localctx, 5);
      setState(610);
      match(CHTLJavaScriptParser::FOR);
      setState(611);
      match(CHTLJavaScriptParser::LPAREN);
      setState(614);
      _errHandler->sync(this);
      switch (_input->LA(1)) {
        case CHTLJavaScriptParser::CHTL_SELECTOR_START:
        case CHTLJavaScriptParser::ANIMATE:
        case CHTLJavaScriptParser::TEMPLATE_STRING:
        case CHTLJavaScriptParser::REGEX:
        case CHTLJavaScriptParser::IDENTIFIER:
        case CHTLJavaScriptParser::TYPEOF:
        case CHTLJavaScriptParser::NEW:
        case CHTLJavaScriptParser::VOID:
        case CHTLJavaScriptParser::FUNCTION:
        case CHTLJavaScriptParser::THIS:
        case CHTLJavaScriptParser::DELETE:
        case CHTLJavaScriptParser::SUPER:
        case CHTLJavaScriptParser::ASYNC:
        case CHTLJavaScriptParser::AWAIT:
        case CHTLJavaScriptParser::NULL_:
        case CHTLJavaScriptParser::BOOLEAN:
        case CHTLJavaScriptParser::UNDEFINED:
        case CHTLJavaScriptParser::LPAREN:
        case CHTLJavaScriptParser::LBRACE:
        case CHTLJavaScriptParser::LBRACKET:
        case CHTLJavaScriptParser::PLUSPLUS:
        case CHTLJavaScriptParser::MINUSMINUS:
        case CHTLJavaScriptParser::PLUS:
        case CHTLJavaScriptParser::MINUS:
        case CHTLJavaScriptParser::TILDE:
        case CHTLJavaScriptParser::EXCLAMATION:
        case CHTLJavaScriptParser::NUMBER:
        case CHTLJavaScriptParser::STRING: {
          setState(612);
          singleExpression(0);
          break;
        }

        case CHTLJavaScriptParser::VAR:
        case CHTLJavaScriptParser::CONST:
        case CHTLJavaScriptParser::LET: {
          setState(613);
          variableDeclarationList();
          break;
        }

      default:
        throw NoViableAltException(this);
      }
      setState(616);
      match(CHTLJavaScriptParser::OF);
      setState(617);
      expressionSequence();
      setState(618);
      match(CHTLJavaScriptParser::RPAREN);
      setState(619);
      statement();
      break;
    }

    case 6: {
      enterOuterAlt(_localctx, 6);
      setState(621);
      match(CHTLJavaScriptParser::FOR);
      setState(622);
      match(CHTLJavaScriptParser::AWAIT);
      setState(623);
      match(CHTLJavaScriptParser::LPAREN);
      setState(626);
      _errHandler->sync(this);
      switch (_input->LA(1)) {
        case CHTLJavaScriptParser::CHTL_SELECTOR_START:
        case CHTLJavaScriptParser::ANIMATE:
        case CHTLJavaScriptParser::TEMPLATE_STRING:
        case CHTLJavaScriptParser::REGEX:
        case CHTLJavaScriptParser::IDENTIFIER:
        case CHTLJavaScriptParser::TYPEOF:
        case CHTLJavaScriptParser::NEW:
        case CHTLJavaScriptParser::VOID:
        case CHTLJavaScriptParser::FUNCTION:
        case CHTLJavaScriptParser::THIS:
        case CHTLJavaScriptParser::DELETE:
        case CHTLJavaScriptParser::SUPER:
        case CHTLJavaScriptParser::ASYNC:
        case CHTLJavaScriptParser::AWAIT:
        case CHTLJavaScriptParser::NULL_:
        case CHTLJavaScriptParser::BOOLEAN:
        case CHTLJavaScriptParser::UNDEFINED:
        case CHTLJavaScriptParser::LPAREN:
        case CHTLJavaScriptParser::LBRACE:
        case CHTLJavaScriptParser::LBRACKET:
        case CHTLJavaScriptParser::PLUSPLUS:
        case CHTLJavaScriptParser::MINUSMINUS:
        case CHTLJavaScriptParser::PLUS:
        case CHTLJavaScriptParser::MINUS:
        case CHTLJavaScriptParser::TILDE:
        case CHTLJavaScriptParser::EXCLAMATION:
        case CHTLJavaScriptParser::NUMBER:
        case CHTLJavaScriptParser::STRING: {
          setState(624);
          singleExpression(0);
          break;
        }

        case CHTLJavaScriptParser::VAR:
        case CHTLJavaScriptParser::CONST:
        case CHTLJavaScriptParser::LET: {
          setState(625);
          variableDeclarationList();
          break;
        }

      default:
        throw NoViableAltException(this);
      }
      setState(628);
      match(CHTLJavaScriptParser::OF);
      setState(629);
      expressionSequence();
      setState(630);
      match(CHTLJavaScriptParser::RPAREN);
      setState(631);
      statement();
      break;
    }

    default:
      break;
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- ContinueStatementContext ------------------------------------------------------------------

CHTLJavaScriptParser::ContinueStatementContext::ContinueStatementContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* CHTLJavaScriptParser::ContinueStatementContext::CONTINUE() {
  return getToken(CHTLJavaScriptParser::CONTINUE, 0);
}

tree::TerminalNode* CHTLJavaScriptParser::ContinueStatementContext::SEMICOLON() {
  return getToken(CHTLJavaScriptParser::SEMICOLON, 0);
}

tree::TerminalNode* CHTLJavaScriptParser::ContinueStatementContext::IDENTIFIER() {
  return getToken(CHTLJavaScriptParser::IDENTIFIER, 0);
}


size_t CHTLJavaScriptParser::ContinueStatementContext::getRuleIndex() const {
  return CHTLJavaScriptParser::RuleContinueStatement;
}


std::any CHTLJavaScriptParser::ContinueStatementContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<CHTLJavaScriptVisitor*>(visitor))
    return parserVisitor->visitContinueStatement(this);
  else
    return visitor->visitChildren(this);
}

CHTLJavaScriptParser::ContinueStatementContext* CHTLJavaScriptParser::continueStatement() {
  ContinueStatementContext *_localctx = _tracker.createInstance<ContinueStatementContext>(_ctx, getState());
  enterRule(_localctx, 60, CHTLJavaScriptParser::RuleContinueStatement);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(635);
    match(CHTLJavaScriptParser::CONTINUE);
    setState(637);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (_la == CHTLJavaScriptParser::IDENTIFIER) {
      setState(636);
      match(CHTLJavaScriptParser::IDENTIFIER);
    }
    setState(639);
    match(CHTLJavaScriptParser::SEMICOLON);
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- BreakStatementContext ------------------------------------------------------------------

CHTLJavaScriptParser::BreakStatementContext::BreakStatementContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* CHTLJavaScriptParser::BreakStatementContext::BREAK() {
  return getToken(CHTLJavaScriptParser::BREAK, 0);
}

tree::TerminalNode* CHTLJavaScriptParser::BreakStatementContext::SEMICOLON() {
  return getToken(CHTLJavaScriptParser::SEMICOLON, 0);
}

tree::TerminalNode* CHTLJavaScriptParser::BreakStatementContext::IDENTIFIER() {
  return getToken(CHTLJavaScriptParser::IDENTIFIER, 0);
}


size_t CHTLJavaScriptParser::BreakStatementContext::getRuleIndex() const {
  return CHTLJavaScriptParser::RuleBreakStatement;
}


std::any CHTLJavaScriptParser::BreakStatementContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<CHTLJavaScriptVisitor*>(visitor))
    return parserVisitor->visitBreakStatement(this);
  else
    return visitor->visitChildren(this);
}

CHTLJavaScriptParser::BreakStatementContext* CHTLJavaScriptParser::breakStatement() {
  BreakStatementContext *_localctx = _tracker.createInstance<BreakStatementContext>(_ctx, getState());
  enterRule(_localctx, 62, CHTLJavaScriptParser::RuleBreakStatement);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(641);
    match(CHTLJavaScriptParser::BREAK);
    setState(643);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (_la == CHTLJavaScriptParser::IDENTIFIER) {
      setState(642);
      match(CHTLJavaScriptParser::IDENTIFIER);
    }
    setState(645);
    match(CHTLJavaScriptParser::SEMICOLON);
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- ReturnStatementContext ------------------------------------------------------------------

CHTLJavaScriptParser::ReturnStatementContext::ReturnStatementContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* CHTLJavaScriptParser::ReturnStatementContext::RETURN() {
  return getToken(CHTLJavaScriptParser::RETURN, 0);
}

tree::TerminalNode* CHTLJavaScriptParser::ReturnStatementContext::SEMICOLON() {
  return getToken(CHTLJavaScriptParser::SEMICOLON, 0);
}

CHTLJavaScriptParser::ExpressionSequenceContext* CHTLJavaScriptParser::ReturnStatementContext::expressionSequence() {
  return getRuleContext<CHTLJavaScriptParser::ExpressionSequenceContext>(0);
}


size_t CHTLJavaScriptParser::ReturnStatementContext::getRuleIndex() const {
  return CHTLJavaScriptParser::RuleReturnStatement;
}


std::any CHTLJavaScriptParser::ReturnStatementContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<CHTLJavaScriptVisitor*>(visitor))
    return parserVisitor->visitReturnStatement(this);
  else
    return visitor->visitChildren(this);
}

CHTLJavaScriptParser::ReturnStatementContext* CHTLJavaScriptParser::returnStatement() {
  ReturnStatementContext *_localctx = _tracker.createInstance<ReturnStatementContext>(_ctx, getState());
  enterRule(_localctx, 64, CHTLJavaScriptParser::RuleReturnStatement);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(647);
    match(CHTLJavaScriptParser::RETURN);
    setState(649);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if ((((_la & ~ 0x3fULL) == 0) &&
      ((1ULL << _la) & 3532001068879709188) != 0) || ((((_la - 70) & ~ 0x3fULL) == 0) &&
      ((1ULL << (_la - 70)) & 720576008025014447) != 0)) {
      setState(648);
      expressionSequence();
    }
    setState(651);
    match(CHTLJavaScriptParser::SEMICOLON);
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- WithStatementContext ------------------------------------------------------------------

CHTLJavaScriptParser::WithStatementContext::WithStatementContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* CHTLJavaScriptParser::WithStatementContext::WITH() {
  return getToken(CHTLJavaScriptParser::WITH, 0);
}

tree::TerminalNode* CHTLJavaScriptParser::WithStatementContext::LPAREN() {
  return getToken(CHTLJavaScriptParser::LPAREN, 0);
}

CHTLJavaScriptParser::ExpressionSequenceContext* CHTLJavaScriptParser::WithStatementContext::expressionSequence() {
  return getRuleContext<CHTLJavaScriptParser::ExpressionSequenceContext>(0);
}

tree::TerminalNode* CHTLJavaScriptParser::WithStatementContext::RPAREN() {
  return getToken(CHTLJavaScriptParser::RPAREN, 0);
}

CHTLJavaScriptParser::StatementContext* CHTLJavaScriptParser::WithStatementContext::statement() {
  return getRuleContext<CHTLJavaScriptParser::StatementContext>(0);
}


size_t CHTLJavaScriptParser::WithStatementContext::getRuleIndex() const {
  return CHTLJavaScriptParser::RuleWithStatement;
}


std::any CHTLJavaScriptParser::WithStatementContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<CHTLJavaScriptVisitor*>(visitor))
    return parserVisitor->visitWithStatement(this);
  else
    return visitor->visitChildren(this);
}

CHTLJavaScriptParser::WithStatementContext* CHTLJavaScriptParser::withStatement() {
  WithStatementContext *_localctx = _tracker.createInstance<WithStatementContext>(_ctx, getState());
  enterRule(_localctx, 66, CHTLJavaScriptParser::RuleWithStatement);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(653);
    match(CHTLJavaScriptParser::WITH);
    setState(654);
    match(CHTLJavaScriptParser::LPAREN);
    setState(655);
    expressionSequence();
    setState(656);
    match(CHTLJavaScriptParser::RPAREN);
    setState(657);
    statement();
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- LabelledStatementContext ------------------------------------------------------------------

CHTLJavaScriptParser::LabelledStatementContext::LabelledStatementContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* CHTLJavaScriptParser::LabelledStatementContext::IDENTIFIER() {
  return getToken(CHTLJavaScriptParser::IDENTIFIER, 0);
}

tree::TerminalNode* CHTLJavaScriptParser::LabelledStatementContext::COLON() {
  return getToken(CHTLJavaScriptParser::COLON, 0);
}

CHTLJavaScriptParser::StatementContext* CHTLJavaScriptParser::LabelledStatementContext::statement() {
  return getRuleContext<CHTLJavaScriptParser::StatementContext>(0);
}


size_t CHTLJavaScriptParser::LabelledStatementContext::getRuleIndex() const {
  return CHTLJavaScriptParser::RuleLabelledStatement;
}


std::any CHTLJavaScriptParser::LabelledStatementContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<CHTLJavaScriptVisitor*>(visitor))
    return parserVisitor->visitLabelledStatement(this);
  else
    return visitor->visitChildren(this);
}

CHTLJavaScriptParser::LabelledStatementContext* CHTLJavaScriptParser::labelledStatement() {
  LabelledStatementContext *_localctx = _tracker.createInstance<LabelledStatementContext>(_ctx, getState());
  enterRule(_localctx, 68, CHTLJavaScriptParser::RuleLabelledStatement);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(659);
    match(CHTLJavaScriptParser::IDENTIFIER);
    setState(660);
    match(CHTLJavaScriptParser::COLON);
    setState(661);
    statement();
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- SwitchStatementContext ------------------------------------------------------------------

CHTLJavaScriptParser::SwitchStatementContext::SwitchStatementContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* CHTLJavaScriptParser::SwitchStatementContext::SWITCH() {
  return getToken(CHTLJavaScriptParser::SWITCH, 0);
}

tree::TerminalNode* CHTLJavaScriptParser::SwitchStatementContext::LPAREN() {
  return getToken(CHTLJavaScriptParser::LPAREN, 0);
}

CHTLJavaScriptParser::ExpressionSequenceContext* CHTLJavaScriptParser::SwitchStatementContext::expressionSequence() {
  return getRuleContext<CHTLJavaScriptParser::ExpressionSequenceContext>(0);
}

tree::TerminalNode* CHTLJavaScriptParser::SwitchStatementContext::RPAREN() {
  return getToken(CHTLJavaScriptParser::RPAREN, 0);
}

CHTLJavaScriptParser::CaseBlockContext* CHTLJavaScriptParser::SwitchStatementContext::caseBlock() {
  return getRuleContext<CHTLJavaScriptParser::CaseBlockContext>(0);
}


size_t CHTLJavaScriptParser::SwitchStatementContext::getRuleIndex() const {
  return CHTLJavaScriptParser::RuleSwitchStatement;
}


std::any CHTLJavaScriptParser::SwitchStatementContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<CHTLJavaScriptVisitor*>(visitor))
    return parserVisitor->visitSwitchStatement(this);
  else
    return visitor->visitChildren(this);
}

CHTLJavaScriptParser::SwitchStatementContext* CHTLJavaScriptParser::switchStatement() {
  SwitchStatementContext *_localctx = _tracker.createInstance<SwitchStatementContext>(_ctx, getState());
  enterRule(_localctx, 70, CHTLJavaScriptParser::RuleSwitchStatement);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(663);
    match(CHTLJavaScriptParser::SWITCH);
    setState(664);
    match(CHTLJavaScriptParser::LPAREN);
    setState(665);
    expressionSequence();
    setState(666);
    match(CHTLJavaScriptParser::RPAREN);
    setState(667);
    caseBlock();
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- CaseBlockContext ------------------------------------------------------------------

CHTLJavaScriptParser::CaseBlockContext::CaseBlockContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* CHTLJavaScriptParser::CaseBlockContext::LBRACE() {
  return getToken(CHTLJavaScriptParser::LBRACE, 0);
}

tree::TerminalNode* CHTLJavaScriptParser::CaseBlockContext::RBRACE() {
  return getToken(CHTLJavaScriptParser::RBRACE, 0);
}

std::vector<CHTLJavaScriptParser::CaseClausesContext *> CHTLJavaScriptParser::CaseBlockContext::caseClauses() {
  return getRuleContexts<CHTLJavaScriptParser::CaseClausesContext>();
}

CHTLJavaScriptParser::CaseClausesContext* CHTLJavaScriptParser::CaseBlockContext::caseClauses(size_t i) {
  return getRuleContext<CHTLJavaScriptParser::CaseClausesContext>(i);
}

CHTLJavaScriptParser::DefaultClauseContext* CHTLJavaScriptParser::CaseBlockContext::defaultClause() {
  return getRuleContext<CHTLJavaScriptParser::DefaultClauseContext>(0);
}


size_t CHTLJavaScriptParser::CaseBlockContext::getRuleIndex() const {
  return CHTLJavaScriptParser::RuleCaseBlock;
}


std::any CHTLJavaScriptParser::CaseBlockContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<CHTLJavaScriptVisitor*>(visitor))
    return parserVisitor->visitCaseBlock(this);
  else
    return visitor->visitChildren(this);
}

CHTLJavaScriptParser::CaseBlockContext* CHTLJavaScriptParser::caseBlock() {
  CaseBlockContext *_localctx = _tracker.createInstance<CaseBlockContext>(_ctx, getState());
  enterRule(_localctx, 72, CHTLJavaScriptParser::RuleCaseBlock);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(669);
    match(CHTLJavaScriptParser::LBRACE);
    setState(671);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (_la == CHTLJavaScriptParser::CASE) {
      setState(670);
      caseClauses();
    }
    setState(677);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (_la == CHTLJavaScriptParser::DEFAULT) {
      setState(673);
      defaultClause();
      setState(675);
      _errHandler->sync(this);

      _la = _input->LA(1);
      if (_la == CHTLJavaScriptParser::CASE) {
        setState(674);
        caseClauses();
      }
    }
    setState(679);
    match(CHTLJavaScriptParser::RBRACE);
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- CaseClausesContext ------------------------------------------------------------------

CHTLJavaScriptParser::CaseClausesContext::CaseClausesContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

std::vector<CHTLJavaScriptParser::CaseClauseContext *> CHTLJavaScriptParser::CaseClausesContext::caseClause() {
  return getRuleContexts<CHTLJavaScriptParser::CaseClauseContext>();
}

CHTLJavaScriptParser::CaseClauseContext* CHTLJavaScriptParser::CaseClausesContext::caseClause(size_t i) {
  return getRuleContext<CHTLJavaScriptParser::CaseClauseContext>(i);
}


size_t CHTLJavaScriptParser::CaseClausesContext::getRuleIndex() const {
  return CHTLJavaScriptParser::RuleCaseClauses;
}


std::any CHTLJavaScriptParser::CaseClausesContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<CHTLJavaScriptVisitor*>(visitor))
    return parserVisitor->visitCaseClauses(this);
  else
    return visitor->visitChildren(this);
}

CHTLJavaScriptParser::CaseClausesContext* CHTLJavaScriptParser::caseClauses() {
  CaseClausesContext *_localctx = _tracker.createInstance<CaseClausesContext>(_ctx, getState());
  enterRule(_localctx, 74, CHTLJavaScriptParser::RuleCaseClauses);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(682); 
    _errHandler->sync(this);
    _la = _input->LA(1);
    do {
      setState(681);
      caseClause();
      setState(684); 
      _errHandler->sync(this);
      _la = _input->LA(1);
    } while (_la == CHTLJavaScriptParser::CASE);
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- CaseClauseContext ------------------------------------------------------------------

CHTLJavaScriptParser::CaseClauseContext::CaseClauseContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* CHTLJavaScriptParser::CaseClauseContext::CASE() {
  return getToken(CHTLJavaScriptParser::CASE, 0);
}

CHTLJavaScriptParser::ExpressionSequenceContext* CHTLJavaScriptParser::CaseClauseContext::expressionSequence() {
  return getRuleContext<CHTLJavaScriptParser::ExpressionSequenceContext>(0);
}

tree::TerminalNode* CHTLJavaScriptParser::CaseClauseContext::COLON() {
  return getToken(CHTLJavaScriptParser::COLON, 0);
}

std::vector<CHTLJavaScriptParser::StatementContext *> CHTLJavaScriptParser::CaseClauseContext::statement() {
  return getRuleContexts<CHTLJavaScriptParser::StatementContext>();
}

CHTLJavaScriptParser::StatementContext* CHTLJavaScriptParser::CaseClauseContext::statement(size_t i) {
  return getRuleContext<CHTLJavaScriptParser::StatementContext>(i);
}


size_t CHTLJavaScriptParser::CaseClauseContext::getRuleIndex() const {
  return CHTLJavaScriptParser::RuleCaseClause;
}


std::any CHTLJavaScriptParser::CaseClauseContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<CHTLJavaScriptVisitor*>(visitor))
    return parserVisitor->visitCaseClause(this);
  else
    return visitor->visitChildren(this);
}

CHTLJavaScriptParser::CaseClauseContext* CHTLJavaScriptParser::caseClause() {
  CaseClauseContext *_localctx = _tracker.createInstance<CaseClauseContext>(_ctx, getState());
  enterRule(_localctx, 76, CHTLJavaScriptParser::RuleCaseClause);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(686);
    match(CHTLJavaScriptParser::CASE);
    setState(687);
    expressionSequence();
    setState(688);
    match(CHTLJavaScriptParser::COLON);
    setState(692);
    _errHandler->sync(this);
    _la = _input->LA(1);
    while ((((_la & ~ 0x3fULL) == 0) &&
      ((1ULL << _la) & -4668130657528970236) != 0) || ((((_la - 70) & ~ 0x3fULL) == 0) &&
      ((1ULL << (_la - 70)) & 720576008025014959) != 0)) {
      setState(689);
      statement();
      setState(694);
      _errHandler->sync(this);
      _la = _input->LA(1);
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- DefaultClauseContext ------------------------------------------------------------------

CHTLJavaScriptParser::DefaultClauseContext::DefaultClauseContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* CHTLJavaScriptParser::DefaultClauseContext::DEFAULT() {
  return getToken(CHTLJavaScriptParser::DEFAULT, 0);
}

tree::TerminalNode* CHTLJavaScriptParser::DefaultClauseContext::COLON() {
  return getToken(CHTLJavaScriptParser::COLON, 0);
}

std::vector<CHTLJavaScriptParser::StatementContext *> CHTLJavaScriptParser::DefaultClauseContext::statement() {
  return getRuleContexts<CHTLJavaScriptParser::StatementContext>();
}

CHTLJavaScriptParser::StatementContext* CHTLJavaScriptParser::DefaultClauseContext::statement(size_t i) {
  return getRuleContext<CHTLJavaScriptParser::StatementContext>(i);
}


size_t CHTLJavaScriptParser::DefaultClauseContext::getRuleIndex() const {
  return CHTLJavaScriptParser::RuleDefaultClause;
}


std::any CHTLJavaScriptParser::DefaultClauseContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<CHTLJavaScriptVisitor*>(visitor))
    return parserVisitor->visitDefaultClause(this);
  else
    return visitor->visitChildren(this);
}

CHTLJavaScriptParser::DefaultClauseContext* CHTLJavaScriptParser::defaultClause() {
  DefaultClauseContext *_localctx = _tracker.createInstance<DefaultClauseContext>(_ctx, getState());
  enterRule(_localctx, 78, CHTLJavaScriptParser::RuleDefaultClause);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(695);
    match(CHTLJavaScriptParser::DEFAULT);
    setState(696);
    match(CHTLJavaScriptParser::COLON);
    setState(700);
    _errHandler->sync(this);
    _la = _input->LA(1);
    while ((((_la & ~ 0x3fULL) == 0) &&
      ((1ULL << _la) & -4668130657528970236) != 0) || ((((_la - 70) & ~ 0x3fULL) == 0) &&
      ((1ULL << (_la - 70)) & 720576008025014959) != 0)) {
      setState(697);
      statement();
      setState(702);
      _errHandler->sync(this);
      _la = _input->LA(1);
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- ThrowStatementContext ------------------------------------------------------------------

CHTLJavaScriptParser::ThrowStatementContext::ThrowStatementContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* CHTLJavaScriptParser::ThrowStatementContext::THROW() {
  return getToken(CHTLJavaScriptParser::THROW, 0);
}

CHTLJavaScriptParser::ExpressionSequenceContext* CHTLJavaScriptParser::ThrowStatementContext::expressionSequence() {
  return getRuleContext<CHTLJavaScriptParser::ExpressionSequenceContext>(0);
}

tree::TerminalNode* CHTLJavaScriptParser::ThrowStatementContext::SEMICOLON() {
  return getToken(CHTLJavaScriptParser::SEMICOLON, 0);
}


size_t CHTLJavaScriptParser::ThrowStatementContext::getRuleIndex() const {
  return CHTLJavaScriptParser::RuleThrowStatement;
}


std::any CHTLJavaScriptParser::ThrowStatementContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<CHTLJavaScriptVisitor*>(visitor))
    return parserVisitor->visitThrowStatement(this);
  else
    return visitor->visitChildren(this);
}

CHTLJavaScriptParser::ThrowStatementContext* CHTLJavaScriptParser::throwStatement() {
  ThrowStatementContext *_localctx = _tracker.createInstance<ThrowStatementContext>(_ctx, getState());
  enterRule(_localctx, 80, CHTLJavaScriptParser::RuleThrowStatement);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(703);
    match(CHTLJavaScriptParser::THROW);
    setState(704);
    expressionSequence();
    setState(705);
    match(CHTLJavaScriptParser::SEMICOLON);
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- TryStatementContext ------------------------------------------------------------------

CHTLJavaScriptParser::TryStatementContext::TryStatementContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* CHTLJavaScriptParser::TryStatementContext::TRY() {
  return getToken(CHTLJavaScriptParser::TRY, 0);
}

CHTLJavaScriptParser::BlockContext* CHTLJavaScriptParser::TryStatementContext::block() {
  return getRuleContext<CHTLJavaScriptParser::BlockContext>(0);
}

CHTLJavaScriptParser::CatchClauseContext* CHTLJavaScriptParser::TryStatementContext::catchClause() {
  return getRuleContext<CHTLJavaScriptParser::CatchClauseContext>(0);
}

CHTLJavaScriptParser::FinallyClauseContext* CHTLJavaScriptParser::TryStatementContext::finallyClause() {
  return getRuleContext<CHTLJavaScriptParser::FinallyClauseContext>(0);
}


size_t CHTLJavaScriptParser::TryStatementContext::getRuleIndex() const {
  return CHTLJavaScriptParser::RuleTryStatement;
}


std::any CHTLJavaScriptParser::TryStatementContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<CHTLJavaScriptVisitor*>(visitor))
    return parserVisitor->visitTryStatement(this);
  else
    return visitor->visitChildren(this);
}

CHTLJavaScriptParser::TryStatementContext* CHTLJavaScriptParser::tryStatement() {
  TryStatementContext *_localctx = _tracker.createInstance<TryStatementContext>(_ctx, getState());
  enterRule(_localctx, 82, CHTLJavaScriptParser::RuleTryStatement);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(707);
    match(CHTLJavaScriptParser::TRY);
    setState(708);
    block();
    setState(714);
    _errHandler->sync(this);
    switch (_input->LA(1)) {
      case CHTLJavaScriptParser::CATCH: {
        setState(709);
        catchClause();
        setState(711);
        _errHandler->sync(this);

        _la = _input->LA(1);
        if (_la == CHTLJavaScriptParser::FINALLY) {
          setState(710);
          finallyClause();
        }
        break;
      }

      case CHTLJavaScriptParser::FINALLY: {
        setState(713);
        finallyClause();
        break;
      }

    default:
      throw NoViableAltException(this);
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- CatchClauseContext ------------------------------------------------------------------

CHTLJavaScriptParser::CatchClauseContext::CatchClauseContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* CHTLJavaScriptParser::CatchClauseContext::CATCH() {
  return getToken(CHTLJavaScriptParser::CATCH, 0);
}

CHTLJavaScriptParser::BlockContext* CHTLJavaScriptParser::CatchClauseContext::block() {
  return getRuleContext<CHTLJavaScriptParser::BlockContext>(0);
}

tree::TerminalNode* CHTLJavaScriptParser::CatchClauseContext::LPAREN() {
  return getToken(CHTLJavaScriptParser::LPAREN, 0);
}

CHTLJavaScriptParser::AssignableContext* CHTLJavaScriptParser::CatchClauseContext::assignable() {
  return getRuleContext<CHTLJavaScriptParser::AssignableContext>(0);
}

tree::TerminalNode* CHTLJavaScriptParser::CatchClauseContext::RPAREN() {
  return getToken(CHTLJavaScriptParser::RPAREN, 0);
}


size_t CHTLJavaScriptParser::CatchClauseContext::getRuleIndex() const {
  return CHTLJavaScriptParser::RuleCatchClause;
}


std::any CHTLJavaScriptParser::CatchClauseContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<CHTLJavaScriptVisitor*>(visitor))
    return parserVisitor->visitCatchClause(this);
  else
    return visitor->visitChildren(this);
}

CHTLJavaScriptParser::CatchClauseContext* CHTLJavaScriptParser::catchClause() {
  CatchClauseContext *_localctx = _tracker.createInstance<CatchClauseContext>(_ctx, getState());
  enterRule(_localctx, 84, CHTLJavaScriptParser::RuleCatchClause);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(716);
    match(CHTLJavaScriptParser::CATCH);
    setState(721);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (_la == CHTLJavaScriptParser::LPAREN) {
      setState(717);
      match(CHTLJavaScriptParser::LPAREN);
      setState(718);
      assignable();
      setState(719);
      match(CHTLJavaScriptParser::RPAREN);
    }
    setState(723);
    block();
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- FinallyClauseContext ------------------------------------------------------------------

CHTLJavaScriptParser::FinallyClauseContext::FinallyClauseContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* CHTLJavaScriptParser::FinallyClauseContext::FINALLY() {
  return getToken(CHTLJavaScriptParser::FINALLY, 0);
}

CHTLJavaScriptParser::BlockContext* CHTLJavaScriptParser::FinallyClauseContext::block() {
  return getRuleContext<CHTLJavaScriptParser::BlockContext>(0);
}


size_t CHTLJavaScriptParser::FinallyClauseContext::getRuleIndex() const {
  return CHTLJavaScriptParser::RuleFinallyClause;
}


std::any CHTLJavaScriptParser::FinallyClauseContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<CHTLJavaScriptVisitor*>(visitor))
    return parserVisitor->visitFinallyClause(this);
  else
    return visitor->visitChildren(this);
}

CHTLJavaScriptParser::FinallyClauseContext* CHTLJavaScriptParser::finallyClause() {
  FinallyClauseContext *_localctx = _tracker.createInstance<FinallyClauseContext>(_ctx, getState());
  enterRule(_localctx, 86, CHTLJavaScriptParser::RuleFinallyClause);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(725);
    match(CHTLJavaScriptParser::FINALLY);
    setState(726);
    block();
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- FunctionDeclarationContext ------------------------------------------------------------------

CHTLJavaScriptParser::FunctionDeclarationContext::FunctionDeclarationContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* CHTLJavaScriptParser::FunctionDeclarationContext::FUNCTION() {
  return getToken(CHTLJavaScriptParser::FUNCTION, 0);
}

tree::TerminalNode* CHTLJavaScriptParser::FunctionDeclarationContext::IDENTIFIER() {
  return getToken(CHTLJavaScriptParser::IDENTIFIER, 0);
}

tree::TerminalNode* CHTLJavaScriptParser::FunctionDeclarationContext::LPAREN() {
  return getToken(CHTLJavaScriptParser::LPAREN, 0);
}

tree::TerminalNode* CHTLJavaScriptParser::FunctionDeclarationContext::RPAREN() {
  return getToken(CHTLJavaScriptParser::RPAREN, 0);
}

CHTLJavaScriptParser::BlockContext* CHTLJavaScriptParser::FunctionDeclarationContext::block() {
  return getRuleContext<CHTLJavaScriptParser::BlockContext>(0);
}

tree::TerminalNode* CHTLJavaScriptParser::FunctionDeclarationContext::ASYNC() {
  return getToken(CHTLJavaScriptParser::ASYNC, 0);
}

tree::TerminalNode* CHTLJavaScriptParser::FunctionDeclarationContext::STAR() {
  return getToken(CHTLJavaScriptParser::STAR, 0);
}

CHTLJavaScriptParser::FormalParameterListContext* CHTLJavaScriptParser::FunctionDeclarationContext::formalParameterList() {
  return getRuleContext<CHTLJavaScriptParser::FormalParameterListContext>(0);
}


size_t CHTLJavaScriptParser::FunctionDeclarationContext::getRuleIndex() const {
  return CHTLJavaScriptParser::RuleFunctionDeclaration;
}


std::any CHTLJavaScriptParser::FunctionDeclarationContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<CHTLJavaScriptVisitor*>(visitor))
    return parserVisitor->visitFunctionDeclaration(this);
  else
    return visitor->visitChildren(this);
}

CHTLJavaScriptParser::FunctionDeclarationContext* CHTLJavaScriptParser::functionDeclaration() {
  FunctionDeclarationContext *_localctx = _tracker.createInstance<FunctionDeclarationContext>(_ctx, getState());
  enterRule(_localctx, 88, CHTLJavaScriptParser::RuleFunctionDeclaration);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(729);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (_la == CHTLJavaScriptParser::ASYNC) {
      setState(728);
      match(CHTLJavaScriptParser::ASYNC);
    }
    setState(731);
    match(CHTLJavaScriptParser::FUNCTION);
    setState(733);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (_la == CHTLJavaScriptParser::STAR) {
      setState(732);
      match(CHTLJavaScriptParser::STAR);
    }
    setState(735);
    match(CHTLJavaScriptParser::IDENTIFIER);
    setState(736);
    match(CHTLJavaScriptParser::LPAREN);
    setState(738);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (((((_la - 23) & ~ 0x3fULL) == 0) &&
      ((1ULL << (_la - 23)) & 2328361007350546433) != 0)) {
      setState(737);
      formalParameterList();
    }
    setState(740);
    match(CHTLJavaScriptParser::RPAREN);
    setState(741);
    block();
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- ClassDeclarationContext ------------------------------------------------------------------

CHTLJavaScriptParser::ClassDeclarationContext::ClassDeclarationContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* CHTLJavaScriptParser::ClassDeclarationContext::CLASS() {
  return getToken(CHTLJavaScriptParser::CLASS, 0);
}

tree::TerminalNode* CHTLJavaScriptParser::ClassDeclarationContext::IDENTIFIER() {
  return getToken(CHTLJavaScriptParser::IDENTIFIER, 0);
}

CHTLJavaScriptParser::ClassTailContext* CHTLJavaScriptParser::ClassDeclarationContext::classTail() {
  return getRuleContext<CHTLJavaScriptParser::ClassTailContext>(0);
}

tree::TerminalNode* CHTLJavaScriptParser::ClassDeclarationContext::EXTENDS() {
  return getToken(CHTLJavaScriptParser::EXTENDS, 0);
}

CHTLJavaScriptParser::SingleExpressionContext* CHTLJavaScriptParser::ClassDeclarationContext::singleExpression() {
  return getRuleContext<CHTLJavaScriptParser::SingleExpressionContext>(0);
}


size_t CHTLJavaScriptParser::ClassDeclarationContext::getRuleIndex() const {
  return CHTLJavaScriptParser::RuleClassDeclaration;
}


std::any CHTLJavaScriptParser::ClassDeclarationContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<CHTLJavaScriptVisitor*>(visitor))
    return parserVisitor->visitClassDeclaration(this);
  else
    return visitor->visitChildren(this);
}

CHTLJavaScriptParser::ClassDeclarationContext* CHTLJavaScriptParser::classDeclaration() {
  ClassDeclarationContext *_localctx = _tracker.createInstance<ClassDeclarationContext>(_ctx, getState());
  enterRule(_localctx, 90, CHTLJavaScriptParser::RuleClassDeclaration);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(743);
    match(CHTLJavaScriptParser::CLASS);
    setState(744);
    match(CHTLJavaScriptParser::IDENTIFIER);
    setState(747);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (_la == CHTLJavaScriptParser::EXTENDS) {
      setState(745);
      match(CHTLJavaScriptParser::EXTENDS);
      setState(746);
      singleExpression(0);
    }
    setState(749);
    classTail();
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- ClassTailContext ------------------------------------------------------------------

CHTLJavaScriptParser::ClassTailContext::ClassTailContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* CHTLJavaScriptParser::ClassTailContext::LBRACE() {
  return getToken(CHTLJavaScriptParser::LBRACE, 0);
}

tree::TerminalNode* CHTLJavaScriptParser::ClassTailContext::RBRACE() {
  return getToken(CHTLJavaScriptParser::RBRACE, 0);
}

std::vector<CHTLJavaScriptParser::ClassElementContext *> CHTLJavaScriptParser::ClassTailContext::classElement() {
  return getRuleContexts<CHTLJavaScriptParser::ClassElementContext>();
}

CHTLJavaScriptParser::ClassElementContext* CHTLJavaScriptParser::ClassTailContext::classElement(size_t i) {
  return getRuleContext<CHTLJavaScriptParser::ClassElementContext>(i);
}


size_t CHTLJavaScriptParser::ClassTailContext::getRuleIndex() const {
  return CHTLJavaScriptParser::RuleClassTail;
}


std::any CHTLJavaScriptParser::ClassTailContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<CHTLJavaScriptVisitor*>(visitor))
    return parserVisitor->visitClassTail(this);
  else
    return visitor->visitChildren(this);
}

CHTLJavaScriptParser::ClassTailContext* CHTLJavaScriptParser::classTail() {
  ClassTailContext *_localctx = _tracker.createInstance<ClassTailContext>(_ctx, getState());
  enterRule(_localctx, 92, CHTLJavaScriptParser::RuleClassTail);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(751);
    match(CHTLJavaScriptParser::LBRACE);
    setState(755);
    _errHandler->sync(this);
    _la = _input->LA(1);
    while (((((_la - 23) & ~ 0x3fULL) == 0) &&
      ((1ULL << (_la - 23)) & 90634942500831217) != 0) || ((((_la - 106) & ~ 0x3fULL) == 0) &&
      ((1ULL << (_la - 106)) & 10485761) != 0)) {
      setState(752);
      classElement();
      setState(757);
      _errHandler->sync(this);
      _la = _input->LA(1);
    }
    setState(758);
    match(CHTLJavaScriptParser::RBRACE);
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- ClassElementContext ------------------------------------------------------------------

CHTLJavaScriptParser::ClassElementContext::ClassElementContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

CHTLJavaScriptParser::MethodDefinitionContext* CHTLJavaScriptParser::ClassElementContext::methodDefinition() {
  return getRuleContext<CHTLJavaScriptParser::MethodDefinitionContext>(0);
}

tree::TerminalNode* CHTLJavaScriptParser::ClassElementContext::STATIC() {
  return getToken(CHTLJavaScriptParser::STATIC, 0);
}

CHTLJavaScriptParser::EmptyStatementContext* CHTLJavaScriptParser::ClassElementContext::emptyStatement() {
  return getRuleContext<CHTLJavaScriptParser::EmptyStatementContext>(0);
}

CHTLJavaScriptParser::PropertyNameContext* CHTLJavaScriptParser::ClassElementContext::propertyName() {
  return getRuleContext<CHTLJavaScriptParser::PropertyNameContext>(0);
}

tree::TerminalNode* CHTLJavaScriptParser::ClassElementContext::EQUALS() {
  return getToken(CHTLJavaScriptParser::EQUALS, 0);
}

CHTLJavaScriptParser::SingleExpressionContext* CHTLJavaScriptParser::ClassElementContext::singleExpression() {
  return getRuleContext<CHTLJavaScriptParser::SingleExpressionContext>(0);
}

tree::TerminalNode* CHTLJavaScriptParser::ClassElementContext::SEMICOLON() {
  return getToken(CHTLJavaScriptParser::SEMICOLON, 0);
}


size_t CHTLJavaScriptParser::ClassElementContext::getRuleIndex() const {
  return CHTLJavaScriptParser::RuleClassElement;
}


std::any CHTLJavaScriptParser::ClassElementContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<CHTLJavaScriptVisitor*>(visitor))
    return parserVisitor->visitClassElement(this);
  else
    return visitor->visitChildren(this);
}

CHTLJavaScriptParser::ClassElementContext* CHTLJavaScriptParser::classElement() {
  ClassElementContext *_localctx = _tracker.createInstance<ClassElementContext>(_ctx, getState());
  enterRule(_localctx, 94, CHTLJavaScriptParser::RuleClassElement);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    setState(770);
    _errHandler->sync(this);
    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 54, _ctx)) {
    case 1: {
      enterOuterAlt(_localctx, 1);
      setState(761);
      _errHandler->sync(this);

      switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 53, _ctx)) {
      case 1: {
        setState(760);
        match(CHTLJavaScriptParser::STATIC);
        break;
      }

      default:
        break;
      }
      setState(763);
      methodDefinition();
      break;
    }

    case 2: {
      enterOuterAlt(_localctx, 2);
      setState(764);
      emptyStatement();
      break;
    }

    case 3: {
      enterOuterAlt(_localctx, 3);
      setState(765);
      propertyName();
      setState(766);
      match(CHTLJavaScriptParser::EQUALS);
      setState(767);
      singleExpression(0);
      setState(768);
      match(CHTLJavaScriptParser::SEMICOLON);
      break;
    }

    default:
      break;
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- MethodDefinitionContext ------------------------------------------------------------------

CHTLJavaScriptParser::MethodDefinitionContext::MethodDefinitionContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

CHTLJavaScriptParser::PropertyNameContext* CHTLJavaScriptParser::MethodDefinitionContext::propertyName() {
  return getRuleContext<CHTLJavaScriptParser::PropertyNameContext>(0);
}

tree::TerminalNode* CHTLJavaScriptParser::MethodDefinitionContext::LPAREN() {
  return getToken(CHTLJavaScriptParser::LPAREN, 0);
}

tree::TerminalNode* CHTLJavaScriptParser::MethodDefinitionContext::RPAREN() {
  return getToken(CHTLJavaScriptParser::RPAREN, 0);
}

CHTLJavaScriptParser::BlockContext* CHTLJavaScriptParser::MethodDefinitionContext::block() {
  return getRuleContext<CHTLJavaScriptParser::BlockContext>(0);
}

CHTLJavaScriptParser::FormalParameterListContext* CHTLJavaScriptParser::MethodDefinitionContext::formalParameterList() {
  return getRuleContext<CHTLJavaScriptParser::FormalParameterListContext>(0);
}

CHTLJavaScriptParser::GetterContext* CHTLJavaScriptParser::MethodDefinitionContext::getter() {
  return getRuleContext<CHTLJavaScriptParser::GetterContext>(0);
}

CHTLJavaScriptParser::SetterContext* CHTLJavaScriptParser::MethodDefinitionContext::setter() {
  return getRuleContext<CHTLJavaScriptParser::SetterContext>(0);
}

CHTLJavaScriptParser::GeneratorMethodContext* CHTLJavaScriptParser::MethodDefinitionContext::generatorMethod() {
  return getRuleContext<CHTLJavaScriptParser::GeneratorMethodContext>(0);
}

CHTLJavaScriptParser::AsyncMethodContext* CHTLJavaScriptParser::MethodDefinitionContext::asyncMethod() {
  return getRuleContext<CHTLJavaScriptParser::AsyncMethodContext>(0);
}


size_t CHTLJavaScriptParser::MethodDefinitionContext::getRuleIndex() const {
  return CHTLJavaScriptParser::RuleMethodDefinition;
}


std::any CHTLJavaScriptParser::MethodDefinitionContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<CHTLJavaScriptVisitor*>(visitor))
    return parserVisitor->visitMethodDefinition(this);
  else
    return visitor->visitChildren(this);
}

CHTLJavaScriptParser::MethodDefinitionContext* CHTLJavaScriptParser::methodDefinition() {
  MethodDefinitionContext *_localctx = _tracker.createInstance<MethodDefinitionContext>(_ctx, getState());
  enterRule(_localctx, 96, CHTLJavaScriptParser::RuleMethodDefinition);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    setState(784);
    _errHandler->sync(this);
    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 56, _ctx)) {
    case 1: {
      enterOuterAlt(_localctx, 1);
      setState(772);
      propertyName();
      setState(773);
      match(CHTLJavaScriptParser::LPAREN);
      setState(775);
      _errHandler->sync(this);

      _la = _input->LA(1);
      if (((((_la - 23) & ~ 0x3fULL) == 0) &&
        ((1ULL << (_la - 23)) & 2328361007350546433) != 0)) {
        setState(774);
        formalParameterList();
      }
      setState(777);
      match(CHTLJavaScriptParser::RPAREN);
      setState(778);
      block();
      break;
    }

    case 2: {
      enterOuterAlt(_localctx, 2);
      setState(780);
      getter();
      break;
    }

    case 3: {
      enterOuterAlt(_localctx, 3);
      setState(781);
      setter();
      break;
    }

    case 4: {
      enterOuterAlt(_localctx, 4);
      setState(782);
      generatorMethod();
      break;
    }

    case 5: {
      enterOuterAlt(_localctx, 5);
      setState(783);
      asyncMethod();
      break;
    }

    default:
      break;
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- GetterContext ------------------------------------------------------------------

CHTLJavaScriptParser::GetterContext::GetterContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* CHTLJavaScriptParser::GetterContext::GET() {
  return getToken(CHTLJavaScriptParser::GET, 0);
}

CHTLJavaScriptParser::PropertyNameContext* CHTLJavaScriptParser::GetterContext::propertyName() {
  return getRuleContext<CHTLJavaScriptParser::PropertyNameContext>(0);
}

tree::TerminalNode* CHTLJavaScriptParser::GetterContext::LPAREN() {
  return getToken(CHTLJavaScriptParser::LPAREN, 0);
}

tree::TerminalNode* CHTLJavaScriptParser::GetterContext::RPAREN() {
  return getToken(CHTLJavaScriptParser::RPAREN, 0);
}

CHTLJavaScriptParser::BlockContext* CHTLJavaScriptParser::GetterContext::block() {
  return getRuleContext<CHTLJavaScriptParser::BlockContext>(0);
}


size_t CHTLJavaScriptParser::GetterContext::getRuleIndex() const {
  return CHTLJavaScriptParser::RuleGetter;
}


std::any CHTLJavaScriptParser::GetterContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<CHTLJavaScriptVisitor*>(visitor))
    return parserVisitor->visitGetter(this);
  else
    return visitor->visitChildren(this);
}

CHTLJavaScriptParser::GetterContext* CHTLJavaScriptParser::getter() {
  GetterContext *_localctx = _tracker.createInstance<GetterContext>(_ctx, getState());
  enterRule(_localctx, 98, CHTLJavaScriptParser::RuleGetter);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(786);
    match(CHTLJavaScriptParser::GET);
    setState(787);
    propertyName();
    setState(788);
    match(CHTLJavaScriptParser::LPAREN);
    setState(789);
    match(CHTLJavaScriptParser::RPAREN);
    setState(790);
    block();
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- SetterContext ------------------------------------------------------------------

CHTLJavaScriptParser::SetterContext::SetterContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* CHTLJavaScriptParser::SetterContext::SET() {
  return getToken(CHTLJavaScriptParser::SET, 0);
}

CHTLJavaScriptParser::PropertyNameContext* CHTLJavaScriptParser::SetterContext::propertyName() {
  return getRuleContext<CHTLJavaScriptParser::PropertyNameContext>(0);
}

tree::TerminalNode* CHTLJavaScriptParser::SetterContext::LPAREN() {
  return getToken(CHTLJavaScriptParser::LPAREN, 0);
}

CHTLJavaScriptParser::FormalParameterListContext* CHTLJavaScriptParser::SetterContext::formalParameterList() {
  return getRuleContext<CHTLJavaScriptParser::FormalParameterListContext>(0);
}

tree::TerminalNode* CHTLJavaScriptParser::SetterContext::RPAREN() {
  return getToken(CHTLJavaScriptParser::RPAREN, 0);
}

CHTLJavaScriptParser::BlockContext* CHTLJavaScriptParser::SetterContext::block() {
  return getRuleContext<CHTLJavaScriptParser::BlockContext>(0);
}


size_t CHTLJavaScriptParser::SetterContext::getRuleIndex() const {
  return CHTLJavaScriptParser::RuleSetter;
}


std::any CHTLJavaScriptParser::SetterContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<CHTLJavaScriptVisitor*>(visitor))
    return parserVisitor->visitSetter(this);
  else
    return visitor->visitChildren(this);
}

CHTLJavaScriptParser::SetterContext* CHTLJavaScriptParser::setter() {
  SetterContext *_localctx = _tracker.createInstance<SetterContext>(_ctx, getState());
  enterRule(_localctx, 100, CHTLJavaScriptParser::RuleSetter);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(792);
    match(CHTLJavaScriptParser::SET);
    setState(793);
    propertyName();
    setState(794);
    match(CHTLJavaScriptParser::LPAREN);
    setState(795);
    formalParameterList();
    setState(796);
    match(CHTLJavaScriptParser::RPAREN);
    setState(797);
    block();
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- GeneratorMethodContext ------------------------------------------------------------------

CHTLJavaScriptParser::GeneratorMethodContext::GeneratorMethodContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* CHTLJavaScriptParser::GeneratorMethodContext::STAR() {
  return getToken(CHTLJavaScriptParser::STAR, 0);
}

CHTLJavaScriptParser::PropertyNameContext* CHTLJavaScriptParser::GeneratorMethodContext::propertyName() {
  return getRuleContext<CHTLJavaScriptParser::PropertyNameContext>(0);
}

tree::TerminalNode* CHTLJavaScriptParser::GeneratorMethodContext::LPAREN() {
  return getToken(CHTLJavaScriptParser::LPAREN, 0);
}

tree::TerminalNode* CHTLJavaScriptParser::GeneratorMethodContext::RPAREN() {
  return getToken(CHTLJavaScriptParser::RPAREN, 0);
}

CHTLJavaScriptParser::BlockContext* CHTLJavaScriptParser::GeneratorMethodContext::block() {
  return getRuleContext<CHTLJavaScriptParser::BlockContext>(0);
}

CHTLJavaScriptParser::FormalParameterListContext* CHTLJavaScriptParser::GeneratorMethodContext::formalParameterList() {
  return getRuleContext<CHTLJavaScriptParser::FormalParameterListContext>(0);
}


size_t CHTLJavaScriptParser::GeneratorMethodContext::getRuleIndex() const {
  return CHTLJavaScriptParser::RuleGeneratorMethod;
}


std::any CHTLJavaScriptParser::GeneratorMethodContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<CHTLJavaScriptVisitor*>(visitor))
    return parserVisitor->visitGeneratorMethod(this);
  else
    return visitor->visitChildren(this);
}

CHTLJavaScriptParser::GeneratorMethodContext* CHTLJavaScriptParser::generatorMethod() {
  GeneratorMethodContext *_localctx = _tracker.createInstance<GeneratorMethodContext>(_ctx, getState());
  enterRule(_localctx, 102, CHTLJavaScriptParser::RuleGeneratorMethod);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(799);
    match(CHTLJavaScriptParser::STAR);
    setState(800);
    propertyName();
    setState(801);
    match(CHTLJavaScriptParser::LPAREN);
    setState(803);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (((((_la - 23) & ~ 0x3fULL) == 0) &&
      ((1ULL << (_la - 23)) & 2328361007350546433) != 0)) {
      setState(802);
      formalParameterList();
    }
    setState(805);
    match(CHTLJavaScriptParser::RPAREN);
    setState(806);
    block();
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- AsyncMethodContext ------------------------------------------------------------------

CHTLJavaScriptParser::AsyncMethodContext::AsyncMethodContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* CHTLJavaScriptParser::AsyncMethodContext::ASYNC() {
  return getToken(CHTLJavaScriptParser::ASYNC, 0);
}

CHTLJavaScriptParser::PropertyNameContext* CHTLJavaScriptParser::AsyncMethodContext::propertyName() {
  return getRuleContext<CHTLJavaScriptParser::PropertyNameContext>(0);
}

tree::TerminalNode* CHTLJavaScriptParser::AsyncMethodContext::LPAREN() {
  return getToken(CHTLJavaScriptParser::LPAREN, 0);
}

tree::TerminalNode* CHTLJavaScriptParser::AsyncMethodContext::RPAREN() {
  return getToken(CHTLJavaScriptParser::RPAREN, 0);
}

CHTLJavaScriptParser::BlockContext* CHTLJavaScriptParser::AsyncMethodContext::block() {
  return getRuleContext<CHTLJavaScriptParser::BlockContext>(0);
}

CHTLJavaScriptParser::FormalParameterListContext* CHTLJavaScriptParser::AsyncMethodContext::formalParameterList() {
  return getRuleContext<CHTLJavaScriptParser::FormalParameterListContext>(0);
}


size_t CHTLJavaScriptParser::AsyncMethodContext::getRuleIndex() const {
  return CHTLJavaScriptParser::RuleAsyncMethod;
}


std::any CHTLJavaScriptParser::AsyncMethodContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<CHTLJavaScriptVisitor*>(visitor))
    return parserVisitor->visitAsyncMethod(this);
  else
    return visitor->visitChildren(this);
}

CHTLJavaScriptParser::AsyncMethodContext* CHTLJavaScriptParser::asyncMethod() {
  AsyncMethodContext *_localctx = _tracker.createInstance<AsyncMethodContext>(_ctx, getState());
  enterRule(_localctx, 104, CHTLJavaScriptParser::RuleAsyncMethod);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(808);
    match(CHTLJavaScriptParser::ASYNC);
    setState(809);
    propertyName();
    setState(810);
    match(CHTLJavaScriptParser::LPAREN);
    setState(812);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (((((_la - 23) & ~ 0x3fULL) == 0) &&
      ((1ULL << (_la - 23)) & 2328361007350546433) != 0)) {
      setState(811);
      formalParameterList();
    }
    setState(814);
    match(CHTLJavaScriptParser::RPAREN);
    setState(815);
    block();
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- ImportStatementContext ------------------------------------------------------------------

CHTLJavaScriptParser::ImportStatementContext::ImportStatementContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* CHTLJavaScriptParser::ImportStatementContext::IMPORT() {
  return getToken(CHTLJavaScriptParser::IMPORT, 0);
}

tree::TerminalNode* CHTLJavaScriptParser::ImportStatementContext::SEMICOLON() {
  return getToken(CHTLJavaScriptParser::SEMICOLON, 0);
}

CHTLJavaScriptParser::ImportFromBlockContext* CHTLJavaScriptParser::ImportStatementContext::importFromBlock() {
  return getRuleContext<CHTLJavaScriptParser::ImportFromBlockContext>(0);
}

tree::TerminalNode* CHTLJavaScriptParser::ImportStatementContext::STRING() {
  return getToken(CHTLJavaScriptParser::STRING, 0);
}


size_t CHTLJavaScriptParser::ImportStatementContext::getRuleIndex() const {
  return CHTLJavaScriptParser::RuleImportStatement;
}


std::any CHTLJavaScriptParser::ImportStatementContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<CHTLJavaScriptVisitor*>(visitor))
    return parserVisitor->visitImportStatement(this);
  else
    return visitor->visitChildren(this);
}

CHTLJavaScriptParser::ImportStatementContext* CHTLJavaScriptParser::importStatement() {
  ImportStatementContext *_localctx = _tracker.createInstance<ImportStatementContext>(_ctx, getState());
  enterRule(_localctx, 106, CHTLJavaScriptParser::RuleImportStatement);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(817);
    match(CHTLJavaScriptParser::IMPORT);
    setState(820);
    _errHandler->sync(this);
    switch (_input->LA(1)) {
      case CHTLJavaScriptParser::LBRACE:
      case CHTLJavaScriptParser::STAR: {
        setState(818);
        importFromBlock();
        break;
      }

      case CHTLJavaScriptParser::STRING: {
        setState(819);
        match(CHTLJavaScriptParser::STRING);
        break;
      }

    default:
      throw NoViableAltException(this);
    }
    setState(822);
    match(CHTLJavaScriptParser::SEMICOLON);
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- ImportFromBlockContext ------------------------------------------------------------------

CHTLJavaScriptParser::ImportFromBlockContext::ImportFromBlockContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* CHTLJavaScriptParser::ImportFromBlockContext::FROM() {
  return getToken(CHTLJavaScriptParser::FROM, 0);
}

tree::TerminalNode* CHTLJavaScriptParser::ImportFromBlockContext::STRING() {
  return getToken(CHTLJavaScriptParser::STRING, 0);
}

tree::TerminalNode* CHTLJavaScriptParser::ImportFromBlockContext::STAR() {
  return getToken(CHTLJavaScriptParser::STAR, 0);
}

tree::TerminalNode* CHTLJavaScriptParser::ImportFromBlockContext::AS() {
  return getToken(CHTLJavaScriptParser::AS, 0);
}

tree::TerminalNode* CHTLJavaScriptParser::ImportFromBlockContext::IDENTIFIER() {
  return getToken(CHTLJavaScriptParser::IDENTIFIER, 0);
}

CHTLJavaScriptParser::ImportNamespaceContext* CHTLJavaScriptParser::ImportFromBlockContext::importNamespace() {
  return getRuleContext<CHTLJavaScriptParser::ImportNamespaceContext>(0);
}


size_t CHTLJavaScriptParser::ImportFromBlockContext::getRuleIndex() const {
  return CHTLJavaScriptParser::RuleImportFromBlock;
}


std::any CHTLJavaScriptParser::ImportFromBlockContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<CHTLJavaScriptVisitor*>(visitor))
    return parserVisitor->visitImportFromBlock(this);
  else
    return visitor->visitChildren(this);
}

CHTLJavaScriptParser::ImportFromBlockContext* CHTLJavaScriptParser::importFromBlock() {
  ImportFromBlockContext *_localctx = _tracker.createInstance<ImportFromBlockContext>(_ctx, getState());
  enterRule(_localctx, 108, CHTLJavaScriptParser::RuleImportFromBlock);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(828);
    _errHandler->sync(this);
    switch (_input->LA(1)) {
      case CHTLJavaScriptParser::STAR: {
        setState(824);
        match(CHTLJavaScriptParser::STAR);
        setState(825);
        match(CHTLJavaScriptParser::AS);
        setState(826);
        match(CHTLJavaScriptParser::IDENTIFIER);
        break;
      }

      case CHTLJavaScriptParser::LBRACE: {
        setState(827);
        importNamespace();
        break;
      }

    default:
      throw NoViableAltException(this);
    }
    setState(830);
    match(CHTLJavaScriptParser::FROM);
    setState(831);
    match(CHTLJavaScriptParser::STRING);
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- ImportNamespaceContext ------------------------------------------------------------------

CHTLJavaScriptParser::ImportNamespaceContext::ImportNamespaceContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* CHTLJavaScriptParser::ImportNamespaceContext::LBRACE() {
  return getToken(CHTLJavaScriptParser::LBRACE, 0);
}

tree::TerminalNode* CHTLJavaScriptParser::ImportNamespaceContext::RBRACE() {
  return getToken(CHTLJavaScriptParser::RBRACE, 0);
}

std::vector<CHTLJavaScriptParser::ImportSpecifierContext *> CHTLJavaScriptParser::ImportNamespaceContext::importSpecifier() {
  return getRuleContexts<CHTLJavaScriptParser::ImportSpecifierContext>();
}

CHTLJavaScriptParser::ImportSpecifierContext* CHTLJavaScriptParser::ImportNamespaceContext::importSpecifier(size_t i) {
  return getRuleContext<CHTLJavaScriptParser::ImportSpecifierContext>(i);
}

std::vector<tree::TerminalNode *> CHTLJavaScriptParser::ImportNamespaceContext::COMMA() {
  return getTokens(CHTLJavaScriptParser::COMMA);
}

tree::TerminalNode* CHTLJavaScriptParser::ImportNamespaceContext::COMMA(size_t i) {
  return getToken(CHTLJavaScriptParser::COMMA, i);
}


size_t CHTLJavaScriptParser::ImportNamespaceContext::getRuleIndex() const {
  return CHTLJavaScriptParser::RuleImportNamespace;
}


std::any CHTLJavaScriptParser::ImportNamespaceContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<CHTLJavaScriptVisitor*>(visitor))
    return parserVisitor->visitImportNamespace(this);
  else
    return visitor->visitChildren(this);
}

CHTLJavaScriptParser::ImportNamespaceContext* CHTLJavaScriptParser::importNamespace() {
  ImportNamespaceContext *_localctx = _tracker.createInstance<ImportNamespaceContext>(_ctx, getState());
  enterRule(_localctx, 110, CHTLJavaScriptParser::RuleImportNamespace);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(833);
    match(CHTLJavaScriptParser::LBRACE);
    setState(842);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (_la == CHTLJavaScriptParser::IDENTIFIER || _la == CHTLJavaScriptParser::STRING) {
      setState(834);
      importSpecifier();
      setState(839);
      _errHandler->sync(this);
      _la = _input->LA(1);
      while (_la == CHTLJavaScriptParser::COMMA) {
        setState(835);
        match(CHTLJavaScriptParser::COMMA);
        setState(836);
        importSpecifier();
        setState(841);
        _errHandler->sync(this);
        _la = _input->LA(1);
      }
    }
    setState(844);
    match(CHTLJavaScriptParser::RBRACE);
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- ImportSpecifierContext ------------------------------------------------------------------

CHTLJavaScriptParser::ImportSpecifierContext::ImportSpecifierContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

std::vector<tree::TerminalNode *> CHTLJavaScriptParser::ImportSpecifierContext::IDENTIFIER() {
  return getTokens(CHTLJavaScriptParser::IDENTIFIER);
}

tree::TerminalNode* CHTLJavaScriptParser::ImportSpecifierContext::IDENTIFIER(size_t i) {
  return getToken(CHTLJavaScriptParser::IDENTIFIER, i);
}

CHTLJavaScriptParser::ModuleExportNameContext* CHTLJavaScriptParser::ImportSpecifierContext::moduleExportName() {
  return getRuleContext<CHTLJavaScriptParser::ModuleExportNameContext>(0);
}

tree::TerminalNode* CHTLJavaScriptParser::ImportSpecifierContext::AS() {
  return getToken(CHTLJavaScriptParser::AS, 0);
}


size_t CHTLJavaScriptParser::ImportSpecifierContext::getRuleIndex() const {
  return CHTLJavaScriptParser::RuleImportSpecifier;
}


std::any CHTLJavaScriptParser::ImportSpecifierContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<CHTLJavaScriptVisitor*>(visitor))
    return parserVisitor->visitImportSpecifier(this);
  else
    return visitor->visitChildren(this);
}

CHTLJavaScriptParser::ImportSpecifierContext* CHTLJavaScriptParser::importSpecifier() {
  ImportSpecifierContext *_localctx = _tracker.createInstance<ImportSpecifierContext>(_ctx, getState());
  enterRule(_localctx, 112, CHTLJavaScriptParser::RuleImportSpecifier);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(848);
    _errHandler->sync(this);
    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 63, _ctx)) {
    case 1: {
      setState(846);
      match(CHTLJavaScriptParser::IDENTIFIER);
      break;
    }

    case 2: {
      setState(847);
      moduleExportName();
      break;
    }

    default:
      break;
    }
    setState(852);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (_la == CHTLJavaScriptParser::AS) {
      setState(850);
      match(CHTLJavaScriptParser::AS);
      setState(851);
      match(CHTLJavaScriptParser::IDENTIFIER);
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- ModuleExportNameContext ------------------------------------------------------------------

CHTLJavaScriptParser::ModuleExportNameContext::ModuleExportNameContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* CHTLJavaScriptParser::ModuleExportNameContext::STRING() {
  return getToken(CHTLJavaScriptParser::STRING, 0);
}

tree::TerminalNode* CHTLJavaScriptParser::ModuleExportNameContext::IDENTIFIER() {
  return getToken(CHTLJavaScriptParser::IDENTIFIER, 0);
}


size_t CHTLJavaScriptParser::ModuleExportNameContext::getRuleIndex() const {
  return CHTLJavaScriptParser::RuleModuleExportName;
}


std::any CHTLJavaScriptParser::ModuleExportNameContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<CHTLJavaScriptVisitor*>(visitor))
    return parserVisitor->visitModuleExportName(this);
  else
    return visitor->visitChildren(this);
}

CHTLJavaScriptParser::ModuleExportNameContext* CHTLJavaScriptParser::moduleExportName() {
  ModuleExportNameContext *_localctx = _tracker.createInstance<ModuleExportNameContext>(_ctx, getState());
  enterRule(_localctx, 114, CHTLJavaScriptParser::RuleModuleExportName);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(854);
    _la = _input->LA(1);
    if (!(_la == CHTLJavaScriptParser::IDENTIFIER || _la == CHTLJavaScriptParser::STRING)) {
    _errHandler->recoverInline(this);
    }
    else {
      _errHandler->reportMatch(this);
      consume();
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- ExportStatementContext ------------------------------------------------------------------

CHTLJavaScriptParser::ExportStatementContext::ExportStatementContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* CHTLJavaScriptParser::ExportStatementContext::EXPORT() {
  return getToken(CHTLJavaScriptParser::EXPORT, 0);
}

tree::TerminalNode* CHTLJavaScriptParser::ExportStatementContext::SEMICOLON() {
  return getToken(CHTLJavaScriptParser::SEMICOLON, 0);
}

CHTLJavaScriptParser::ExportFromBlockContext* CHTLJavaScriptParser::ExportStatementContext::exportFromBlock() {
  return getRuleContext<CHTLJavaScriptParser::ExportFromBlockContext>(0);
}

CHTLJavaScriptParser::DeclarationContext* CHTLJavaScriptParser::ExportStatementContext::declaration() {
  return getRuleContext<CHTLJavaScriptParser::DeclarationContext>(0);
}

tree::TerminalNode* CHTLJavaScriptParser::ExportStatementContext::DEFAULT() {
  return getToken(CHTLJavaScriptParser::DEFAULT, 0);
}

CHTLJavaScriptParser::SingleExpressionContext* CHTLJavaScriptParser::ExportStatementContext::singleExpression() {
  return getRuleContext<CHTLJavaScriptParser::SingleExpressionContext>(0);
}


size_t CHTLJavaScriptParser::ExportStatementContext::getRuleIndex() const {
  return CHTLJavaScriptParser::RuleExportStatement;
}


std::any CHTLJavaScriptParser::ExportStatementContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<CHTLJavaScriptVisitor*>(visitor))
    return parserVisitor->visitExportStatement(this);
  else
    return visitor->visitChildren(this);
}

CHTLJavaScriptParser::ExportStatementContext* CHTLJavaScriptParser::exportStatement() {
  ExportStatementContext *_localctx = _tracker.createInstance<ExportStatementContext>(_ctx, getState());
  enterRule(_localctx, 116, CHTLJavaScriptParser::RuleExportStatement);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    setState(868);
    _errHandler->sync(this);
    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 66, _ctx)) {
    case 1: {
      enterOuterAlt(_localctx, 1);
      setState(856);
      match(CHTLJavaScriptParser::EXPORT);
      setState(859);
      _errHandler->sync(this);
      switch (_input->LA(1)) {
        case CHTLJavaScriptParser::LBRACE:
        case CHTLJavaScriptParser::STAR: {
          setState(857);
          exportFromBlock();
          break;
        }

        case CHTLJavaScriptParser::VAR:
        case CHTLJavaScriptParser::FUNCTION:
        case CHTLJavaScriptParser::CLASS:
        case CHTLJavaScriptParser::CONST:
        case CHTLJavaScriptParser::ASYNC:
        case CHTLJavaScriptParser::LET: {
          setState(858);
          declaration();
          break;
        }

      default:
        throw NoViableAltException(this);
      }
      setState(861);
      match(CHTLJavaScriptParser::SEMICOLON);
      break;
    }

    case 2: {
      enterOuterAlt(_localctx, 2);
      setState(863);
      match(CHTLJavaScriptParser::EXPORT);
      setState(864);
      match(CHTLJavaScriptParser::DEFAULT);
      setState(865);
      singleExpression(0);
      setState(866);
      match(CHTLJavaScriptParser::SEMICOLON);
      break;
    }

    default:
      break;
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- ExportFromBlockContext ------------------------------------------------------------------

CHTLJavaScriptParser::ExportFromBlockContext::ExportFromBlockContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* CHTLJavaScriptParser::ExportFromBlockContext::FROM() {
  return getToken(CHTLJavaScriptParser::FROM, 0);
}

tree::TerminalNode* CHTLJavaScriptParser::ExportFromBlockContext::STRING() {
  return getToken(CHTLJavaScriptParser::STRING, 0);
}

tree::TerminalNode* CHTLJavaScriptParser::ExportFromBlockContext::STAR() {
  return getToken(CHTLJavaScriptParser::STAR, 0);
}

CHTLJavaScriptParser::ExportNamespaceContext* CHTLJavaScriptParser::ExportFromBlockContext::exportNamespace() {
  return getRuleContext<CHTLJavaScriptParser::ExportNamespaceContext>(0);
}


size_t CHTLJavaScriptParser::ExportFromBlockContext::getRuleIndex() const {
  return CHTLJavaScriptParser::RuleExportFromBlock;
}


std::any CHTLJavaScriptParser::ExportFromBlockContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<CHTLJavaScriptVisitor*>(visitor))
    return parserVisitor->visitExportFromBlock(this);
  else
    return visitor->visitChildren(this);
}

CHTLJavaScriptParser::ExportFromBlockContext* CHTLJavaScriptParser::exportFromBlock() {
  ExportFromBlockContext *_localctx = _tracker.createInstance<ExportFromBlockContext>(_ctx, getState());
  enterRule(_localctx, 118, CHTLJavaScriptParser::RuleExportFromBlock);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(872);
    _errHandler->sync(this);
    switch (_input->LA(1)) {
      case CHTLJavaScriptParser::STAR: {
        setState(870);
        match(CHTLJavaScriptParser::STAR);
        break;
      }

      case CHTLJavaScriptParser::LBRACE: {
        setState(871);
        exportNamespace();
        break;
      }

    default:
      throw NoViableAltException(this);
    }
    setState(874);
    match(CHTLJavaScriptParser::FROM);
    setState(875);
    match(CHTLJavaScriptParser::STRING);
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- ExportNamespaceContext ------------------------------------------------------------------

CHTLJavaScriptParser::ExportNamespaceContext::ExportNamespaceContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* CHTLJavaScriptParser::ExportNamespaceContext::LBRACE() {
  return getToken(CHTLJavaScriptParser::LBRACE, 0);
}

tree::TerminalNode* CHTLJavaScriptParser::ExportNamespaceContext::RBRACE() {
  return getToken(CHTLJavaScriptParser::RBRACE, 0);
}

std::vector<CHTLJavaScriptParser::ExportSpecifierContext *> CHTLJavaScriptParser::ExportNamespaceContext::exportSpecifier() {
  return getRuleContexts<CHTLJavaScriptParser::ExportSpecifierContext>();
}

CHTLJavaScriptParser::ExportSpecifierContext* CHTLJavaScriptParser::ExportNamespaceContext::exportSpecifier(size_t i) {
  return getRuleContext<CHTLJavaScriptParser::ExportSpecifierContext>(i);
}

std::vector<tree::TerminalNode *> CHTLJavaScriptParser::ExportNamespaceContext::COMMA() {
  return getTokens(CHTLJavaScriptParser::COMMA);
}

tree::TerminalNode* CHTLJavaScriptParser::ExportNamespaceContext::COMMA(size_t i) {
  return getToken(CHTLJavaScriptParser::COMMA, i);
}


size_t CHTLJavaScriptParser::ExportNamespaceContext::getRuleIndex() const {
  return CHTLJavaScriptParser::RuleExportNamespace;
}


std::any CHTLJavaScriptParser::ExportNamespaceContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<CHTLJavaScriptVisitor*>(visitor))
    return parserVisitor->visitExportNamespace(this);
  else
    return visitor->visitChildren(this);
}

CHTLJavaScriptParser::ExportNamespaceContext* CHTLJavaScriptParser::exportNamespace() {
  ExportNamespaceContext *_localctx = _tracker.createInstance<ExportNamespaceContext>(_ctx, getState());
  enterRule(_localctx, 120, CHTLJavaScriptParser::RuleExportNamespace);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(877);
    match(CHTLJavaScriptParser::LBRACE);
    setState(886);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (_la == CHTLJavaScriptParser::IDENTIFIER || _la == CHTLJavaScriptParser::STRING) {
      setState(878);
      exportSpecifier();
      setState(883);
      _errHandler->sync(this);
      _la = _input->LA(1);
      while (_la == CHTLJavaScriptParser::COMMA) {
        setState(879);
        match(CHTLJavaScriptParser::COMMA);
        setState(880);
        exportSpecifier();
        setState(885);
        _errHandler->sync(this);
        _la = _input->LA(1);
      }
    }
    setState(888);
    match(CHTLJavaScriptParser::RBRACE);
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- ExportSpecifierContext ------------------------------------------------------------------

CHTLJavaScriptParser::ExportSpecifierContext::ExportSpecifierContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* CHTLJavaScriptParser::ExportSpecifierContext::IDENTIFIER() {
  return getToken(CHTLJavaScriptParser::IDENTIFIER, 0);
}

std::vector<CHTLJavaScriptParser::ModuleExportNameContext *> CHTLJavaScriptParser::ExportSpecifierContext::moduleExportName() {
  return getRuleContexts<CHTLJavaScriptParser::ModuleExportNameContext>();
}

CHTLJavaScriptParser::ModuleExportNameContext* CHTLJavaScriptParser::ExportSpecifierContext::moduleExportName(size_t i) {
  return getRuleContext<CHTLJavaScriptParser::ModuleExportNameContext>(i);
}

tree::TerminalNode* CHTLJavaScriptParser::ExportSpecifierContext::AS() {
  return getToken(CHTLJavaScriptParser::AS, 0);
}


size_t CHTLJavaScriptParser::ExportSpecifierContext::getRuleIndex() const {
  return CHTLJavaScriptParser::RuleExportSpecifier;
}


std::any CHTLJavaScriptParser::ExportSpecifierContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<CHTLJavaScriptVisitor*>(visitor))
    return parserVisitor->visitExportSpecifier(this);
  else
    return visitor->visitChildren(this);
}

CHTLJavaScriptParser::ExportSpecifierContext* CHTLJavaScriptParser::exportSpecifier() {
  ExportSpecifierContext *_localctx = _tracker.createInstance<ExportSpecifierContext>(_ctx, getState());
  enterRule(_localctx, 122, CHTLJavaScriptParser::RuleExportSpecifier);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(892);
    _errHandler->sync(this);
    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 70, _ctx)) {
    case 1: {
      setState(890);
      match(CHTLJavaScriptParser::IDENTIFIER);
      break;
    }

    case 2: {
      setState(891);
      moduleExportName();
      break;
    }

    default:
      break;
    }
    setState(896);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (_la == CHTLJavaScriptParser::AS) {
      setState(894);
      match(CHTLJavaScriptParser::AS);
      setState(895);
      moduleExportName();
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- DeclarationContext ------------------------------------------------------------------

CHTLJavaScriptParser::DeclarationContext::DeclarationContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

CHTLJavaScriptParser::VariableStatementContext* CHTLJavaScriptParser::DeclarationContext::variableStatement() {
  return getRuleContext<CHTLJavaScriptParser::VariableStatementContext>(0);
}

CHTLJavaScriptParser::ClassDeclarationContext* CHTLJavaScriptParser::DeclarationContext::classDeclaration() {
  return getRuleContext<CHTLJavaScriptParser::ClassDeclarationContext>(0);
}

CHTLJavaScriptParser::FunctionDeclarationContext* CHTLJavaScriptParser::DeclarationContext::functionDeclaration() {
  return getRuleContext<CHTLJavaScriptParser::FunctionDeclarationContext>(0);
}


size_t CHTLJavaScriptParser::DeclarationContext::getRuleIndex() const {
  return CHTLJavaScriptParser::RuleDeclaration;
}


std::any CHTLJavaScriptParser::DeclarationContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<CHTLJavaScriptVisitor*>(visitor))
    return parserVisitor->visitDeclaration(this);
  else
    return visitor->visitChildren(this);
}

CHTLJavaScriptParser::DeclarationContext* CHTLJavaScriptParser::declaration() {
  DeclarationContext *_localctx = _tracker.createInstance<DeclarationContext>(_ctx, getState());
  enterRule(_localctx, 124, CHTLJavaScriptParser::RuleDeclaration);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    setState(901);
    _errHandler->sync(this);
    switch (_input->LA(1)) {
      case CHTLJavaScriptParser::VAR:
      case CHTLJavaScriptParser::CONST:
      case CHTLJavaScriptParser::LET: {
        enterOuterAlt(_localctx, 1);
        setState(898);
        variableStatement();
        break;
      }

      case CHTLJavaScriptParser::CLASS: {
        enterOuterAlt(_localctx, 2);
        setState(899);
        classDeclaration();
        break;
      }

      case CHTLJavaScriptParser::FUNCTION:
      case CHTLJavaScriptParser::ASYNC: {
        enterOuterAlt(_localctx, 3);
        setState(900);
        functionDeclaration();
        break;
      }

    default:
      throw NoViableAltException(this);
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- FormalParameterListContext ------------------------------------------------------------------

CHTLJavaScriptParser::FormalParameterListContext::FormalParameterListContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

std::vector<CHTLJavaScriptParser::FormalParameterContext *> CHTLJavaScriptParser::FormalParameterListContext::formalParameter() {
  return getRuleContexts<CHTLJavaScriptParser::FormalParameterContext>();
}

CHTLJavaScriptParser::FormalParameterContext* CHTLJavaScriptParser::FormalParameterListContext::formalParameter(size_t i) {
  return getRuleContext<CHTLJavaScriptParser::FormalParameterContext>(i);
}

std::vector<tree::TerminalNode *> CHTLJavaScriptParser::FormalParameterListContext::COMMA() {
  return getTokens(CHTLJavaScriptParser::COMMA);
}

tree::TerminalNode* CHTLJavaScriptParser::FormalParameterListContext::COMMA(size_t i) {
  return getToken(CHTLJavaScriptParser::COMMA, i);
}

CHTLJavaScriptParser::RestParameterContext* CHTLJavaScriptParser::FormalParameterListContext::restParameter() {
  return getRuleContext<CHTLJavaScriptParser::RestParameterContext>(0);
}


size_t CHTLJavaScriptParser::FormalParameterListContext::getRuleIndex() const {
  return CHTLJavaScriptParser::RuleFormalParameterList;
}


std::any CHTLJavaScriptParser::FormalParameterListContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<CHTLJavaScriptVisitor*>(visitor))
    return parserVisitor->visitFormalParameterList(this);
  else
    return visitor->visitChildren(this);
}

CHTLJavaScriptParser::FormalParameterListContext* CHTLJavaScriptParser::formalParameterList() {
  FormalParameterListContext *_localctx = _tracker.createInstance<FormalParameterListContext>(_ctx, getState());
  enterRule(_localctx, 126, CHTLJavaScriptParser::RuleFormalParameterList);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    size_t alt;
    setState(916);
    _errHandler->sync(this);
    switch (_input->LA(1)) {
      case CHTLJavaScriptParser::IDENTIFIER:
      case CHTLJavaScriptParser::LBRACE:
      case CHTLJavaScriptParser::LBRACKET: {
        enterOuterAlt(_localctx, 1);
        setState(903);
        formalParameter();
        setState(908);
        _errHandler->sync(this);
        alt = getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 73, _ctx);
        while (alt != 2 && alt != atn::ATN::INVALID_ALT_NUMBER) {
          if (alt == 1) {
            setState(904);
            match(CHTLJavaScriptParser::COMMA);
            setState(905);
            formalParameter(); 
          }
          setState(910);
          _errHandler->sync(this);
          alt = getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 73, _ctx);
        }
        setState(913);
        _errHandler->sync(this);

        _la = _input->LA(1);
        if (_la == CHTLJavaScriptParser::COMMA) {
          setState(911);
          match(CHTLJavaScriptParser::COMMA);
          setState(912);
          restParameter();
        }
        break;
      }

      case CHTLJavaScriptParser::ELLIPSIS: {
        enterOuterAlt(_localctx, 2);
        setState(915);
        restParameter();
        break;
      }

    default:
      throw NoViableAltException(this);
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- FormalParameterContext ------------------------------------------------------------------

CHTLJavaScriptParser::FormalParameterContext::FormalParameterContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

CHTLJavaScriptParser::AssignableContext* CHTLJavaScriptParser::FormalParameterContext::assignable() {
  return getRuleContext<CHTLJavaScriptParser::AssignableContext>(0);
}

tree::TerminalNode* CHTLJavaScriptParser::FormalParameterContext::EQUALS() {
  return getToken(CHTLJavaScriptParser::EQUALS, 0);
}

CHTLJavaScriptParser::SingleExpressionContext* CHTLJavaScriptParser::FormalParameterContext::singleExpression() {
  return getRuleContext<CHTLJavaScriptParser::SingleExpressionContext>(0);
}


size_t CHTLJavaScriptParser::FormalParameterContext::getRuleIndex() const {
  return CHTLJavaScriptParser::RuleFormalParameter;
}


std::any CHTLJavaScriptParser::FormalParameterContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<CHTLJavaScriptVisitor*>(visitor))
    return parserVisitor->visitFormalParameter(this);
  else
    return visitor->visitChildren(this);
}

CHTLJavaScriptParser::FormalParameterContext* CHTLJavaScriptParser::formalParameter() {
  FormalParameterContext *_localctx = _tracker.createInstance<FormalParameterContext>(_ctx, getState());
  enterRule(_localctx, 128, CHTLJavaScriptParser::RuleFormalParameter);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(918);
    assignable();
    setState(921);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (_la == CHTLJavaScriptParser::EQUALS) {
      setState(919);
      match(CHTLJavaScriptParser::EQUALS);
      setState(920);
      singleExpression(0);
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- RestParameterContext ------------------------------------------------------------------

CHTLJavaScriptParser::RestParameterContext::RestParameterContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* CHTLJavaScriptParser::RestParameterContext::ELLIPSIS() {
  return getToken(CHTLJavaScriptParser::ELLIPSIS, 0);
}

CHTLJavaScriptParser::AssignableContext* CHTLJavaScriptParser::RestParameterContext::assignable() {
  return getRuleContext<CHTLJavaScriptParser::AssignableContext>(0);
}


size_t CHTLJavaScriptParser::RestParameterContext::getRuleIndex() const {
  return CHTLJavaScriptParser::RuleRestParameter;
}


std::any CHTLJavaScriptParser::RestParameterContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<CHTLJavaScriptVisitor*>(visitor))
    return parserVisitor->visitRestParameter(this);
  else
    return visitor->visitChildren(this);
}

CHTLJavaScriptParser::RestParameterContext* CHTLJavaScriptParser::restParameter() {
  RestParameterContext *_localctx = _tracker.createInstance<RestParameterContext>(_ctx, getState());
  enterRule(_localctx, 130, CHTLJavaScriptParser::RuleRestParameter);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(923);
    match(CHTLJavaScriptParser::ELLIPSIS);
    setState(924);
    assignable();
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- AssignableContext ------------------------------------------------------------------

CHTLJavaScriptParser::AssignableContext::AssignableContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* CHTLJavaScriptParser::AssignableContext::IDENTIFIER() {
  return getToken(CHTLJavaScriptParser::IDENTIFIER, 0);
}

CHTLJavaScriptParser::ArrayLiteralContext* CHTLJavaScriptParser::AssignableContext::arrayLiteral() {
  return getRuleContext<CHTLJavaScriptParser::ArrayLiteralContext>(0);
}

CHTLJavaScriptParser::ObjectLiteralContext* CHTLJavaScriptParser::AssignableContext::objectLiteral() {
  return getRuleContext<CHTLJavaScriptParser::ObjectLiteralContext>(0);
}


size_t CHTLJavaScriptParser::AssignableContext::getRuleIndex() const {
  return CHTLJavaScriptParser::RuleAssignable;
}


std::any CHTLJavaScriptParser::AssignableContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<CHTLJavaScriptVisitor*>(visitor))
    return parserVisitor->visitAssignable(this);
  else
    return visitor->visitChildren(this);
}

CHTLJavaScriptParser::AssignableContext* CHTLJavaScriptParser::assignable() {
  AssignableContext *_localctx = _tracker.createInstance<AssignableContext>(_ctx, getState());
  enterRule(_localctx, 132, CHTLJavaScriptParser::RuleAssignable);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    setState(929);
    _errHandler->sync(this);
    switch (_input->LA(1)) {
      case CHTLJavaScriptParser::IDENTIFIER: {
        enterOuterAlt(_localctx, 1);
        setState(926);
        match(CHTLJavaScriptParser::IDENTIFIER);
        break;
      }

      case CHTLJavaScriptParser::LBRACKET: {
        enterOuterAlt(_localctx, 2);
        setState(927);
        arrayLiteral();
        break;
      }

      case CHTLJavaScriptParser::LBRACE: {
        enterOuterAlt(_localctx, 3);
        setState(928);
        objectLiteral();
        break;
      }

    default:
      throw NoViableAltException(this);
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- PropertyNameContext ------------------------------------------------------------------

CHTLJavaScriptParser::PropertyNameContext::PropertyNameContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

CHTLJavaScriptParser::IdentifierNameContext* CHTLJavaScriptParser::PropertyNameContext::identifierName() {
  return getRuleContext<CHTLJavaScriptParser::IdentifierNameContext>(0);
}

tree::TerminalNode* CHTLJavaScriptParser::PropertyNameContext::STRING() {
  return getToken(CHTLJavaScriptParser::STRING, 0);
}

tree::TerminalNode* CHTLJavaScriptParser::PropertyNameContext::NUMBER() {
  return getToken(CHTLJavaScriptParser::NUMBER, 0);
}

tree::TerminalNode* CHTLJavaScriptParser::PropertyNameContext::LBRACKET() {
  return getToken(CHTLJavaScriptParser::LBRACKET, 0);
}

CHTLJavaScriptParser::SingleExpressionContext* CHTLJavaScriptParser::PropertyNameContext::singleExpression() {
  return getRuleContext<CHTLJavaScriptParser::SingleExpressionContext>(0);
}

tree::TerminalNode* CHTLJavaScriptParser::PropertyNameContext::RBRACKET() {
  return getToken(CHTLJavaScriptParser::RBRACKET, 0);
}


size_t CHTLJavaScriptParser::PropertyNameContext::getRuleIndex() const {
  return CHTLJavaScriptParser::RulePropertyName;
}


std::any CHTLJavaScriptParser::PropertyNameContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<CHTLJavaScriptVisitor*>(visitor))
    return parserVisitor->visitPropertyName(this);
  else
    return visitor->visitChildren(this);
}

CHTLJavaScriptParser::PropertyNameContext* CHTLJavaScriptParser::propertyName() {
  PropertyNameContext *_localctx = _tracker.createInstance<PropertyNameContext>(_ctx, getState());
  enterRule(_localctx, 134, CHTLJavaScriptParser::RulePropertyName);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    setState(938);
    _errHandler->sync(this);
    switch (_input->LA(1)) {
      case CHTLJavaScriptParser::IDENTIFIER:
      case CHTLJavaScriptParser::BREAK:
      case CHTLJavaScriptParser::DO:
      case CHTLJavaScriptParser::INSTANCEOF:
      case CHTLJavaScriptParser::TYPEOF:
      case CHTLJavaScriptParser::CASE:
      case CHTLJavaScriptParser::ELSE:
      case CHTLJavaScriptParser::NEW:
      case CHTLJavaScriptParser::VAR:
      case CHTLJavaScriptParser::CATCH:
      case CHTLJavaScriptParser::FINALLY:
      case CHTLJavaScriptParser::RETURN:
      case CHTLJavaScriptParser::VOID:
      case CHTLJavaScriptParser::CONTINUE:
      case CHTLJavaScriptParser::FOR:
      case CHTLJavaScriptParser::SWITCH:
      case CHTLJavaScriptParser::WHILE:
      case CHTLJavaScriptParser::DEBUGGER:
      case CHTLJavaScriptParser::FUNCTION:
      case CHTLJavaScriptParser::THIS:
      case CHTLJavaScriptParser::WITH:
      case CHTLJavaScriptParser::DEFAULT:
      case CHTLJavaScriptParser::IF:
      case CHTLJavaScriptParser::THROW:
      case CHTLJavaScriptParser::DELETE:
      case CHTLJavaScriptParser::IN:
      case CHTLJavaScriptParser::TRY:
      case CHTLJavaScriptParser::CLASS:
      case CHTLJavaScriptParser::ENUM:
      case CHTLJavaScriptParser::EXTENDS:
      case CHTLJavaScriptParser::SUPER:
      case CHTLJavaScriptParser::CONST:
      case CHTLJavaScriptParser::EXPORT:
      case CHTLJavaScriptParser::IMPORT:
      case CHTLJavaScriptParser::ASYNC:
      case CHTLJavaScriptParser::AWAIT:
      case CHTLJavaScriptParser::YIELD:
      case CHTLJavaScriptParser::LET:
      case CHTLJavaScriptParser::STATIC:
      case CHTLJavaScriptParser::FROM:
      case CHTLJavaScriptParser::AS:
      case CHTLJavaScriptParser::OF:
      case CHTLJavaScriptParser::NULL_:
      case CHTLJavaScriptParser::BOOLEAN: {
        enterOuterAlt(_localctx, 1);
        setState(931);
        identifierName();
        break;
      }

      case CHTLJavaScriptParser::STRING: {
        enterOuterAlt(_localctx, 2);
        setState(932);
        match(CHTLJavaScriptParser::STRING);
        break;
      }

      case CHTLJavaScriptParser::NUMBER: {
        enterOuterAlt(_localctx, 3);
        setState(933);
        match(CHTLJavaScriptParser::NUMBER);
        break;
      }

      case CHTLJavaScriptParser::LBRACKET: {
        enterOuterAlt(_localctx, 4);
        setState(934);
        match(CHTLJavaScriptParser::LBRACKET);
        setState(935);
        singleExpression(0);
        setState(936);
        match(CHTLJavaScriptParser::RBRACKET);
        break;
      }

    default:
      throw NoViableAltException(this);
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- ExpressionSequenceContext ------------------------------------------------------------------

CHTLJavaScriptParser::ExpressionSequenceContext::ExpressionSequenceContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

std::vector<CHTLJavaScriptParser::SingleExpressionContext *> CHTLJavaScriptParser::ExpressionSequenceContext::singleExpression() {
  return getRuleContexts<CHTLJavaScriptParser::SingleExpressionContext>();
}

CHTLJavaScriptParser::SingleExpressionContext* CHTLJavaScriptParser::ExpressionSequenceContext::singleExpression(size_t i) {
  return getRuleContext<CHTLJavaScriptParser::SingleExpressionContext>(i);
}

std::vector<tree::TerminalNode *> CHTLJavaScriptParser::ExpressionSequenceContext::COMMA() {
  return getTokens(CHTLJavaScriptParser::COMMA);
}

tree::TerminalNode* CHTLJavaScriptParser::ExpressionSequenceContext::COMMA(size_t i) {
  return getToken(CHTLJavaScriptParser::COMMA, i);
}


size_t CHTLJavaScriptParser::ExpressionSequenceContext::getRuleIndex() const {
  return CHTLJavaScriptParser::RuleExpressionSequence;
}


std::any CHTLJavaScriptParser::ExpressionSequenceContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<CHTLJavaScriptVisitor*>(visitor))
    return parserVisitor->visitExpressionSequence(this);
  else
    return visitor->visitChildren(this);
}

CHTLJavaScriptParser::ExpressionSequenceContext* CHTLJavaScriptParser::expressionSequence() {
  ExpressionSequenceContext *_localctx = _tracker.createInstance<ExpressionSequenceContext>(_ctx, getState());
  enterRule(_localctx, 136, CHTLJavaScriptParser::RuleExpressionSequence);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(940);
    singleExpression(0);
    setState(945);
    _errHandler->sync(this);
    _la = _input->LA(1);
    while (_la == CHTLJavaScriptParser::COMMA) {
      setState(941);
      match(CHTLJavaScriptParser::COMMA);
      setState(942);
      singleExpression(0);
      setState(947);
      _errHandler->sync(this);
      _la = _input->LA(1);
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- AssignmentOperatorContext ------------------------------------------------------------------

CHTLJavaScriptParser::AssignmentOperatorContext::AssignmentOperatorContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* CHTLJavaScriptParser::AssignmentOperatorContext::STAR_EQUALS() {
  return getToken(CHTLJavaScriptParser::STAR_EQUALS, 0);
}

tree::TerminalNode* CHTLJavaScriptParser::AssignmentOperatorContext::SLASH_EQUALS() {
  return getToken(CHTLJavaScriptParser::SLASH_EQUALS, 0);
}

tree::TerminalNode* CHTLJavaScriptParser::AssignmentOperatorContext::PERCENT_EQUALS() {
  return getToken(CHTLJavaScriptParser::PERCENT_EQUALS, 0);
}

tree::TerminalNode* CHTLJavaScriptParser::AssignmentOperatorContext::PLUS_EQUALS() {
  return getToken(CHTLJavaScriptParser::PLUS_EQUALS, 0);
}

tree::TerminalNode* CHTLJavaScriptParser::AssignmentOperatorContext::MINUS_EQUALS() {
  return getToken(CHTLJavaScriptParser::MINUS_EQUALS, 0);
}

tree::TerminalNode* CHTLJavaScriptParser::AssignmentOperatorContext::LSHIFT_EQUALS() {
  return getToken(CHTLJavaScriptParser::LSHIFT_EQUALS, 0);
}

tree::TerminalNode* CHTLJavaScriptParser::AssignmentOperatorContext::RSHIFT_EQUALS() {
  return getToken(CHTLJavaScriptParser::RSHIFT_EQUALS, 0);
}

tree::TerminalNode* CHTLJavaScriptParser::AssignmentOperatorContext::URSHIFT_EQUALS() {
  return getToken(CHTLJavaScriptParser::URSHIFT_EQUALS, 0);
}

tree::TerminalNode* CHTLJavaScriptParser::AssignmentOperatorContext::AMPERSAND_EQUALS() {
  return getToken(CHTLJavaScriptParser::AMPERSAND_EQUALS, 0);
}

tree::TerminalNode* CHTLJavaScriptParser::AssignmentOperatorContext::CARET_EQUALS() {
  return getToken(CHTLJavaScriptParser::CARET_EQUALS, 0);
}

tree::TerminalNode* CHTLJavaScriptParser::AssignmentOperatorContext::PIPE_EQUALS() {
  return getToken(CHTLJavaScriptParser::PIPE_EQUALS, 0);
}

tree::TerminalNode* CHTLJavaScriptParser::AssignmentOperatorContext::POWER_EQUALS() {
  return getToken(CHTLJavaScriptParser::POWER_EQUALS, 0);
}

tree::TerminalNode* CHTLJavaScriptParser::AssignmentOperatorContext::NULLISH_EQUALS() {
  return getToken(CHTLJavaScriptParser::NULLISH_EQUALS, 0);
}


size_t CHTLJavaScriptParser::AssignmentOperatorContext::getRuleIndex() const {
  return CHTLJavaScriptParser::RuleAssignmentOperator;
}


std::any CHTLJavaScriptParser::AssignmentOperatorContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<CHTLJavaScriptVisitor*>(visitor))
    return parserVisitor->visitAssignmentOperator(this);
  else
    return visitor->visitChildren(this);
}

CHTLJavaScriptParser::AssignmentOperatorContext* CHTLJavaScriptParser::assignmentOperator() {
  AssignmentOperatorContext *_localctx = _tracker.createInstance<AssignmentOperatorContext>(_ctx, getState());
  enterRule(_localctx, 138, CHTLJavaScriptParser::RuleAssignmentOperator);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(948);
    _la = _input->LA(1);
    if (!(((((_la - 86) & ~ 0x3fULL) == 0) &&
      ((1ULL << (_la - 86)) & 8191) != 0))) {
    _errHandler->recoverInline(this);
    }
    else {
      _errHandler->reportMatch(this);
      consume();
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- LiteralContext ------------------------------------------------------------------

CHTLJavaScriptParser::LiteralContext::LiteralContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* CHTLJavaScriptParser::LiteralContext::NUMBER() {
  return getToken(CHTLJavaScriptParser::NUMBER, 0);
}

tree::TerminalNode* CHTLJavaScriptParser::LiteralContext::STRING() {
  return getToken(CHTLJavaScriptParser::STRING, 0);
}

tree::TerminalNode* CHTLJavaScriptParser::LiteralContext::TEMPLATE_STRING() {
  return getToken(CHTLJavaScriptParser::TEMPLATE_STRING, 0);
}

tree::TerminalNode* CHTLJavaScriptParser::LiteralContext::BOOLEAN() {
  return getToken(CHTLJavaScriptParser::BOOLEAN, 0);
}

tree::TerminalNode* CHTLJavaScriptParser::LiteralContext::NULL_() {
  return getToken(CHTLJavaScriptParser::NULL_, 0);
}

tree::TerminalNode* CHTLJavaScriptParser::LiteralContext::UNDEFINED() {
  return getToken(CHTLJavaScriptParser::UNDEFINED, 0);
}

tree::TerminalNode* CHTLJavaScriptParser::LiteralContext::REGEX() {
  return getToken(CHTLJavaScriptParser::REGEX, 0);
}


size_t CHTLJavaScriptParser::LiteralContext::getRuleIndex() const {
  return CHTLJavaScriptParser::RuleLiteral;
}


std::any CHTLJavaScriptParser::LiteralContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<CHTLJavaScriptVisitor*>(visitor))
    return parserVisitor->visitLiteral(this);
  else
    return visitor->visitChildren(this);
}

CHTLJavaScriptParser::LiteralContext* CHTLJavaScriptParser::literal() {
  LiteralContext *_localctx = _tracker.createInstance<LiteralContext>(_ctx, getState());
  enterRule(_localctx, 140, CHTLJavaScriptParser::RuleLiteral);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(950);
    _la = _input->LA(1);
    if (!(_la == CHTLJavaScriptParser::TEMPLATE_STRING

    || _la == CHTLJavaScriptParser::REGEX || ((((_la - 70) & ~ 0x3fULL) == 0) &&
      ((1ULL << (_la - 70)) & 720575940379279367) != 0))) {
    _errHandler->recoverInline(this);
    }
    else {
      _errHandler->reportMatch(this);
      consume();
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- ArrayLiteralContext ------------------------------------------------------------------

CHTLJavaScriptParser::ArrayLiteralContext::ArrayLiteralContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* CHTLJavaScriptParser::ArrayLiteralContext::LBRACKET() {
  return getToken(CHTLJavaScriptParser::LBRACKET, 0);
}

tree::TerminalNode* CHTLJavaScriptParser::ArrayLiteralContext::RBRACKET() {
  return getToken(CHTLJavaScriptParser::RBRACKET, 0);
}

CHTLJavaScriptParser::ElementListContext* CHTLJavaScriptParser::ArrayLiteralContext::elementList() {
  return getRuleContext<CHTLJavaScriptParser::ElementListContext>(0);
}


size_t CHTLJavaScriptParser::ArrayLiteralContext::getRuleIndex() const {
  return CHTLJavaScriptParser::RuleArrayLiteral;
}


std::any CHTLJavaScriptParser::ArrayLiteralContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<CHTLJavaScriptVisitor*>(visitor))
    return parserVisitor->visitArrayLiteral(this);
  else
    return visitor->visitChildren(this);
}

CHTLJavaScriptParser::ArrayLiteralContext* CHTLJavaScriptParser::arrayLiteral() {
  ArrayLiteralContext *_localctx = _tracker.createInstance<ArrayLiteralContext>(_ctx, getState());
  enterRule(_localctx, 142, CHTLJavaScriptParser::RuleArrayLiteral);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(952);
    match(CHTLJavaScriptParser::LBRACKET);
    setState(954);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if ((((_la & ~ 0x3fULL) == 0) &&
      ((1ULL << _la) & 3532001068879709188) != 0) || ((((_la - 70) & ~ 0x3fULL) == 0) &&
      ((1ULL << (_la - 70)) & 720576008025031855) != 0)) {
      setState(953);
      elementList();
    }
    setState(956);
    match(CHTLJavaScriptParser::RBRACKET);
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- ElementListContext ------------------------------------------------------------------

CHTLJavaScriptParser::ElementListContext::ElementListContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

std::vector<CHTLJavaScriptParser::ArrayElementContext *> CHTLJavaScriptParser::ElementListContext::arrayElement() {
  return getRuleContexts<CHTLJavaScriptParser::ArrayElementContext>();
}

CHTLJavaScriptParser::ArrayElementContext* CHTLJavaScriptParser::ElementListContext::arrayElement(size_t i) {
  return getRuleContext<CHTLJavaScriptParser::ArrayElementContext>(i);
}

std::vector<tree::TerminalNode *> CHTLJavaScriptParser::ElementListContext::COMMA() {
  return getTokens(CHTLJavaScriptParser::COMMA);
}

tree::TerminalNode* CHTLJavaScriptParser::ElementListContext::COMMA(size_t i) {
  return getToken(CHTLJavaScriptParser::COMMA, i);
}


size_t CHTLJavaScriptParser::ElementListContext::getRuleIndex() const {
  return CHTLJavaScriptParser::RuleElementList;
}


std::any CHTLJavaScriptParser::ElementListContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<CHTLJavaScriptVisitor*>(visitor))
    return parserVisitor->visitElementList(this);
  else
    return visitor->visitChildren(this);
}

CHTLJavaScriptParser::ElementListContext* CHTLJavaScriptParser::elementList() {
  ElementListContext *_localctx = _tracker.createInstance<ElementListContext>(_ctx, getState());
  enterRule(_localctx, 144, CHTLJavaScriptParser::RuleElementList);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(958);
    arrayElement();
    setState(963);
    _errHandler->sync(this);
    _la = _input->LA(1);
    while (_la == CHTLJavaScriptParser::COMMA) {
      setState(959);
      match(CHTLJavaScriptParser::COMMA);
      setState(960);
      arrayElement();
      setState(965);
      _errHandler->sync(this);
      _la = _input->LA(1);
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- ArrayElementContext ------------------------------------------------------------------

CHTLJavaScriptParser::ArrayElementContext::ArrayElementContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

CHTLJavaScriptParser::SingleExpressionContext* CHTLJavaScriptParser::ArrayElementContext::singleExpression() {
  return getRuleContext<CHTLJavaScriptParser::SingleExpressionContext>(0);
}

tree::TerminalNode* CHTLJavaScriptParser::ArrayElementContext::ELLIPSIS() {
  return getToken(CHTLJavaScriptParser::ELLIPSIS, 0);
}

tree::TerminalNode* CHTLJavaScriptParser::ArrayElementContext::COMMA() {
  return getToken(CHTLJavaScriptParser::COMMA, 0);
}


size_t CHTLJavaScriptParser::ArrayElementContext::getRuleIndex() const {
  return CHTLJavaScriptParser::RuleArrayElement;
}


std::any CHTLJavaScriptParser::ArrayElementContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<CHTLJavaScriptVisitor*>(visitor))
    return parserVisitor->visitArrayElement(this);
  else
    return visitor->visitChildren(this);
}

CHTLJavaScriptParser::ArrayElementContext* CHTLJavaScriptParser::arrayElement() {
  ArrayElementContext *_localctx = _tracker.createInstance<ArrayElementContext>(_ctx, getState());
  enterRule(_localctx, 146, CHTLJavaScriptParser::RuleArrayElement);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    setState(971);
    _errHandler->sync(this);
    switch (_input->LA(1)) {
      case CHTLJavaScriptParser::CHTL_SELECTOR_START:
      case CHTLJavaScriptParser::ANIMATE:
      case CHTLJavaScriptParser::TEMPLATE_STRING:
      case CHTLJavaScriptParser::REGEX:
      case CHTLJavaScriptParser::IDENTIFIER:
      case CHTLJavaScriptParser::TYPEOF:
      case CHTLJavaScriptParser::NEW:
      case CHTLJavaScriptParser::VOID:
      case CHTLJavaScriptParser::FUNCTION:
      case CHTLJavaScriptParser::THIS:
      case CHTLJavaScriptParser::DELETE:
      case CHTLJavaScriptParser::SUPER:
      case CHTLJavaScriptParser::ASYNC:
      case CHTLJavaScriptParser::AWAIT:
      case CHTLJavaScriptParser::NULL_:
      case CHTLJavaScriptParser::BOOLEAN:
      case CHTLJavaScriptParser::UNDEFINED:
      case CHTLJavaScriptParser::LPAREN:
      case CHTLJavaScriptParser::LBRACE:
      case CHTLJavaScriptParser::LBRACKET:
      case CHTLJavaScriptParser::ELLIPSIS:
      case CHTLJavaScriptParser::PLUSPLUS:
      case CHTLJavaScriptParser::MINUSMINUS:
      case CHTLJavaScriptParser::PLUS:
      case CHTLJavaScriptParser::MINUS:
      case CHTLJavaScriptParser::TILDE:
      case CHTLJavaScriptParser::EXCLAMATION:
      case CHTLJavaScriptParser::NUMBER:
      case CHTLJavaScriptParser::STRING: {
        enterOuterAlt(_localctx, 1);
        setState(967);
        _errHandler->sync(this);

        _la = _input->LA(1);
        if (_la == CHTLJavaScriptParser::ELLIPSIS) {
          setState(966);
          match(CHTLJavaScriptParser::ELLIPSIS);
        }
        setState(969);
        singleExpression(0);
        break;
      }

      case CHTLJavaScriptParser::COMMA: {
        enterOuterAlt(_localctx, 2);
        setState(970);
        match(CHTLJavaScriptParser::COMMA);
        break;
      }

    default:
      throw NoViableAltException(this);
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- ObjectLiteralContext ------------------------------------------------------------------

CHTLJavaScriptParser::ObjectLiteralContext::ObjectLiteralContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* CHTLJavaScriptParser::ObjectLiteralContext::LBRACE() {
  return getToken(CHTLJavaScriptParser::LBRACE, 0);
}

std::vector<CHTLJavaScriptParser::PropertyAssignmentContext *> CHTLJavaScriptParser::ObjectLiteralContext::propertyAssignment() {
  return getRuleContexts<CHTLJavaScriptParser::PropertyAssignmentContext>();
}

CHTLJavaScriptParser::PropertyAssignmentContext* CHTLJavaScriptParser::ObjectLiteralContext::propertyAssignment(size_t i) {
  return getRuleContext<CHTLJavaScriptParser::PropertyAssignmentContext>(i);
}

tree::TerminalNode* CHTLJavaScriptParser::ObjectLiteralContext::RBRACE() {
  return getToken(CHTLJavaScriptParser::RBRACE, 0);
}

std::vector<tree::TerminalNode *> CHTLJavaScriptParser::ObjectLiteralContext::COMMA() {
  return getTokens(CHTLJavaScriptParser::COMMA);
}

tree::TerminalNode* CHTLJavaScriptParser::ObjectLiteralContext::COMMA(size_t i) {
  return getToken(CHTLJavaScriptParser::COMMA, i);
}


size_t CHTLJavaScriptParser::ObjectLiteralContext::getRuleIndex() const {
  return CHTLJavaScriptParser::RuleObjectLiteral;
}


std::any CHTLJavaScriptParser::ObjectLiteralContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<CHTLJavaScriptVisitor*>(visitor))
    return parserVisitor->visitObjectLiteral(this);
  else
    return visitor->visitChildren(this);
}

CHTLJavaScriptParser::ObjectLiteralContext* CHTLJavaScriptParser::objectLiteral() {
  ObjectLiteralContext *_localctx = _tracker.createInstance<ObjectLiteralContext>(_ctx, getState());
  enterRule(_localctx, 148, CHTLJavaScriptParser::RuleObjectLiteral);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    size_t alt;
    enterOuterAlt(_localctx, 1);
    setState(973);
    match(CHTLJavaScriptParser::LBRACE);
    setState(974);
    propertyAssignment();
    setState(979);
    _errHandler->sync(this);
    alt = getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 84, _ctx);
    while (alt != 2 && alt != atn::ATN::INVALID_ALT_NUMBER) {
      if (alt == 1) {
        setState(975);
        match(CHTLJavaScriptParser::COMMA);
        setState(976);
        propertyAssignment(); 
      }
      setState(981);
      _errHandler->sync(this);
      alt = getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 84, _ctx);
    }
    setState(983);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (_la == CHTLJavaScriptParser::COMMA) {
      setState(982);
      match(CHTLJavaScriptParser::COMMA);
    }
    setState(985);
    match(CHTLJavaScriptParser::RBRACE);
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- PropertyAssignmentContext ------------------------------------------------------------------

CHTLJavaScriptParser::PropertyAssignmentContext::PropertyAssignmentContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

CHTLJavaScriptParser::PropertyNameContext* CHTLJavaScriptParser::PropertyAssignmentContext::propertyName() {
  return getRuleContext<CHTLJavaScriptParser::PropertyNameContext>(0);
}

tree::TerminalNode* CHTLJavaScriptParser::PropertyAssignmentContext::COLON() {
  return getToken(CHTLJavaScriptParser::COLON, 0);
}

std::vector<CHTLJavaScriptParser::SingleExpressionContext *> CHTLJavaScriptParser::PropertyAssignmentContext::singleExpression() {
  return getRuleContexts<CHTLJavaScriptParser::SingleExpressionContext>();
}

CHTLJavaScriptParser::SingleExpressionContext* CHTLJavaScriptParser::PropertyAssignmentContext::singleExpression(size_t i) {
  return getRuleContext<CHTLJavaScriptParser::SingleExpressionContext>(i);
}

tree::TerminalNode* CHTLJavaScriptParser::PropertyAssignmentContext::LBRACKET() {
  return getToken(CHTLJavaScriptParser::LBRACKET, 0);
}

tree::TerminalNode* CHTLJavaScriptParser::PropertyAssignmentContext::RBRACKET() {
  return getToken(CHTLJavaScriptParser::RBRACKET, 0);
}

CHTLJavaScriptParser::MethodDefinitionContext* CHTLJavaScriptParser::PropertyAssignmentContext::methodDefinition() {
  return getRuleContext<CHTLJavaScriptParser::MethodDefinitionContext>(0);
}

tree::TerminalNode* CHTLJavaScriptParser::PropertyAssignmentContext::IDENTIFIER() {
  return getToken(CHTLJavaScriptParser::IDENTIFIER, 0);
}

tree::TerminalNode* CHTLJavaScriptParser::PropertyAssignmentContext::ELLIPSIS() {
  return getToken(CHTLJavaScriptParser::ELLIPSIS, 0);
}


size_t CHTLJavaScriptParser::PropertyAssignmentContext::getRuleIndex() const {
  return CHTLJavaScriptParser::RulePropertyAssignment;
}


std::any CHTLJavaScriptParser::PropertyAssignmentContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<CHTLJavaScriptVisitor*>(visitor))
    return parserVisitor->visitPropertyAssignment(this);
  else
    return visitor->visitChildren(this);
}

CHTLJavaScriptParser::PropertyAssignmentContext* CHTLJavaScriptParser::propertyAssignment() {
  PropertyAssignmentContext *_localctx = _tracker.createInstance<PropertyAssignmentContext>(_ctx, getState());
  enterRule(_localctx, 150, CHTLJavaScriptParser::RulePropertyAssignment);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    setState(1001);
    _errHandler->sync(this);
    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 86, _ctx)) {
    case 1: {
      enterOuterAlt(_localctx, 1);
      setState(987);
      propertyName();
      setState(988);
      match(CHTLJavaScriptParser::COLON);
      setState(989);
      singleExpression(0);
      break;
    }

    case 2: {
      enterOuterAlt(_localctx, 2);
      setState(991);
      match(CHTLJavaScriptParser::LBRACKET);
      setState(992);
      singleExpression(0);
      setState(993);
      match(CHTLJavaScriptParser::RBRACKET);
      setState(994);
      match(CHTLJavaScriptParser::COLON);
      setState(995);
      singleExpression(0);
      break;
    }

    case 3: {
      enterOuterAlt(_localctx, 3);
      setState(997);
      methodDefinition();
      break;
    }

    case 4: {
      enterOuterAlt(_localctx, 4);
      setState(998);
      match(CHTLJavaScriptParser::IDENTIFIER);
      break;
    }

    case 5: {
      enterOuterAlt(_localctx, 5);
      setState(999);
      match(CHTLJavaScriptParser::ELLIPSIS);
      setState(1000);
      singleExpression(0);
      break;
    }

    default:
      break;
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- ArgumentsContext ------------------------------------------------------------------

CHTLJavaScriptParser::ArgumentsContext::ArgumentsContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* CHTLJavaScriptParser::ArgumentsContext::LPAREN() {
  return getToken(CHTLJavaScriptParser::LPAREN, 0);
}

tree::TerminalNode* CHTLJavaScriptParser::ArgumentsContext::RPAREN() {
  return getToken(CHTLJavaScriptParser::RPAREN, 0);
}

CHTLJavaScriptParser::ArgumentListContext* CHTLJavaScriptParser::ArgumentsContext::argumentList() {
  return getRuleContext<CHTLJavaScriptParser::ArgumentListContext>(0);
}


size_t CHTLJavaScriptParser::ArgumentsContext::getRuleIndex() const {
  return CHTLJavaScriptParser::RuleArguments;
}


std::any CHTLJavaScriptParser::ArgumentsContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<CHTLJavaScriptVisitor*>(visitor))
    return parserVisitor->visitArguments(this);
  else
    return visitor->visitChildren(this);
}

CHTLJavaScriptParser::ArgumentsContext* CHTLJavaScriptParser::arguments() {
  ArgumentsContext *_localctx = _tracker.createInstance<ArgumentsContext>(_ctx, getState());
  enterRule(_localctx, 152, CHTLJavaScriptParser::RuleArguments);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(1003);
    match(CHTLJavaScriptParser::LPAREN);
    setState(1005);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if ((((_la & ~ 0x3fULL) == 0) &&
      ((1ULL << _la) & 3532001068879709188) != 0) || ((((_la - 70) & ~ 0x3fULL) == 0) &&
      ((1ULL << (_la - 70)) & 720576008025030831) != 0)) {
      setState(1004);
      argumentList();
    }
    setState(1007);
    match(CHTLJavaScriptParser::RPAREN);
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- ArgumentListContext ------------------------------------------------------------------

CHTLJavaScriptParser::ArgumentListContext::ArgumentListContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

std::vector<CHTLJavaScriptParser::ArgumentContext *> CHTLJavaScriptParser::ArgumentListContext::argument() {
  return getRuleContexts<CHTLJavaScriptParser::ArgumentContext>();
}

CHTLJavaScriptParser::ArgumentContext* CHTLJavaScriptParser::ArgumentListContext::argument(size_t i) {
  return getRuleContext<CHTLJavaScriptParser::ArgumentContext>(i);
}

std::vector<tree::TerminalNode *> CHTLJavaScriptParser::ArgumentListContext::COMMA() {
  return getTokens(CHTLJavaScriptParser::COMMA);
}

tree::TerminalNode* CHTLJavaScriptParser::ArgumentListContext::COMMA(size_t i) {
  return getToken(CHTLJavaScriptParser::COMMA, i);
}


size_t CHTLJavaScriptParser::ArgumentListContext::getRuleIndex() const {
  return CHTLJavaScriptParser::RuleArgumentList;
}


std::any CHTLJavaScriptParser::ArgumentListContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<CHTLJavaScriptVisitor*>(visitor))
    return parserVisitor->visitArgumentList(this);
  else
    return visitor->visitChildren(this);
}

CHTLJavaScriptParser::ArgumentListContext* CHTLJavaScriptParser::argumentList() {
  ArgumentListContext *_localctx = _tracker.createInstance<ArgumentListContext>(_ctx, getState());
  enterRule(_localctx, 154, CHTLJavaScriptParser::RuleArgumentList);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(1009);
    argument();
    setState(1014);
    _errHandler->sync(this);
    _la = _input->LA(1);
    while (_la == CHTLJavaScriptParser::COMMA) {
      setState(1010);
      match(CHTLJavaScriptParser::COMMA);
      setState(1011);
      argument();
      setState(1016);
      _errHandler->sync(this);
      _la = _input->LA(1);
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- ArgumentContext ------------------------------------------------------------------

CHTLJavaScriptParser::ArgumentContext::ArgumentContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

CHTLJavaScriptParser::SingleExpressionContext* CHTLJavaScriptParser::ArgumentContext::singleExpression() {
  return getRuleContext<CHTLJavaScriptParser::SingleExpressionContext>(0);
}

tree::TerminalNode* CHTLJavaScriptParser::ArgumentContext::ELLIPSIS() {
  return getToken(CHTLJavaScriptParser::ELLIPSIS, 0);
}


size_t CHTLJavaScriptParser::ArgumentContext::getRuleIndex() const {
  return CHTLJavaScriptParser::RuleArgument;
}


std::any CHTLJavaScriptParser::ArgumentContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<CHTLJavaScriptVisitor*>(visitor))
    return parserVisitor->visitArgument(this);
  else
    return visitor->visitChildren(this);
}

CHTLJavaScriptParser::ArgumentContext* CHTLJavaScriptParser::argument() {
  ArgumentContext *_localctx = _tracker.createInstance<ArgumentContext>(_ctx, getState());
  enterRule(_localctx, 156, CHTLJavaScriptParser::RuleArgument);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(1018);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (_la == CHTLJavaScriptParser::ELLIPSIS) {
      setState(1017);
      match(CHTLJavaScriptParser::ELLIPSIS);
    }
    setState(1020);
    singleExpression(0);
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- AnonymousFunctionContext ------------------------------------------------------------------

CHTLJavaScriptParser::AnonymousFunctionContext::AnonymousFunctionContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* CHTLJavaScriptParser::AnonymousFunctionContext::FUNCTION() {
  return getToken(CHTLJavaScriptParser::FUNCTION, 0);
}

tree::TerminalNode* CHTLJavaScriptParser::AnonymousFunctionContext::LPAREN() {
  return getToken(CHTLJavaScriptParser::LPAREN, 0);
}

tree::TerminalNode* CHTLJavaScriptParser::AnonymousFunctionContext::RPAREN() {
  return getToken(CHTLJavaScriptParser::RPAREN, 0);
}

CHTLJavaScriptParser::BlockContext* CHTLJavaScriptParser::AnonymousFunctionContext::block() {
  return getRuleContext<CHTLJavaScriptParser::BlockContext>(0);
}

tree::TerminalNode* CHTLJavaScriptParser::AnonymousFunctionContext::ASYNC() {
  return getToken(CHTLJavaScriptParser::ASYNC, 0);
}

tree::TerminalNode* CHTLJavaScriptParser::AnonymousFunctionContext::STAR() {
  return getToken(CHTLJavaScriptParser::STAR, 0);
}

CHTLJavaScriptParser::FormalParameterListContext* CHTLJavaScriptParser::AnonymousFunctionContext::formalParameterList() {
  return getRuleContext<CHTLJavaScriptParser::FormalParameterListContext>(0);
}


size_t CHTLJavaScriptParser::AnonymousFunctionContext::getRuleIndex() const {
  return CHTLJavaScriptParser::RuleAnonymousFunction;
}


std::any CHTLJavaScriptParser::AnonymousFunctionContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<CHTLJavaScriptVisitor*>(visitor))
    return parserVisitor->visitAnonymousFunction(this);
  else
    return visitor->visitChildren(this);
}

CHTLJavaScriptParser::AnonymousFunctionContext* CHTLJavaScriptParser::anonymousFunction() {
  AnonymousFunctionContext *_localctx = _tracker.createInstance<AnonymousFunctionContext>(_ctx, getState());
  enterRule(_localctx, 158, CHTLJavaScriptParser::RuleAnonymousFunction);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(1023);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (_la == CHTLJavaScriptParser::ASYNC) {
      setState(1022);
      match(CHTLJavaScriptParser::ASYNC);
    }
    setState(1025);
    match(CHTLJavaScriptParser::FUNCTION);
    setState(1027);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (_la == CHTLJavaScriptParser::STAR) {
      setState(1026);
      match(CHTLJavaScriptParser::STAR);
    }
    setState(1029);
    match(CHTLJavaScriptParser::LPAREN);
    setState(1031);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (((((_la - 23) & ~ 0x3fULL) == 0) &&
      ((1ULL << (_la - 23)) & 2328361007350546433) != 0)) {
      setState(1030);
      formalParameterList();
    }
    setState(1033);
    match(CHTLJavaScriptParser::RPAREN);
    setState(1034);
    block();
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- ArrowFunctionContext ------------------------------------------------------------------

CHTLJavaScriptParser::ArrowFunctionContext::ArrowFunctionContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

CHTLJavaScriptParser::ArrowFunctionParametersContext* CHTLJavaScriptParser::ArrowFunctionContext::arrowFunctionParameters() {
  return getRuleContext<CHTLJavaScriptParser::ArrowFunctionParametersContext>(0);
}

tree::TerminalNode* CHTLJavaScriptParser::ArrowFunctionContext::ARROW() {
  return getToken(CHTLJavaScriptParser::ARROW, 0);
}

CHTLJavaScriptParser::ArrowFunctionBodyContext* CHTLJavaScriptParser::ArrowFunctionContext::arrowFunctionBody() {
  return getRuleContext<CHTLJavaScriptParser::ArrowFunctionBodyContext>(0);
}

tree::TerminalNode* CHTLJavaScriptParser::ArrowFunctionContext::ASYNC() {
  return getToken(CHTLJavaScriptParser::ASYNC, 0);
}


size_t CHTLJavaScriptParser::ArrowFunctionContext::getRuleIndex() const {
  return CHTLJavaScriptParser::RuleArrowFunction;
}


std::any CHTLJavaScriptParser::ArrowFunctionContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<CHTLJavaScriptVisitor*>(visitor))
    return parserVisitor->visitArrowFunction(this);
  else
    return visitor->visitChildren(this);
}

CHTLJavaScriptParser::ArrowFunctionContext* CHTLJavaScriptParser::arrowFunction() {
  ArrowFunctionContext *_localctx = _tracker.createInstance<ArrowFunctionContext>(_ctx, getState());
  enterRule(_localctx, 160, CHTLJavaScriptParser::RuleArrowFunction);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(1037);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (_la == CHTLJavaScriptParser::ASYNC) {
      setState(1036);
      match(CHTLJavaScriptParser::ASYNC);
    }
    setState(1039);
    arrowFunctionParameters();
    setState(1040);
    match(CHTLJavaScriptParser::ARROW);
    setState(1041);
    arrowFunctionBody();
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- ArrowFunctionParametersContext ------------------------------------------------------------------

CHTLJavaScriptParser::ArrowFunctionParametersContext::ArrowFunctionParametersContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* CHTLJavaScriptParser::ArrowFunctionParametersContext::IDENTIFIER() {
  return getToken(CHTLJavaScriptParser::IDENTIFIER, 0);
}

tree::TerminalNode* CHTLJavaScriptParser::ArrowFunctionParametersContext::LPAREN() {
  return getToken(CHTLJavaScriptParser::LPAREN, 0);
}

tree::TerminalNode* CHTLJavaScriptParser::ArrowFunctionParametersContext::RPAREN() {
  return getToken(CHTLJavaScriptParser::RPAREN, 0);
}

CHTLJavaScriptParser::FormalParameterListContext* CHTLJavaScriptParser::ArrowFunctionParametersContext::formalParameterList() {
  return getRuleContext<CHTLJavaScriptParser::FormalParameterListContext>(0);
}


size_t CHTLJavaScriptParser::ArrowFunctionParametersContext::getRuleIndex() const {
  return CHTLJavaScriptParser::RuleArrowFunctionParameters;
}


std::any CHTLJavaScriptParser::ArrowFunctionParametersContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<CHTLJavaScriptVisitor*>(visitor))
    return parserVisitor->visitArrowFunctionParameters(this);
  else
    return visitor->visitChildren(this);
}

CHTLJavaScriptParser::ArrowFunctionParametersContext* CHTLJavaScriptParser::arrowFunctionParameters() {
  ArrowFunctionParametersContext *_localctx = _tracker.createInstance<ArrowFunctionParametersContext>(_ctx, getState());
  enterRule(_localctx, 162, CHTLJavaScriptParser::RuleArrowFunctionParameters);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    setState(1049);
    _errHandler->sync(this);
    switch (_input->LA(1)) {
      case CHTLJavaScriptParser::IDENTIFIER: {
        enterOuterAlt(_localctx, 1);
        setState(1043);
        match(CHTLJavaScriptParser::IDENTIFIER);
        break;
      }

      case CHTLJavaScriptParser::LPAREN: {
        enterOuterAlt(_localctx, 2);
        setState(1044);
        match(CHTLJavaScriptParser::LPAREN);
        setState(1046);
        _errHandler->sync(this);

        _la = _input->LA(1);
        if (((((_la - 23) & ~ 0x3fULL) == 0) &&
          ((1ULL << (_la - 23)) & 2328361007350546433) != 0)) {
          setState(1045);
          formalParameterList();
        }
        setState(1048);
        match(CHTLJavaScriptParser::RPAREN);
        break;
      }

    default:
      throw NoViableAltException(this);
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- ArrowFunctionBodyContext ------------------------------------------------------------------

CHTLJavaScriptParser::ArrowFunctionBodyContext::ArrowFunctionBodyContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

CHTLJavaScriptParser::SingleExpressionContext* CHTLJavaScriptParser::ArrowFunctionBodyContext::singleExpression() {
  return getRuleContext<CHTLJavaScriptParser::SingleExpressionContext>(0);
}

CHTLJavaScriptParser::BlockContext* CHTLJavaScriptParser::ArrowFunctionBodyContext::block() {
  return getRuleContext<CHTLJavaScriptParser::BlockContext>(0);
}


size_t CHTLJavaScriptParser::ArrowFunctionBodyContext::getRuleIndex() const {
  return CHTLJavaScriptParser::RuleArrowFunctionBody;
}


std::any CHTLJavaScriptParser::ArrowFunctionBodyContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<CHTLJavaScriptVisitor*>(visitor))
    return parserVisitor->visitArrowFunctionBody(this);
  else
    return visitor->visitChildren(this);
}

CHTLJavaScriptParser::ArrowFunctionBodyContext* CHTLJavaScriptParser::arrowFunctionBody() {
  ArrowFunctionBodyContext *_localctx = _tracker.createInstance<ArrowFunctionBodyContext>(_ctx, getState());
  enterRule(_localctx, 164, CHTLJavaScriptParser::RuleArrowFunctionBody);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    setState(1053);
    _errHandler->sync(this);
    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 96, _ctx)) {
    case 1: {
      enterOuterAlt(_localctx, 1);
      setState(1051);
      singleExpression(0);
      break;
    }

    case 2: {
      enterOuterAlt(_localctx, 2);
      setState(1052);
      block();
      break;
    }

    default:
      break;
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- TypeofExpressionContext ------------------------------------------------------------------

CHTLJavaScriptParser::TypeofExpressionContext::TypeofExpressionContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* CHTLJavaScriptParser::TypeofExpressionContext::TYPEOF() {
  return getToken(CHTLJavaScriptParser::TYPEOF, 0);
}

CHTLJavaScriptParser::SingleExpressionContext* CHTLJavaScriptParser::TypeofExpressionContext::singleExpression() {
  return getRuleContext<CHTLJavaScriptParser::SingleExpressionContext>(0);
}


size_t CHTLJavaScriptParser::TypeofExpressionContext::getRuleIndex() const {
  return CHTLJavaScriptParser::RuleTypeofExpression;
}


std::any CHTLJavaScriptParser::TypeofExpressionContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<CHTLJavaScriptVisitor*>(visitor))
    return parserVisitor->visitTypeofExpression(this);
  else
    return visitor->visitChildren(this);
}

CHTLJavaScriptParser::TypeofExpressionContext* CHTLJavaScriptParser::typeofExpression() {
  TypeofExpressionContext *_localctx = _tracker.createInstance<TypeofExpressionContext>(_ctx, getState());
  enterRule(_localctx, 166, CHTLJavaScriptParser::RuleTypeofExpression);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(1055);
    match(CHTLJavaScriptParser::TYPEOF);
    setState(1056);
    singleExpression(0);
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- IdentifierNameContext ------------------------------------------------------------------

CHTLJavaScriptParser::IdentifierNameContext::IdentifierNameContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* CHTLJavaScriptParser::IdentifierNameContext::IDENTIFIER() {
  return getToken(CHTLJavaScriptParser::IDENTIFIER, 0);
}

CHTLJavaScriptParser::ReservedWordContext* CHTLJavaScriptParser::IdentifierNameContext::reservedWord() {
  return getRuleContext<CHTLJavaScriptParser::ReservedWordContext>(0);
}


size_t CHTLJavaScriptParser::IdentifierNameContext::getRuleIndex() const {
  return CHTLJavaScriptParser::RuleIdentifierName;
}


std::any CHTLJavaScriptParser::IdentifierNameContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<CHTLJavaScriptVisitor*>(visitor))
    return parserVisitor->visitIdentifierName(this);
  else
    return visitor->visitChildren(this);
}

CHTLJavaScriptParser::IdentifierNameContext* CHTLJavaScriptParser::identifierName() {
  IdentifierNameContext *_localctx = _tracker.createInstance<IdentifierNameContext>(_ctx, getState());
  enterRule(_localctx, 168, CHTLJavaScriptParser::RuleIdentifierName);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    setState(1060);
    _errHandler->sync(this);
    switch (_input->LA(1)) {
      case CHTLJavaScriptParser::IDENTIFIER: {
        enterOuterAlt(_localctx, 1);
        setState(1058);
        match(CHTLJavaScriptParser::IDENTIFIER);
        break;
      }

      case CHTLJavaScriptParser::BREAK:
      case CHTLJavaScriptParser::DO:
      case CHTLJavaScriptParser::INSTANCEOF:
      case CHTLJavaScriptParser::TYPEOF:
      case CHTLJavaScriptParser::CASE:
      case CHTLJavaScriptParser::ELSE:
      case CHTLJavaScriptParser::NEW:
      case CHTLJavaScriptParser::VAR:
      case CHTLJavaScriptParser::CATCH:
      case CHTLJavaScriptParser::FINALLY:
      case CHTLJavaScriptParser::RETURN:
      case CHTLJavaScriptParser::VOID:
      case CHTLJavaScriptParser::CONTINUE:
      case CHTLJavaScriptParser::FOR:
      case CHTLJavaScriptParser::SWITCH:
      case CHTLJavaScriptParser::WHILE:
      case CHTLJavaScriptParser::DEBUGGER:
      case CHTLJavaScriptParser::FUNCTION:
      case CHTLJavaScriptParser::THIS:
      case CHTLJavaScriptParser::WITH:
      case CHTLJavaScriptParser::DEFAULT:
      case CHTLJavaScriptParser::IF:
      case CHTLJavaScriptParser::THROW:
      case CHTLJavaScriptParser::DELETE:
      case CHTLJavaScriptParser::IN:
      case CHTLJavaScriptParser::TRY:
      case CHTLJavaScriptParser::CLASS:
      case CHTLJavaScriptParser::ENUM:
      case CHTLJavaScriptParser::EXTENDS:
      case CHTLJavaScriptParser::SUPER:
      case CHTLJavaScriptParser::CONST:
      case CHTLJavaScriptParser::EXPORT:
      case CHTLJavaScriptParser::IMPORT:
      case CHTLJavaScriptParser::ASYNC:
      case CHTLJavaScriptParser::AWAIT:
      case CHTLJavaScriptParser::YIELD:
      case CHTLJavaScriptParser::LET:
      case CHTLJavaScriptParser::STATIC:
      case CHTLJavaScriptParser::FROM:
      case CHTLJavaScriptParser::AS:
      case CHTLJavaScriptParser::OF:
      case CHTLJavaScriptParser::NULL_:
      case CHTLJavaScriptParser::BOOLEAN: {
        enterOuterAlt(_localctx, 2);
        setState(1059);
        reservedWord();
        break;
      }

    default:
      throw NoViableAltException(this);
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- ReservedWordContext ------------------------------------------------------------------

CHTLJavaScriptParser::ReservedWordContext::ReservedWordContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

CHTLJavaScriptParser::KeywordContext* CHTLJavaScriptParser::ReservedWordContext::keyword() {
  return getRuleContext<CHTLJavaScriptParser::KeywordContext>(0);
}

tree::TerminalNode* CHTLJavaScriptParser::ReservedWordContext::NULL_() {
  return getToken(CHTLJavaScriptParser::NULL_, 0);
}

tree::TerminalNode* CHTLJavaScriptParser::ReservedWordContext::BOOLEAN() {
  return getToken(CHTLJavaScriptParser::BOOLEAN, 0);
}


size_t CHTLJavaScriptParser::ReservedWordContext::getRuleIndex() const {
  return CHTLJavaScriptParser::RuleReservedWord;
}


std::any CHTLJavaScriptParser::ReservedWordContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<CHTLJavaScriptVisitor*>(visitor))
    return parserVisitor->visitReservedWord(this);
  else
    return visitor->visitChildren(this);
}

CHTLJavaScriptParser::ReservedWordContext* CHTLJavaScriptParser::reservedWord() {
  ReservedWordContext *_localctx = _tracker.createInstance<ReservedWordContext>(_ctx, getState());
  enterRule(_localctx, 170, CHTLJavaScriptParser::RuleReservedWord);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    setState(1065);
    _errHandler->sync(this);
    switch (_input->LA(1)) {
      case CHTLJavaScriptParser::BREAK:
      case CHTLJavaScriptParser::DO:
      case CHTLJavaScriptParser::INSTANCEOF:
      case CHTLJavaScriptParser::TYPEOF:
      case CHTLJavaScriptParser::CASE:
      case CHTLJavaScriptParser::ELSE:
      case CHTLJavaScriptParser::NEW:
      case CHTLJavaScriptParser::VAR:
      case CHTLJavaScriptParser::CATCH:
      case CHTLJavaScriptParser::FINALLY:
      case CHTLJavaScriptParser::RETURN:
      case CHTLJavaScriptParser::VOID:
      case CHTLJavaScriptParser::CONTINUE:
      case CHTLJavaScriptParser::FOR:
      case CHTLJavaScriptParser::SWITCH:
      case CHTLJavaScriptParser::WHILE:
      case CHTLJavaScriptParser::DEBUGGER:
      case CHTLJavaScriptParser::FUNCTION:
      case CHTLJavaScriptParser::THIS:
      case CHTLJavaScriptParser::WITH:
      case CHTLJavaScriptParser::DEFAULT:
      case CHTLJavaScriptParser::IF:
      case CHTLJavaScriptParser::THROW:
      case CHTLJavaScriptParser::DELETE:
      case CHTLJavaScriptParser::IN:
      case CHTLJavaScriptParser::TRY:
      case CHTLJavaScriptParser::CLASS:
      case CHTLJavaScriptParser::ENUM:
      case CHTLJavaScriptParser::EXTENDS:
      case CHTLJavaScriptParser::SUPER:
      case CHTLJavaScriptParser::CONST:
      case CHTLJavaScriptParser::EXPORT:
      case CHTLJavaScriptParser::IMPORT:
      case CHTLJavaScriptParser::ASYNC:
      case CHTLJavaScriptParser::AWAIT:
      case CHTLJavaScriptParser::YIELD:
      case CHTLJavaScriptParser::LET:
      case CHTLJavaScriptParser::STATIC:
      case CHTLJavaScriptParser::FROM:
      case CHTLJavaScriptParser::AS:
      case CHTLJavaScriptParser::OF: {
        enterOuterAlt(_localctx, 1);
        setState(1062);
        keyword();
        break;
      }

      case CHTLJavaScriptParser::NULL_: {
        enterOuterAlt(_localctx, 2);
        setState(1063);
        match(CHTLJavaScriptParser::NULL_);
        break;
      }

      case CHTLJavaScriptParser::BOOLEAN: {
        enterOuterAlt(_localctx, 3);
        setState(1064);
        match(CHTLJavaScriptParser::BOOLEAN);
        break;
      }

    default:
      throw NoViableAltException(this);
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- KeywordContext ------------------------------------------------------------------

CHTLJavaScriptParser::KeywordContext::KeywordContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* CHTLJavaScriptParser::KeywordContext::BREAK() {
  return getToken(CHTLJavaScriptParser::BREAK, 0);
}

tree::TerminalNode* CHTLJavaScriptParser::KeywordContext::DO() {
  return getToken(CHTLJavaScriptParser::DO, 0);
}

tree::TerminalNode* CHTLJavaScriptParser::KeywordContext::INSTANCEOF() {
  return getToken(CHTLJavaScriptParser::INSTANCEOF, 0);
}

tree::TerminalNode* CHTLJavaScriptParser::KeywordContext::TYPEOF() {
  return getToken(CHTLJavaScriptParser::TYPEOF, 0);
}

tree::TerminalNode* CHTLJavaScriptParser::KeywordContext::CASE() {
  return getToken(CHTLJavaScriptParser::CASE, 0);
}

tree::TerminalNode* CHTLJavaScriptParser::KeywordContext::ELSE() {
  return getToken(CHTLJavaScriptParser::ELSE, 0);
}

tree::TerminalNode* CHTLJavaScriptParser::KeywordContext::NEW() {
  return getToken(CHTLJavaScriptParser::NEW, 0);
}

tree::TerminalNode* CHTLJavaScriptParser::KeywordContext::VAR() {
  return getToken(CHTLJavaScriptParser::VAR, 0);
}

tree::TerminalNode* CHTLJavaScriptParser::KeywordContext::CATCH() {
  return getToken(CHTLJavaScriptParser::CATCH, 0);
}

tree::TerminalNode* CHTLJavaScriptParser::KeywordContext::FINALLY() {
  return getToken(CHTLJavaScriptParser::FINALLY, 0);
}

tree::TerminalNode* CHTLJavaScriptParser::KeywordContext::RETURN() {
  return getToken(CHTLJavaScriptParser::RETURN, 0);
}

tree::TerminalNode* CHTLJavaScriptParser::KeywordContext::VOID() {
  return getToken(CHTLJavaScriptParser::VOID, 0);
}

tree::TerminalNode* CHTLJavaScriptParser::KeywordContext::CONTINUE() {
  return getToken(CHTLJavaScriptParser::CONTINUE, 0);
}

tree::TerminalNode* CHTLJavaScriptParser::KeywordContext::FOR() {
  return getToken(CHTLJavaScriptParser::FOR, 0);
}

tree::TerminalNode* CHTLJavaScriptParser::KeywordContext::SWITCH() {
  return getToken(CHTLJavaScriptParser::SWITCH, 0);
}

tree::TerminalNode* CHTLJavaScriptParser::KeywordContext::WHILE() {
  return getToken(CHTLJavaScriptParser::WHILE, 0);
}

tree::TerminalNode* CHTLJavaScriptParser::KeywordContext::DEBUGGER() {
  return getToken(CHTLJavaScriptParser::DEBUGGER, 0);
}

tree::TerminalNode* CHTLJavaScriptParser::KeywordContext::FUNCTION() {
  return getToken(CHTLJavaScriptParser::FUNCTION, 0);
}

tree::TerminalNode* CHTLJavaScriptParser::KeywordContext::THIS() {
  return getToken(CHTLJavaScriptParser::THIS, 0);
}

tree::TerminalNode* CHTLJavaScriptParser::KeywordContext::WITH() {
  return getToken(CHTLJavaScriptParser::WITH, 0);
}

tree::TerminalNode* CHTLJavaScriptParser::KeywordContext::DEFAULT() {
  return getToken(CHTLJavaScriptParser::DEFAULT, 0);
}

tree::TerminalNode* CHTLJavaScriptParser::KeywordContext::IF() {
  return getToken(CHTLJavaScriptParser::IF, 0);
}

tree::TerminalNode* CHTLJavaScriptParser::KeywordContext::THROW() {
  return getToken(CHTLJavaScriptParser::THROW, 0);
}

tree::TerminalNode* CHTLJavaScriptParser::KeywordContext::DELETE() {
  return getToken(CHTLJavaScriptParser::DELETE, 0);
}

tree::TerminalNode* CHTLJavaScriptParser::KeywordContext::IN() {
  return getToken(CHTLJavaScriptParser::IN, 0);
}

tree::TerminalNode* CHTLJavaScriptParser::KeywordContext::TRY() {
  return getToken(CHTLJavaScriptParser::TRY, 0);
}

tree::TerminalNode* CHTLJavaScriptParser::KeywordContext::CLASS() {
  return getToken(CHTLJavaScriptParser::CLASS, 0);
}

tree::TerminalNode* CHTLJavaScriptParser::KeywordContext::ENUM() {
  return getToken(CHTLJavaScriptParser::ENUM, 0);
}

tree::TerminalNode* CHTLJavaScriptParser::KeywordContext::EXTENDS() {
  return getToken(CHTLJavaScriptParser::EXTENDS, 0);
}

tree::TerminalNode* CHTLJavaScriptParser::KeywordContext::SUPER() {
  return getToken(CHTLJavaScriptParser::SUPER, 0);
}

tree::TerminalNode* CHTLJavaScriptParser::KeywordContext::CONST() {
  return getToken(CHTLJavaScriptParser::CONST, 0);
}

tree::TerminalNode* CHTLJavaScriptParser::KeywordContext::EXPORT() {
  return getToken(CHTLJavaScriptParser::EXPORT, 0);
}

tree::TerminalNode* CHTLJavaScriptParser::KeywordContext::IMPORT() {
  return getToken(CHTLJavaScriptParser::IMPORT, 0);
}

tree::TerminalNode* CHTLJavaScriptParser::KeywordContext::ASYNC() {
  return getToken(CHTLJavaScriptParser::ASYNC, 0);
}

tree::TerminalNode* CHTLJavaScriptParser::KeywordContext::AWAIT() {
  return getToken(CHTLJavaScriptParser::AWAIT, 0);
}

tree::TerminalNode* CHTLJavaScriptParser::KeywordContext::YIELD() {
  return getToken(CHTLJavaScriptParser::YIELD, 0);
}

tree::TerminalNode* CHTLJavaScriptParser::KeywordContext::LET() {
  return getToken(CHTLJavaScriptParser::LET, 0);
}

tree::TerminalNode* CHTLJavaScriptParser::KeywordContext::STATIC() {
  return getToken(CHTLJavaScriptParser::STATIC, 0);
}

tree::TerminalNode* CHTLJavaScriptParser::KeywordContext::FROM() {
  return getToken(CHTLJavaScriptParser::FROM, 0);
}

tree::TerminalNode* CHTLJavaScriptParser::KeywordContext::AS() {
  return getToken(CHTLJavaScriptParser::AS, 0);
}

tree::TerminalNode* CHTLJavaScriptParser::KeywordContext::OF() {
  return getToken(CHTLJavaScriptParser::OF, 0);
}


size_t CHTLJavaScriptParser::KeywordContext::getRuleIndex() const {
  return CHTLJavaScriptParser::RuleKeyword;
}


std::any CHTLJavaScriptParser::KeywordContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<CHTLJavaScriptVisitor*>(visitor))
    return parserVisitor->visitKeyword(this);
  else
    return visitor->visitChildren(this);
}

CHTLJavaScriptParser::KeywordContext* CHTLJavaScriptParser::keyword() {
  KeywordContext *_localctx = _tracker.createInstance<KeywordContext>(_ctx, getState());
  enterRule(_localctx, 172, CHTLJavaScriptParser::RuleKeyword);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(1067);
    _la = _input->LA(1);
    if (!(((((_la - 27) & ~ 0x3fULL) == 0) &&
      ((1ULL << (_la - 27)) & 2199023255551) != 0))) {
    _errHandler->recoverInline(this);
    }
    else {
      _errHandler->reportMatch(this);
      consume();
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

bool CHTLJavaScriptParser::sempred(RuleContext *context, size_t ruleIndex, size_t predicateIndex) {
  switch (ruleIndex) {
    case 0: return singleExpressionSempred(antlrcpp::downCast<SingleExpressionContext *>(context), predicateIndex);

  default:
    break;
  }
  return true;
}

bool CHTLJavaScriptParser::singleExpressionSempred(SingleExpressionContext *_localctx, size_t predicateIndex) {
  switch (predicateIndex) {
    case 0: return precpred(_ctx, 25);
    case 1: return precpred(_ctx, 24);
    case 2: return precpred(_ctx, 23);
    case 3: return precpred(_ctx, 22);
    case 4: return precpred(_ctx, 21);
    case 5: return precpred(_ctx, 20);
    case 6: return precpred(_ctx, 19);
    case 7: return precpred(_ctx, 18);
    case 8: return precpred(_ctx, 17);
    case 9: return precpred(_ctx, 16);
    case 10: return precpred(_ctx, 15);
    case 11: return precpred(_ctx, 14);
    case 12: return precpred(_ctx, 13);
    case 13: return precpred(_ctx, 12);
    case 14: return precpred(_ctx, 11);
    case 15: return precpred(_ctx, 10);
    case 16: return precpred(_ctx, 9);
    case 17: return precpred(_ctx, 48);
    case 18: return precpred(_ctx, 47);
    case 19: return precpred(_ctx, 46);
    case 20: return precpred(_ctx, 45);
    case 21: return precpred(_ctx, 41);
    case 22: return precpred(_ctx, 40);
    case 23: return precpred(_ctx, 39);
    case 24: return precpred(_ctx, 37);
    case 25: return precpred(_ctx, 36);

  default:
    break;
  }
  return true;
}

void CHTLJavaScriptParser::initialize() {
#if ANTLR4_USE_THREAD_LOCAL_CACHE
  chtljavascriptParserInitialize();
#else
  ::antlr4::internal::call_once(chtljavascriptParserOnceFlag, chtljavascriptParserInitialize);
#endif
}
