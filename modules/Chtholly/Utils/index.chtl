// Chtholly.Utils Module
// 实用工具模块 - 提供各种实用的工具函数和组件
// "用心准备的工具，能让每一天都更加美好"

[Info] {
    name: "Chtholly.Utils"
    version: "1.0.0"
    description: "CHTL实用工具模块，提供常用的工具函数和辅助组件"
    author: "CHTL Development Team"
    license: "MIT"
}

// 导入核心模块
Import @Chtl from "Chtholly.Core.*"

// 条件渲染组件
[Custom] @Element If {
    props: {
        condition: boolean
        then: any
        else: any
    }
    
    render: {
        props.condition ? props.then : (props.else || null)
    }
}

// 循环渲染组件
[Custom] @Element For {
    props: {
        each: array | object
        as: string = "item"
        index: string = "index"
        children: function
    }
    
    render: {
        if (Array.isArray(props.each)) {
            props.each.map((item, idx) => {
                props.children({ [props.as]: item, [props.index]: idx })
            })
        } else if (typeof props.each === 'object') {
            Object.entries(props.each).map(([key, value], idx) => {
                props.children({ 
                    [props.as]: value, 
                    key: key, 
                    [props.index]: idx 
                })
            })
        }
    }
}

// 开关组件
[Custom] @Element Switch {
    props: {
        value: any
        cases: object
        default: any
    }
    
    render: {
        props.cases[props.value] || props.default || null
    }
}

// 延迟加载组件
[Custom] @Element Lazy {
    props: {
        load: function           // 加载函数
        fallback: any           // 加载时显示的内容
        delay: number = 200     // 延迟时间
        onError: function       // 错误处理
    }
    
    state: {
        component: null
        loading: boolean = true
        error: null
    }
    
    lifecycle: {
        onMount: () => {
            setTimeout(async () => {
                try {
                    const component = await props.load()
                    this.setState({ component, loading: false })
                } catch (error) {
                    this.setState({ error, loading: false })
                    props.onError?.(error)
                }
            }, props.delay)
        }
    }
    
    render: {
        if (state.loading) {
            props.fallback || div { "加载中..." }
        } else if (state.error) {
            div {
                class: "chtl-error"
                "加载失败: " + state.error.message
            }
        } else {
            state.component
        }
    }
}

// 错误边界组件
[Custom] @Element ErrorBoundary {
    props: {
        fallback: any
        onError: function
    }
    
    state: {
        hasError: boolean = false
        error: null
    }
    
    lifecycle: {
        onError: (error) => {
            this.setState({ hasError: true, error })
            props.onError?.(error)
        }
    }
    
    render: {
        if (state.hasError) {
            props.fallback || div {
                class: "chtl-error-boundary"
                h3 { "出错了！" }
                p { state.error?.message || "未知错误" }
            }
        } else {
            [children]
        }
    }
}

// 门户组件（传送门）
[Custom] @Element Portal {
    props: {
        to: string = "body"      // 目标选择器
        disabled: boolean = false
    }
    
    lifecycle: {
        onMount: () => {
            if (!props.disabled) {
                this.container = document.querySelector(props.to) || document.body
                this.el = document.createElement('div')
                this.el.className = 'chtl-portal'
                this.container.appendChild(this.el)
            }
        }
        
        onUnmount: () => {
            if (this.el && this.container) {
                this.container.removeChild(this.el)
            }
        }
    }
    
    render: {
        if (!props.disabled && this.el) {
            // 将children渲染到portal容器中
            ReactDOM.createPortal([children], this.el)
        } else {
            [children]
        }
    }
}

// 防抖组件
[Custom] @Element Debounced {
    props: {
        delay: number = 300
        onChange: function
        children: function
    }
    
    state: {
        value: any = null
    }
    
    methods: {
        handleChange: (newValue) => {
            clearTimeout(this.timer)
            this.timer = setTimeout(() => {
                this.setState({ value: newValue })
                props.onChange?.(newValue)
            }, props.delay)
        }
    }
    
    render: {
        props.children({
            value: state.value,
            onChange: this.handleChange
        })
    }
}

// 节流组件
[Custom] @Element Throttled {
    props: {
        delay: number = 100
        onTrigger: function
        children: function
    }
    
    state: {
        canTrigger: boolean = true
    }
    
    methods: {
        handleTrigger: (...args) => {
            if (state.canTrigger) {
                this.setState({ canTrigger: false })
                props.onTrigger?.(...args)
                
                setTimeout(() => {
                    this.setState({ canTrigger: true })
                }, props.delay)
            }
        }
    }
    
    render: {
        props.children({
            canTrigger: state.canTrigger,
            trigger: this.handleTrigger
        })
    }
}

// 复制到剪贴板组件
[Custom] @Element CopyToClipboard {
    props: {
        text: string
        onCopy: function
        onError: function
        children: any
    }
    
    methods: {
        copy: async () => {
            try {
                await navigator.clipboard.writeText(props.text)
                props.onCopy?.(props.text)
            } catch (error) {
                props.onError?.(error)
            }
        }
    }
    
    render: {
        div {
            onclick: this.copy
            style: { cursor: "pointer" }
            [children]
        }
    }
}

// 可见性观察组件
[Custom] @Element VisibilityObserver {
    props: {
        threshold: number = 0.1
        rootMargin: string = "0px"
        onVisible: function
        onHidden: function
        once: boolean = false
    }
    
    state: {
        isVisible: boolean = false
    }
    
    lifecycle: {
        onMount: () => {
            this.observer = new IntersectionObserver(
                (entries) => {
                    entries.forEach(entry => {
                        const isVisible = entry.isIntersecting
                        this.setState({ isVisible })
                        
                        if (isVisible) {
                            props.onVisible?.()
                            if (props.once) {
                                this.observer.disconnect()
                            }
                        } else {
                            props.onHidden?.()
                        }
                    })
                },
                {
                    threshold: props.threshold,
                    rootMargin: props.rootMargin
                }
            )
            
            this.observer.observe(this.ref)
        }
        
        onUnmount: () => {
            this.observer?.disconnect()
        }
    }
    
    render: {
        div {
            ref: (el) => this.ref = el
            [children]
        }
    }
}

// 工具样式
[Style] @UtilsStyles {
    .chtl-error {
        color: #FF6B6B;
        padding: 16px;
        background: #FFF0F0;
        border: 1px solid #FFD0D0;
        border-radius: 4px;
    }
    
    .chtl-error-boundary {
        padding: 20px;
        background: #FFF0F0;
        border: 2px solid #FF6B6B;
        border-radius: 8px;
        text-align: center;
    }
    
    .chtl-error-boundary h3 {
        color: #FF6B6B;
        margin-bottom: 10px;
    }
    
    .chtl-portal {
        position: absolute;
        z-index: 9999;
    }
}

// 工具函数集合
[Template] @Function debounce(func, delay) {
    let timeoutId
    return function(...args) {
        clearTimeout(timeoutId)
        timeoutId = setTimeout(() => func.apply(this, args), delay)
    }
}

[Template] @Function throttle(func, delay) {
    let lastCall = 0
    return function(...args) {
        const now = Date.now()
        if (now - lastCall >= delay) {
            lastCall = now
            return func.apply(this, args)
        }
    }
}

[Template] @Function deepClone(obj) {
    if (obj === null || typeof obj !== 'object') return obj
    if (obj instanceof Date) return new Date(obj.getTime())
    if (obj instanceof Array) return obj.map(item => deepClone(item))
    if (obj instanceof Object) {
        const cloned = {}
        for (let key in obj) {
            if (obj.hasOwnProperty(key)) {
                cloned[key] = deepClone(obj[key])
            }
        }
        return cloned
    }
}

[Template] @Function deepMerge(target, ...sources) {
    if (!sources.length) return target
    const source = sources.shift()
    
    if (isObject(target) && isObject(source)) {
        for (const key in source) {
            if (isObject(source[key])) {
                if (!target[key]) Object.assign(target, { [key]: {} })
                deepMerge(target[key], source[key])
            } else {
                Object.assign(target, { [key]: source[key] })
            }
        }
    }
    
    return deepMerge(target, ...sources)
}

[Template] @Function isObject(item) {
    return item && typeof item === 'object' && !Array.isArray(item)
}

[Template] @Function generateId(prefix = 'chtl') {
    return `${prefix}_${Date.now()}_${Math.random().toString(36).substr(2, 9)}`
}

[Template] @Function classNames(...args) {
    // 类名组合工具
    return args.filter(Boolean).flat().join(' ')
}

[Template] @Function range(start, end, step = 1) {
    // 生成数字范围
    const result = []
    for (let i = start; i < end; i += step) {
        result.push(i)
    }
    return result
}

[Template] @Function pipe(...funcs) {
    // 函数管道
    return (value) => funcs.reduce((acc, func) => func(acc), value)
}

[Template] @Function compose(...funcs) {
    // 函数组合
    return (value) => funcs.reduceRight((acc, func) => func(acc), value)
}

[Template] @Function memoize(func) {
    // 函数记忆化
    const cache = new Map()
    return function(...args) {
        const key = JSON.stringify(args)
        if (cache.has(key)) {
            return cache.get(key)
        }
        const result = func.apply(this, args)
        cache.set(key, result)
        return result
    }
}

[Template] @Function retry(func, attempts = 3, delay = 1000) {
    // 重试函数
    return async function(...args) {
        for (let i = 0; i < attempts; i++) {
            try {
                return await func.apply(this, args)
            } catch (error) {
                if (i === attempts - 1) throw error
                await new Promise(resolve => setTimeout(resolve, delay))
            }
        }
    }
}

[Template] @Function formatNumber(num, decimals = 2) {
    // 格式化数字
    return Number(num).toLocaleString('zh-CN', {
        minimumFractionDigits: decimals,
        maximumFractionDigits: decimals
    })
}

[Template] @Function formatBytes(bytes, decimals = 2) {
    // 格式化字节大小
    if (bytes === 0) return '0 Bytes'
    
    const k = 1024
    const dm = decimals < 0 ? 0 : decimals
    const sizes = ['Bytes', 'KB', 'MB', 'GB', 'TB', 'PB']
    
    const i = Math.floor(Math.log(bytes) / Math.log(k))
    
    return parseFloat((bytes / Math.pow(k, i)).toFixed(dm)) + ' ' + sizes[i]
}

// 导出工具模块
[Export] {
    @Element If, For, Switch, Lazy, ErrorBoundary, Portal, 
             Debounced, Throttled, CopyToClipboard, VisibilityObserver
    @Style UtilsStyles
    @Var debounce, throttle, deepClone, deepMerge, isObject, 
         generateId, classNames, range, pipe, compose, memoize, 
         retry, formatNumber, formatBytes
}