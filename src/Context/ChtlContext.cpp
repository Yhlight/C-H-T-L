#include "Context/ChtlContext.h"
#include <iostream>
#include <sstream>
#include <algorithm>
#include <functional>

namespace chtl {

ChtlContext::ChtlContext() 
    : BasicContext(ContextType::CHTL, "ChtlContext") {
    // 创建根命名空间
    rootNamespace_ = std::make_shared<NamespaceInfo>();
    rootNamespace_->name = "root";
    rootNamespace_->fullPath = "";
    currentNamespace_ = rootNamespace_;
}

bool ChtlContext::validate() {
    bool isValid = true;
    
    // 验证所有模板
    for (const auto& [name, info] : templates_) {
        if (!validateTemplate(info)) {
            isValid = false;
        }
    }
    
    // 验证所有自定义
    for (const auto& [name, info] : customs_) {
        if (!validateCustom(info)) {
            isValid = false;
        }
    }
    
    // 验证继承关系
    // TODO: 检查循环继承等问题
    
    return isValid && !hasErrors();
}

void ChtlContext::reset() {
    BasicContext::reset();
    
    // 清空CHTL特有的数据
    templates_.clear();
    customs_.clear();
    
    // 重置命名空间
    rootNamespace_ = std::make_shared<NamespaceInfo>();
    rootNamespace_->name = "root";
    rootNamespace_->fullPath = "";
    currentNamespace_ = rootNamespace_;
    
    // 清空其他数据
    importedFiles_.clear();
    while (!elementStack_.empty()) {
        elementStack_.pop();
    }
    keywordAliases_.clear();
    constraints_.clear();
    autoGeneratedClasses_.clear();
    autoGeneratedIds_.clear();
}

void ChtlContext::printDebugInfo() const {
    BasicContext::printDebugInfo();
    
    // 打印CHTL特有信息
    std::cout << "\n=== CHTL Context Info ===" << std::endl;
    
    // 打印模板
    std::cout << "\nTemplates:" << std::endl;
    for (const auto& [name, info] : templates_) {
        std::cout << "  " << name << " (type: " << info.type 
                  << ", line: " << info.defineLine << ")" << std::endl;
        if (!info.inheritFrom.empty()) {
            std::cout << "    Inherits from: ";
            for (const auto& base : info.inheritFrom) {
                std::cout << base << " ";
            }
            std::cout << std::endl;
        }
    }
    
    // 打印自定义
    std::cout << "\nCustoms:" << std::endl;
    for (const auto& [name, info] : customs_) {
        std::cout << "  " << name << " (type: " << info.type 
                  << ", line: " << info.defineLine << ")" << std::endl;
        if (!info.inheritFrom.empty()) {
            std::cout << "    Inherits from: ";
            for (const auto& base : info.inheritFrom) {
                std::cout << base << " ";
            }
            std::cout << std::endl;
        }
    }
    
    // 打印命名空间
    std::cout << "\nCurrent Namespace: " << getCurrentNamespacePath() << std::endl;
    
    // 打印导入的文件
    if (!importedFiles_.empty()) {
        std::cout << "\nImported Files:" << std::endl;
        for (const auto& file : importedFiles_) {
            std::cout << "  " << file << std::endl;
        }
    }
    
    // 打印元素栈
    if (!elementStack_.empty()) {
        std::cout << "\nElement Stack:" << std::endl;
        auto tempStack = elementStack_;
        while (!tempStack.empty()) {
            std::cout << "  " << tempStack.top() << std::endl;
            tempStack.pop();
        }
    }
}

bool ChtlContext::addTemplate(const std::string& name, const TemplateInfo& info) {
    if (hasTemplate(name)) {
        addError(formatError("Template '" + name + "' already exists", 
                           info.defineLine, info.defineColumn));
        return false;
    }
    
    templates_[name] = info;
    
    // 同时添加到当前命名空间
    if (currentNamespace_) {
        currentNamespace_->templates[name] = info;
    }
    
    return true;
}

bool ChtlContext::hasTemplate(const std::string& name) const {
    return templates_.find(name) != templates_.end();
}

TemplateInfo* ChtlContext::getTemplate(const std::string& name) {
    auto it = templates_.find(name);
    if (it != templates_.end()) {
        return &it->second;
    }
    return nullptr;
}

const TemplateInfo* ChtlContext::getTemplate(const std::string& name) const {
    auto it = templates_.find(name);
    if (it != templates_.end()) {
        return &it->second;
    }
    return nullptr;
}

bool ChtlContext::addCustom(const std::string& name, const CustomInfo& info) {
    if (hasCustom(name)) {
        addError(formatError("Custom '" + name + "' already exists", 
                           info.defineLine, info.defineColumn));
        return false;
    }
    
    customs_[name] = info;
    
    // 同时添加到当前命名空间
    if (currentNamespace_) {
        currentNamespace_->customs[name] = info;
    }
    
    return true;
}

bool ChtlContext::hasCustom(const std::string& name) const {
    return customs_.find(name) != customs_.end();
}

CustomInfo* ChtlContext::getCustom(const std::string& name) {
    auto it = customs_.find(name);
    if (it != customs_.end()) {
        return &it->second;
    }
    return nullptr;
}

const CustomInfo* ChtlContext::getCustom(const std::string& name) const {
    auto it = customs_.find(name);
    if (it != customs_.end()) {
        return &it->second;
    }
    return nullptr;
}

void ChtlContext::enterNamespace(const std::string& name) {
    auto newNamespace = std::make_shared<NamespaceInfo>();
    newNamespace->name = name;
    newNamespace->parent = currentNamespace_;
    
    // 构建完整路径
    if (currentNamespace_->fullPath.empty()) {
        newNamespace->fullPath = name;
    } else {
        newNamespace->fullPath = currentNamespace_->fullPath + "." + name;
    }
    
    // 添加到父命名空间
    currentNamespace_->subNamespaces[name] = newNamespace;
    
    // 切换当前命名空间
    currentNamespace_ = newNamespace;
}

void ChtlContext::exitNamespace() {
    if (currentNamespace_ && currentNamespace_->parent) {
        currentNamespace_ = currentNamespace_->parent;
    }
}

std::string ChtlContext::getCurrentNamespacePath() const {
    return currentNamespace_ ? currentNamespace_->fullPath : "";
}

bool ChtlContext::addImport(const std::string& filePath) {
    if (isImported(filePath)) {
        return false;
    }
    importedFiles_.insert(filePath);
    return true;
}

bool ChtlContext::isImported(const std::string& filePath) const {
    return importedFiles_.find(filePath) != importedFiles_.end();
}

void ChtlContext::pushElement(const std::string& element) {
    elementStack_.push(element);
}

void ChtlContext::popElement() {
    if (!elementStack_.empty()) {
        elementStack_.pop();
    }
}

std::string ChtlContext::getCurrentElement() const {
    return elementStack_.empty() ? "" : elementStack_.top();
}

bool ChtlContext::isInElement(const std::string& element) const {
    auto tempStack = elementStack_;
    while (!tempStack.empty()) {
        if (tempStack.top() == element) {
            return true;
        }
        tempStack.pop();
    }
    return false;
}

void ChtlContext::addKeywordAlias(const std::string& keyword, const std::string& alias) {
    keywordAliases_[keyword].push_back(alias);
}

void ChtlContext::setKeywordAliases(const std::string& keyword, const std::vector<std::string>& aliases) {
    keywordAliases_[keyword] = aliases;
}

std::vector<std::string> ChtlContext::getKeywordAliases(const std::string& keyword) const {
    auto it = keywordAliases_.find(keyword);
    if (it != keywordAliases_.end()) {
        return it->second;
    }
    return std::vector<std::string>();
}

void ChtlContext::addConstraint(const ConstraintRule& rule) {
    constraints_.push_back(rule);
}

bool ChtlContext::checkConstraint(const std::string& element) const {
    for (const auto& rule : constraints_) {
        if (rule.scope == getCurrentScope()->type || rule.scope == ScopeType::GLOBAL) {
            if (rule.exceptElements.find(element) != rule.exceptElements.end()) {
                return false;
            }
        }
    }
    return true;
}

bool ChtlContext::checkConstraint(TokenType type) const {
    // TODO: 实现类型约束检查
    (void)type; // 避免未使用参数警告
    return true;
}

void ChtlContext::addAutoGeneratedClass(const std::string& className) {
    autoGeneratedClasses_.insert(className);
}

void ChtlContext::addAutoGeneratedId(const std::string& id) {
    autoGeneratedIds_.insert(id);
}

bool ChtlContext::isAutoGeneratedClass(const std::string& className) const {
    return autoGeneratedClasses_.find(className) != autoGeneratedClasses_.end();
}

bool ChtlContext::isAutoGeneratedId(const std::string& id) const {
    return autoGeneratedIds_.find(id) != autoGeneratedIds_.end();
}

bool ChtlContext::validateTemplate(const TemplateInfo& info) const {
    // 验证模板名称
    if (info.name.empty()) {
        const_cast<ChtlContext*>(this)->addError("Template name cannot be empty");
        return false;
    }
    
    // 验证继承关系
    if (!validateInheritance(info.inheritFrom, true)) {
        return false;
    }
    
    // 根据模板类型进行特定验证
    switch (info.type) {
        case TemplateInfo::STYLE_TEMPLATE:
            // 验证样式属性
            for (const auto& [prop, value] : info.properties) {
                if (prop.empty()) {
                    const_cast<ChtlContext*>(this)->addError(
                        formatError("Empty property name in template '" + info.name + "'", 
                                  info.defineLine, info.defineColumn));
                    return false;
                }
            }
            break;
            
        case TemplateInfo::ELEMENT_TEMPLATE:
            // 验证元素列表
            if (info.elements.empty()) {
                const_cast<ChtlContext*>(this)->addWarning(
                    formatWarning("Element template '" + info.name + "' has no elements", 
                                info.defineLine, info.defineColumn));
            }
            break;
            
        case TemplateInfo::VAR_TEMPLATE:
            // 验证变量
            for (const auto& [var, value] : info.properties) {
                if (var.empty() || value.empty()) {
                    const_cast<ChtlContext*>(this)->addError(
                        formatError("Invalid variable definition in template '" + info.name + "'", 
                                  info.defineLine, info.defineColumn));
                    return false;
                }
            }
            break;
    }
    
    return true;
}

bool ChtlContext::validateCustom(const CustomInfo& info) const {
    // 验证自定义名称
    if (info.name.empty()) {
        const_cast<ChtlContext*>(this)->addError("Custom name cannot be empty");
        return false;
    }
    
    // 验证继承关系
    if (!validateInheritance(info.inheritFrom, false)) {
        return false;
    }
    
    // 自定义特有的验证
    if (info.hasUnsetProperties) {
        // 检查是否所有未设置的属性在使用时都被设置了
        // TODO: 实现此验证
    }
    
    return true;
}

bool ChtlContext::validateInheritance(const std::set<std::string>& inheritFrom, bool isTemplate) const {
    for (const auto& base : inheritFrom) {
        if (isTemplate) {
            if (!hasTemplate(base)) {
                const_cast<ChtlContext*>(this)->addError(
                    "Template '" + base + "' not found for inheritance");
                return false;
            }
        } else {
            // 自定义可以继承模板或其他自定义
            if (!hasTemplate(base) && !hasCustom(base)) {
                const_cast<ChtlContext*>(this)->addError(
                    "Template or Custom '" + base + "' not found for inheritance");
                return false;
            }
        }
    }
    
    // TODO: 检查循环继承
    
    return true;
}

TemplateInfo* ChtlContext::lookupTemplate(const std::string& name, const std::string& namespacePath) {
    // 如果指定了命名空间路径
    if (!namespacePath.empty()) {
        auto ns = findNamespace(namespacePath);
        if (ns) {
            auto it = ns->templates.find(name);
            if (it != ns->templates.end()) {
                return &it->second;
            }
        }
        return nullptr;
    }
    
    // 在当前命名空间查找
    auto ns = currentNamespace_;
    while (ns) {
        auto it = ns->templates.find(name);
        if (it != ns->templates.end()) {
            return &it->second;
        }
        ns = ns->parent;
    }
    
    // 在全局模板中查找
    return getTemplate(name);
}

CustomInfo* ChtlContext::lookupCustom(const std::string& name, const std::string& namespacePath) {
    // 如果指定了命名空间路径
    if (!namespacePath.empty()) {
        auto ns = findNamespace(namespacePath);
        if (ns) {
            auto it = ns->customs.find(name);
            if (it != ns->customs.end()) {
                return &it->second;
            }
        }
        return nullptr;
    }
    
    // 在当前命名空间查找
    auto ns = currentNamespace_;
    while (ns) {
        auto it = ns->customs.find(name);
        if (it != ns->customs.end()) {
            return &it->second;
        }
        ns = ns->parent;
    }
    
    // 在全局自定义中查找
    return getCustom(name);
}

std::shared_ptr<NamespaceInfo> ChtlContext::findOrCreateNamespace(const std::string& path) {
    if (path.empty()) {
        return rootNamespace_;
    }
    
    // 分割路径
    std::vector<std::string> parts;
    std::stringstream ss(path);
    std::string part;
    while (std::getline(ss, part, '.')) {
        parts.push_back(part);
    }
    
    // 从根开始查找或创建
    auto current = rootNamespace_;
    for (const auto& name : parts) {
        auto it = current->subNamespaces.find(name);
        if (it != current->subNamespaces.end()) {
            current = it->second;
        } else {
            // 创建新的命名空间
            auto newNs = std::make_shared<NamespaceInfo>();
            newNs->name = name;
            newNs->parent = current;
            newNs->fullPath = current->fullPath.empty() ? name : current->fullPath + "." + name;
            current->subNamespaces[name] = newNs;
            current = newNs;
        }
    }
    
    return current;
}

std::shared_ptr<NamespaceInfo> ChtlContext::findNamespace(const std::string& path) const {
    if (path.empty()) {
        return rootNamespace_;
    }
    
    // 分割路径
    std::vector<std::string> parts;
    std::stringstream ss(path);
    std::string part;
    while (std::getline(ss, part, '.')) {
        parts.push_back(part);
    }
    
    // 从根开始查找
    auto current = rootNamespace_;
    for (const auto& name : parts) {
        auto it = current->subNamespaces.find(name);
        if (it != current->subNamespaces.end()) {
            current = it->second;
        } else {
            return nullptr;
        }
    }
    
    return current;
}

void ChtlContext::collectAllTemplates(std::unordered_map<std::string, TemplateInfo>& result) const {
    // 收集所有命名空间中的模板
    std::function<void(const std::shared_ptr<NamespaceInfo>&)> collect = 
        [&](const std::shared_ptr<NamespaceInfo>& ns) {
            for (const auto& [name, info] : ns->templates) {
                std::string fullName = ns->fullPath.empty() ? name : ns->fullPath + "." + name;
                result[fullName] = info;
            }
            for (const auto& [subName, subNs] : ns->subNamespaces) {
                collect(subNs);
            }
        };
    
    collect(rootNamespace_);
}

void ChtlContext::collectAllCustoms(std::unordered_map<std::string, CustomInfo>& result) const {
    // 收集所有命名空间中的自定义
    std::function<void(const std::shared_ptr<NamespaceInfo>&)> collect = 
        [&](const std::shared_ptr<NamespaceInfo>& ns) {
            for (const auto& [name, info] : ns->customs) {
                std::string fullName = ns->fullPath.empty() ? name : ns->fullPath + "." + name;
                result[fullName] = info;
            }
            for (const auto& [subName, subNs] : ns->subNamespaces) {
                collect(subNs);
            }
        };
    
    collect(rootNamespace_);
}

} // namespace chtl